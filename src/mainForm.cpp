#include <set>
#include "stdafx_zoli.h"
#include "stdafx_lc.h"
#undef max
using namespace nlib;
#include "application.h"
#include "about.h"
#include "help.h"
#include "history.h"
#include "histopt.h"

#include "graphictext.h"

#include "mainForm.h"
#include "calculate.h"

#include "variables.h"

#include <windows.h>
#include <shlobj.h>
#include <iostream>
#include <userenv.h>	// for getting the user directory on windows

using namespace SmString;
using namespace LongNumber;
using namespace FalconCalc;

FalconCalc::LittleEngine *lengine = nullptr;

Clipboard *MyClipboard;

TfrmMain *frmMain;
const wchar_t *FalconCalc_HIST_FILE = L"FalconCalc.hist";
const wchar_t *FalconCalc_DAT_FILE  = L"FalconCalc.dat";
const wchar_t *FalconCalc_CFG_FILE  = L"FalconCalc.cfg";


#if 0
static inline size_t _HexD2Char(_CHART ch)
{ // ch is one hex digit: 0..9,A..F
    ch -= ((ch > '9') ? 'A'-10 : '0');
    return (size_t)ch;
}

static wstring _StringFromHex(STRING_RESULT sres)
{
    STRING_RESULT r = sres;
    r.type = stHex;
    r.hexFormat = hfNormal;
    r.showAs = shaBytes;
    wstring s = r.ToString();
    if(s[0] == '-')       // wstring may start with '-'
        s = s.substr(1);
    if(s[0] == 'T' || s[0] == 'I')
        return L"";
    size_t j = 0;
    size_t i = 0;
    while(i < s.length()-2)
    {
        s[j] = (_HexD2Char(s[i]) << 4) + _HexD2Char(s[i+1]);
        if(s[j] < ' ' )
            s[j] = '.';
            ++j;
        i+=3;
    }
    s[j++] = (_HexD2Char(s[i]) << 4) + _HexD2Char(s[i+1]);
    return s.substr(0,j);
}
#endif

void TfrmMain::InitializeFormAndControls() /* Control initialization function generated by the designer. Modifications will be lost. */
{
	/* Generated member initialization. Do not modify. */
	SetLeft(777);
	SetTop(436);
	SetText(L"FalconCalc");
	GetFont().SetFamily(L"Tahoma");
	GetFont().SetSize(10);
	SetWantedKeyTypes(nlib::wkArrows | nlib::wkTab | nlib::wkEnter | nlib::wkEscape | nlib::wkOthers);
	SetShowPosition(nlib::fspActiveMonitorCenter);
	SetBorderStyle(nlib::fbsSingle);
	SetClientRect(nlib::Rect(0, 0, 528, 372 + GetSystemMetrics(SM_CYMENU)));

	FontDialog1 = new nlib::FontDialog();
	FontDialog1->GetFont().SetFamily(L"Tahoma");
	FontDialog1->GetFont().SetSize(8);
	FontDialog1->SetParent(this);

	pmCopy = new nlib::PopupMenu();
	miCopyDec = pmCopy->Add(L"Copy &Decimal");
	miCopyHex = pmCopy->Add(L"Copy He&xadecimal");
	miCopyOct = pmCopy->Add(L"Copy &Octal");
	miCopyBin = pmCopy->Add(L"Copy &Binary");
	miCopySep = pmCopy->Add(L"-");
	miCopyText = pmCopy->Add(L"Copy &Formula");
	pmCopy->SetParent(this);

	mnuMain = new nlib::Menubar();
	miFile = mnuMain->Add(L"&File");
	miExit = miFile->Add(L"E&xit");
	miExit->SetShortcut(L"Alt+X");
	miEdit = mnuMain->Add(L"&Edit");
	miCopy = miEdit->Add(L"&Copy");
	miCopy->SetShortcutText(L"Ctrl+C");
	miPaste = miEdit->Add(L"&Paste");
	miPaste->SetShortcutText(L"Ctrl+V");
	miAppend = miEdit->Add(L"Paste &After");
	MenuItem1 = miEdit->Add(L"-");
	miCopyDecimal = miEdit->Add(L"Copy &Decimal");
	miCopyHexadecimal = miEdit->Add(L"Copy &Hexadecimal");
	miCopyHexadecimal->SetTag(1);
	miCopyOctal = miEdit->Add(L"Copy &Octal");
	miCopyOctal->SetTag(2);
	miCopyBinary = miEdit->Add(L"Copy &Binary");
	miCopyBinary->SetTag(3);
	MenuItem2 = miEdit->Add(L"-");
	miEditVars = miEdit->Add(L"Edit User &Variables...");
	miEditVars->SetTag(1);
	miEditVars->SetShortcut(L"Alt+V");
	miEditFuncs = miEdit->Add(L"Edit User &Functions...");
	miEditFuncs->SetShortcut(L"Alt+F");
	MenuItem3 = miEdit->Add(L"-");
	miShowHist = miEdit->Add(L"Edit &History");
	miShowHist->SetShortcut(L"Alt+H");
	miClearHist = miEdit->Add(L"C&lear History");
	miOptions = mnuMain->Add(L"&Options");
	miShowDecOpts = miOptions->Add(L"Show &Decimal Options");
	miShowDecOpts->SetShortcutText(L"Ctrl+D");
	miShowHexOpts = miOptions->Add(L"Show &Hexadecimal  Options");
	miShowHexOpts->SetShortcut(L"Ctrl+X");
	miCharFont = miOptions->Add(L"&Font For 'As String...' Display");
	miHistOpts = miOptions->Add(L"Histor&y Options...");
	miHelp = mnuMain->Add(L"&Help");
	miAbout = miHelp->Add(L"&About");
	miGenHelp = miHelp->Add(L"&General Help");
	miGenHelp->SetShortcut(L"F1");
	mnuMain->SetParent(this);

	btnOpenHexOptions = new nlib::FlatButton();
	btnOpenHexOptions->SetBounds(nlib::Rect(14, 279, 242, 291));
	btnOpenHexOptions->SetText(L"-----------Hex. options------------------");
	btnOpenHexOptions->SetVisible(false);
	btnOpenHexOptions->GetFont().SetFamily(L"Tahoma");
	btnOpenHexOptions->GetFont().SetSize(10);
	btnOpenHexOptions->SetParentFont(false);
	btnOpenHexOptions->SetTabOrder(10);
	btnOpenHexOptions->SetParent(this);

	btnOpenDecOptions = new nlib::FlatButton();
	btnOpenDecOptions->SetBounds(nlib::Rect(14, 175, 242, 187));
	btnOpenDecOptions->SetText(L"-----------Decimal options--------------");
	btnOpenDecOptions->SetVisible(false);
	btnOpenDecOptions->GetFont().SetFamily(L"Tahoma");
	btnOpenDecOptions->GetFont().SetSize(10);
	btnOpenDecOptions->SetParentFont(false);
	btnOpenDecOptions->SetTabOrder(9);
	btnOpenDecOptions->SetParent(this);

	pToolbar = new nlib::Panel();
	pToolbar->SetBounds(nlib::Rect(0, 0, 528, 29));
	pToolbar->SetAlignment(nlib::alTop);
	pToolbar->SetTabOrder(1);
	pToolbar->SetInnerBorderStyle(nlib::pbsNone);
	pToolbar->SetParent(this);

	tbExit = new nlib::FlatButton();
	tbExit->SetBounds(nlib::Rect(0, 0, 23, 23));
	tbExit->GetFont().SetFamily(L"Tahoma");
	tbExit->GetFont().SetSize(10);
	tbExit->SetParentFont(false);
	tbExit->SetTabOrder(0);
	tbExit->SetParent(pToolbar);

	Bevel1 = new nlib::Bevel();
	Bevel1->SetBounds(nlib::Rect(26, 1, 28, 22));
	Bevel1->SetShape(nlib::bstLeftLine);
	Bevel1->SetParent(pToolbar);

	tbHistory = new nlib::FlatButton();
	tbHistory->SetBounds(nlib::Rect(31, 0, 54, 23));
	tbHistory->GetFont().SetFamily(L"Tahoma");
	tbHistory->GetFont().SetSize(10);
	tbHistory->SetParentFont(false);
	tbHistory->SetTabOrder(1);
	tbHistory->SetParent(pToolbar);

	tbCopy = new nlib::FlatButton();
	tbCopy->SetBounds(nlib::Rect(55, 0, 78, 23));
	tbCopy->GetFont().SetFamily(L"Tahoma");
	tbCopy->GetFont().SetSize(10);
	tbCopy->SetParentFont(false);
	tbCopy->SetTabOrder(2);
	tbCopy->SetParent(pToolbar);

	tbPaste = new nlib::FlatButton();
	tbPaste->SetBounds(nlib::Rect(79, 0, 102, 23));
	tbPaste->SetEnabled(false);
	tbPaste->GetFont().SetFamily(L"Tahoma");
	tbPaste->GetFont().SetSize(10);
	tbPaste->SetParentFont(false);
	tbPaste->SetTabOrder(3);
	tbPaste->SetParent(pToolbar);

	edtInfix = new nlib::Edit();
	edtInfix->SetBounds(nlib::Rect(8, 29, 513, 50));
	edtInfix->GetFont().SetFamily(L"Tahoma");
	edtInfix->GetFont().SetSize(10);
	edtInfix->SetParentFont(false);
	edtInfix->SetTabOrder(0);
	edtInfix->SetParent(this);

	gbResults = new nlib::Groupbox();
	gbResults->SetBounds(nlib::Rect(16, 52, 521, 175));
	gbResults->SetText(L"Result");
	gbResults->SetPadding(nlib::Rect(0, 0, 0, 0));
	gbResults->GetFont().SetFamily(L"Tahoma");
	gbResults->GetFont().SetSize(10);
	gbResults->SetParentFont(false);
	gbResults->SetTabOrder(2);
	gbResults->SetParent(this);

	btnDecimal = new nlib::Button();
	btnDecimal->SetBounds(nlib::Rect(1, 16, 80, 39));
	btnDecimal->SetText(L"Deci&mal");
	btnDecimal->SetTabOrder(1);
	btnDecimal->SetTooltipText(L"Copy decimal number to clipboard");
	btnDecimal->SetParent(gbResults);

	btnHexadecimal = new nlib::Button();
	btnHexadecimal->SetTag(1);
	btnHexadecimal->SetBounds(nlib::Rect(1, 41, 80, 64));
	btnHexadecimal->SetText(L"&Hexadecimal");
	btnHexadecimal->SetTabOrder(2);
	btnHexadecimal->SetTooltipText(L"Copy hexadec. number to clipboard");
	btnHexadecimal->SetParent(gbResults);

	btnOctal = new nlib::Button();
	btnOctal->SetTag(2);
	btnOctal->SetBounds(nlib::Rect(2, 67, 81, 90));
	btnOctal->SetText(L"O&ctal");
	btnOctal->SetTabOrder(4);
	btnOctal->SetTooltipText(L"Copy octal number to clipboard");
	btnOctal->SetParent(gbResults);

	btnBinary = new nlib::Button();
	btnBinary->SetTag(3);
	btnBinary->SetBounds(nlib::Rect(2, 94, 81, 117));
	btnBinary->SetText(L"&Binary");
	btnBinary->SetTabOrder(6);
	btnBinary->SetTooltipText(L"Copy binary number to clipboard");
	btnBinary->SetParent(gbResults);

	pnlDec = new nlib::Panel();
	pnlDec->SetBounds(nlib::Rect(83, 15, 500, 40));
	pnlDec->GetFont().SetFamily(L"Arial");
	pnlDec->GetFont().SetSize(10);
	pnlDec->GetFont().SetCharacterSet(nlib::fcsAnsi);
	pnlDec->GetFont().SetOutputQuality(nlib::foqDraft);
	pnlDec->SetParentFont(false);
	pnlDec->SetTabOrder(0);
	pnlDec->SetShowText(false);
	pnlDec->SetInnerBorderStyle(nlib::pbsSunken);
	pnlDec->SetTextAlignment(nlib::taRight);
	pnlDec->SetParent(gbResults);

	pnlHex = new nlib::Panel();
	pnlHex->SetBounds(nlib::Rect(83, 41, 500, 66));
	pnlHex->GetFont().SetFamily(L"Arial");
	pnlHex->GetFont().SetSize(10);
	pnlHex->SetParentFont(false);
	pnlHex->SetTabOrder(3);
	pnlHex->SetInnerBorderStyle(nlib::pbsSunken);
	pnlHex->SetTextAlignment(nlib::taRight);
	pnlHex->SetParent(gbResults);

	pnlOct = new nlib::Panel();
	pnlOct->SetBounds(nlib::Rect(83, 67, 500, 92));
	pnlOct->GetFont().SetFamily(L"Arial");
	pnlOct->GetFont().SetSize(10);
	pnlOct->SetParentFont(false);
	pnlOct->SetTabOrder(5);
	pnlOct->SetInnerBorderStyle(nlib::pbsSunken);
	pnlOct->SetTextAlignment(nlib::taRight);
	pnlOct->SetParent(gbResults);

	pnlBin = new nlib::Panel();
	pnlBin->SetBounds(nlib::Rect(83, 93, 500, 118));
	pnlBin->GetFont().SetFamily(L"Arial");
	pnlBin->GetFont().SetSize(10);
	pnlBin->SetParentFont(false);
	pnlBin->SetTabOrder(7);
	pnlBin->SetInnerBorderStyle(nlib::pbsSunken);
	pnlBin->SetTextAlignment(nlib::taRight);
	pnlBin->SetParent(gbResults);

	pnlDecOpt = new nlib::Panel();
	pnlDecOpt->SetBounds(nlib::Rect(8, 191, 513, 277));
	pnlDecOpt->SetTabOrder(3);
	pnlDecOpt->SetInnerBorderStyle(nlib::pbsNone);
	pnlDecOpt->SetParent(this);

	Groupbox1 = new nlib::Groupbox();
	Groupbox1->SetBounds(nlib::Rect(11, 1, 230, 89));
	Groupbox1->SetText(L"Decimal options");
	Groupbox1->SetPadding(nlib::Rect(0, 0, 0, 0));
	Groupbox1->GetFont().SetFamily(L"Tahoma");
	Groupbox1->GetFont().SetSize(10);
	Groupbox1->SetParentFont(false);
	Groupbox1->SetTabOrder(0);
	Groupbox1->SetParent(pnlDecOpt);

	chkSep = new nlib::Checkbox();
	chkSep->SetBounds(nlib::Rect(8, 16, 165, 33));
	chkSep->SetText(L"Use t&housand separator:");
	chkSep->GetFont().SetFamily(L"Tahoma");
	chkSep->GetFont().SetSize(10);
	chkSep->SetParentFont(false);
	chkSep->SetTabOrder(0);
	chkSep->SetState(nlib::csChecked);
	chkSep->SetParent(Groupbox1);

	cbThousandSep = new nlib::Combobox();
	cbThousandSep->SetBounds(nlib::Rect(168, 16, 215, 40));
	cbThousandSep->SetText(L"spc");
	cbThousandSep->GetFont().SetFamily(L"Tahoma");
	cbThousandSep->GetFont().SetSize(10);
	cbThousandSep->SetParentFont(false);
	cbThousandSep->SetTabOrder(1);
	cbThousandSep->SetType(nlib::ctDropdownList);
	cbThousandSep->Items().Add(L"spc");
	cbThousandSep->Items().Add(L",");
	cbThousandSep->Items().Add(L".");
	cbThousandSep->Items().Add(L";");
	cbThousandSep->SetItemIndex(0);
	cbThousandSep->SetParent(Groupbox1);

	chkSci = new nlib::Checkbox();
	chkSci->SetBounds(nlib::Rect(8, 32, 141, 49));
	chkSci->SetText(L"&Scientific format");
	chkSci->GetFont().SetFamily(L"Tahoma");
	chkSci->GetFont().SetSize(10);
	chkSci->SetParentFont(false);
	chkSci->SetTabOrder(2);
	chkSci->SetParent(Groupbox1);

	chkEng = new nlib::Checkbox();
	chkEng->SetBounds(nlib::Rect(8, 48, 149, 65));
	chkEng->SetText(L"Engeneering f&ormat");
	chkEng->GetFont().SetFamily(L"Tahoma");
	chkEng->GetFont().SetSize(10);
	chkEng->SetParentFont(false);
	chkEng->SetTabOrder(3);
	chkEng->SetParent(Groupbox1);

	chkDecDigits = new nlib::Checkbox();
	chkDecDigits->SetBounds(nlib::Rect(8, 64, 149, 81));
	chkDecDigits->SetText(L"&Decimal digits:");
	chkDecDigits->GetFont().SetFamily(L"Tahoma");
	chkDecDigits->GetFont().SetSize(10);
	chkDecDigits->SetParentFont(false);
	chkDecDigits->SetTabOrder(4);
	chkDecDigits->SetParent(Groupbox1);

	spnDecDigits = new nlib::Edit();
	spnDecDigits->SetBounds(nlib::Rect(141, 63, 178, 84));
	spnDecDigits->SetText(L"0");
	spnDecDigits->GetFont().SetFamily(L"Tahoma");
	spnDecDigits->GetFont().SetSize(10);
	spnDecDigits->SetParentFont(false);
	spnDecDigits->SetTabOrder(5);
	spnDecDigits->SetParent(Groupbox1);

	UpDownDecDigits = new nlib::UpDown();
	UpDownDecDigits->SetBounds(nlib::Rect(177, 63, 194, 84));
	UpDownDecDigits->SetMaxValue(80);
	UpDownDecDigits->SetParent(Groupbox1);

	rgAngleUnit = new nlib::Groupbox();
	rgAngleUnit->SetBounds(nlib::Rect(236, 7, 428, 53));
	rgAngleUnit->SetText(L"Angles in");
	rgAngleUnit->SetPadding(nlib::Rect(0, 0, 0, 0));
	rgAngleUnit->GetFont().SetFamily(L"Tahoma");
	rgAngleUnit->GetFont().SetSize(10);
	rgAngleUnit->SetParentFont(false);
	rgAngleUnit->SetTabOrder(1);
	rgAngleUnit->SetParent(pnlDecOpt);

	rdDeg = new nlib::Radiobox();
	rdDeg->SetTag(1);
	rdDeg->SetBounds(nlib::Rect(11, 19, 59, 35));
	rdDeg->SetText(L"De&g");
	rdDeg->GetFont().SetFamily(L"Tahoma");
	rdDeg->GetFont().SetSize(10);
	rdDeg->SetParentFont(false);
	rdDeg->SetTabOrder(0);
	rdDeg->SetChecked(true);
	rdDeg->SetParent(rgAngleUnit);

	rdGrad = new nlib::Radiobox();
	rdGrad->SetTag(2);
	rdGrad->SetBounds(nlib::Rect(59, 19, 115, 35));
	rdGrad->SetText(L"&Grad");
	rdGrad->GetFont().SetFamily(L"Tahoma");
	rdGrad->GetFont().SetSize(10);
	rdGrad->SetParentFont(false);
	rdGrad->SetTabOrder(1);
	rdGrad->SetParent(rgAngleUnit);

	rdRad = new nlib::Radiobox();
	rdRad->SetTag(0);
	rdRad->SetBounds(nlib::Rect(123, 19, 187, 35));
	rdRad->SetText(L"&Rad");
	rdRad->GetFont().SetFamily(L"Tahoma");
	rdRad->GetFont().SetSize(10);
	rdRad->SetParentFont(false);
	rdRad->SetTabOrder(2);
	rdRad->SetParent(rgAngleUnit);

	Groupbox3 = new nlib::Groupbox();
	Groupbox3->SetBounds(nlib::Rect(236, 47, 492, 93));
	Groupbox3->SetText(L"Display");
	Groupbox3->SetPadding(nlib::Rect(0, 0, 0, 0));
	Groupbox3->GetFont().SetFamily(L"Tahoma");
	Groupbox3->GetFont().SetSize(10);
	Groupbox3->SetParentFont(false);
	Groupbox3->SetTabOrder(2);
	Groupbox3->SetParent(pnlDecOpt);

	rdNormal = new nlib::Radiobox();
	rdNormal->SetBounds(nlib::Rect(11, 19, 91, 35));
	rdNormal->SetText(L"Norm&al");
	rdNormal->GetFont().SetFamily(L"Tahoma");
	rdNormal->GetFont().SetSize(10);
	rdNormal->SetParentFont(false);
	rdNormal->SetTabOrder(0);
	rdNormal->SetChecked(true);
	rdNormal->SetParent(Groupbox3);

	rdHtml = new nlib::Radiobox();
	rdHtml->SetTag(1);
	rdHtml->SetBounds(nlib::Rect(77, 20, 141, 36));
	rdHtml->SetText(L"&HTML");
	rdHtml->GetFont().SetFamily(L"Tahoma");
	rdHtml->GetFont().SetSize(10);
	rdHtml->SetParentFont(false);
	rdHtml->SetTabOrder(1);
	rdHtml->SetParent(Groupbox3);

	rdTex = new nlib::Radiobox();
	rdTex->SetTag(2);
	rdTex->SetBounds(nlib::Rect(142, 20, 190, 36));
	rdTex->SetText(L"&TeX");
	rdTex->GetFont().SetFamily(L"Tahoma");
	rdTex->GetFont().SetSize(10);
	rdTex->SetParentFont(false);
	rdTex->SetTabOrder(2);
	rdTex->SetParent(Groupbox3);

	rdNone = new nlib::Radiobox();
	rdNone->SetTag(3);
	rdNone->SetBounds(nlib::Rect(198, 20, 238, 36));
	rdNone->SetText(L"E");
	rdNone->SetTabOrder(3);
	rdNone->SetParent(Groupbox3);

	pnlHexOpt = new nlib::Panel();
	pnlHexOpt->SetBounds(nlib::Rect(8, 293, 515, 375));
	pnlHexOpt->SetTabOrder(4);
	pnlHexOpt->SetInnerBorderStyle(nlib::pbsNone);
	pnlHexOpt->SetParent(this);

	Groupbox2 = new nlib::Groupbox();
	Groupbox2->SetBounds(nlib::Rect(8, 1, 337, 75));
	Groupbox2->SetText(L"Hexadecimal Options");
	Groupbox2->SetPadding(nlib::Rect(0, 0, 0, 0));
	Groupbox2->GetFont().SetFamily(L"Tahoma");
	Groupbox2->GetFont().SetSize(10);
	Groupbox2->SetParentFont(false);
	Groupbox2->SetTabOrder(0);
	Groupbox2->SetParent(pnlHexOpt);

	chkMinus = new nlib::Checkbox();
	chkMinus->SetBounds(nlib::Rect(16, 18, 102, 35));
	chkMinus->SetText(L"M&inus sign");
	chkMinus->GetFont().SetFamily(L"Tahoma");
	chkMinus->GetFont().SetSize(10);
	chkMinus->SetParentFont(false);
	chkMinus->SetTabOrder(0);
	chkMinus->SetTooltipText(L"Absolute value of negative numbers are shown with a minus sign");
	chkMinus->SetParent(Groupbox2);

	chkLittleEndian = new nlib::Checkbox();
	chkLittleEndian->SetTag(6);
	chkLittleEndian->SetBounds(nlib::Rect(16, 52, 102, 69));
	chkLittleEndian->SetText(L"&Little endian");
	chkLittleEndian->GetFont().SetFamily(L"Tahoma");
	chkLittleEndian->GetFont().SetSize(10);
	chkLittleEndian->SetParentFont(false);
	chkLittleEndian->SetTabOrder(1);
	chkLittleEndian->SetTooltipText(L"Left to right order of bytes from least significant to most significant (Intel ordering)");
	chkLittleEndian->SetParent(Groupbox2);

	chkBytes = new nlib::Checkbox();
	chkBytes->SetTag(1);
	chkBytes->SetBounds(nlib::Rect(116, 18, 202, 35));
	chkBytes->SetText(L"As B&ytes");
	chkBytes->GetFont().SetFamily(L"Tahoma");
	chkBytes->GetFont().SetSize(10);
	chkBytes->SetParentFont(false);
	chkBytes->SetTabOrder(2);
	chkBytes->SetParent(Groupbox2);

	chkWords = new nlib::Checkbox();
	chkWords->SetTag(2);
	chkWords->SetBounds(nlib::Rect(116, 35, 202, 52));
	chkWords->SetText(L"As &Words");
	chkWords->GetFont().SetFamily(L"Tahoma");
	chkWords->GetFont().SetSize(10);
	chkWords->SetParentFont(false);
	chkWords->SetTabOrder(3);
	chkWords->SetParent(Groupbox2);

	chkDWords = new nlib::Checkbox();
	chkDWords->SetTag(3);
	chkDWords->SetBounds(nlib::Rect(116, 52, 202, 69));
	chkDWords->SetText(L"As DWo&rds");
	chkDWords->GetFont().SetFamily(L"Tahoma");
	chkDWords->GetFont().SetSize(10);
	chkDWords->SetParentFont(false);
	chkDWords->SetTabOrder(4);
	chkDWords->SetParent(Groupbox2);

	chkIEEESingle = new nlib::Checkbox();
	chkIEEESingle->SetTag(4);
	chkIEEESingle->SetBounds(nlib::Rect(203, 18, 321, 35));
	chkIEEESingle->SetText(L"As IEE &754 single");
	chkIEEESingle->GetFont().SetFamily(L"Tahoma");
	chkIEEESingle->GetFont().SetSize(10);
	chkIEEESingle->SetParentFont(false);
	chkIEEESingle->SetTabOrder(5);
	chkIEEESingle->SetTooltipText(L"Single precision floating point format");
	chkIEEESingle->SetParent(Groupbox2);

	chkIEEEDouble = new nlib::Checkbox();
	chkIEEEDouble->SetTag(5);
	chkIEEEDouble->SetBounds(nlib::Rect(203, 35, 321, 52));
	chkIEEEDouble->SetText(L"As IEE 7&54 double");
	chkIEEEDouble->GetFont().SetFamily(L"Tahoma");
	chkIEEEDouble->GetFont().SetSize(10);
	chkIEEEDouble->SetParentFont(false);
	chkIEEEDouble->SetTabOrder(6);
	chkIEEEDouble->SetTooltipText(L"Double precision floating point format");
	chkIEEEDouble->SetParent(Groupbox2);

	cbInfix = new nlib::Combobox();
	cbInfix->SetBounds(nlib::Rect(357, 21, 493, 45));
	cbInfix->SetTabOrder(1);
	cbInfix->Items().Add(L"");
	cbInfix->Items().Add(L"1234*5678");
	cbInfix->Items().Add(L"9876*1245.9");
	cbInfix->SetParent(pnlHexOpt);

	Label1 = new nlib::Label();
	Label1->SetBounds(nlib::Rect(256, 177, 313, 193));
	Label1->SetText(L"As String:");
	Label1->GetFont().SetFamily(L"Tahoma");
	Label1->GetFont().SetSize(10);
	Label1->SetParentFont(false);
	Label1->SetParent(this);

	edtChars = new nlib::Edit();
	edtChars->SetBounds(nlib::Rect(317, 176, 438, 197));
	edtChars->GetFont().SetFamily(L"Tahoma");
	edtChars->GetFont().SetSize(10);
	edtChars->SetParentFont(false);
	edtChars->SetTabOrder(5);
	edtChars->SetReadOnly(true);
	edtChars->SetParent(this);

	btnFont = new nlib::FlatButton();
	btnFont->SetBounds(nlib::Rect(440, 175, 508, 198));
	btnFont->SetText(L"&Font...");
	btnFont->GetFont().SetFamily(L"Tahoma");
	btnFont->GetFont().SetSize(10);
	btnFont->SetParentFont(false);
	btnFont->SetTabOrder(6);
	btnFont->SetAcceptInput(true);
	btnFont->SetFlat(false);
	btnFont->SetParent(this);

	btnCloseDecOptions = new nlib::FlatButton();
	btnCloseDecOptions->SetBounds(nlib::Rect(14, 175, 242, 187));
	btnCloseDecOptions->SetText(L"-------------------------------------------");
	btnCloseDecOptions->GetFont().SetFamily(L"Tahoma");
	btnCloseDecOptions->GetFont().SetSize(10);
	btnCloseDecOptions->SetParentFont(false);
	btnCloseDecOptions->SetTabOrder(7);
	btnCloseDecOptions->SetParent(this);

	btnCloseHexOptions = new nlib::FlatButton();
	btnCloseHexOptions->SetBounds(nlib::Rect(14, 279, 242, 291));
	btnCloseHexOptions->SetText(L"-------------------------------------------");
	btnCloseHexOptions->GetFont().SetFamily(L"Tahoma");
	btnCloseHexOptions->GetFont().SetSize(10);
	btnCloseHexOptions->SetParentFont(false);
	btnCloseHexOptions->SetTabOrder(8);
	btnCloseHexOptions->SetParent(this);

	SetActiveControl(edtInfix);
	SetMenu(mnuMain);
	btnOpenHexOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28672)));
	btnOpenDecOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28673)));
	tbExit->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28674)));
	tbHistory->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28675)));
	tbCopy->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28676)));
	tbPaste->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28677)));
	pnlDec->SetPopupMenu(pmCopy);
	pnlHex->SetPopupMenu(pmCopy);
	pnlOct->SetPopupMenu(pmCopy);
	pnlBin->SetPopupMenu(pmCopy);
	UpDownDecDigits->SetAttachedEditor(spnDecDigits);
	btnFont->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28678)));
	btnFont->Image()->SetStateCount(2);
	btnCloseDecOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28679)));
	btnCloseHexOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28680)));

	OnStartSizeMove = CreateEvent(this, &TfrmMain::StartMove);
	OnMove = CreateEvent(this, &TfrmMain::FormMove);
	OnClose = CreateEvent(this, &TfrmMain::FormClose);
	miCopyDec->OnClick = CreateEvent(this, &TfrmMain::miCopyDecClick);
	miCopyHex->OnClick = CreateEvent(this, &TfrmMain::miCopyHexClick);
	miCopyOct->OnClick = CreateEvent(this, &TfrmMain::miCopyOctClick);
	miCopyBin->OnClick = CreateEvent(this, &TfrmMain::miCopyBinClick);
	miCopyText->OnClick = CreateEvent(this, &TfrmMain::miCopyClick);
	miExit->OnClick = CreateEvent(this, &TfrmMain::miExitClick);
	miCopy->OnClick = CreateEvent(this, &TfrmMain::miCopyClick);
	miPaste->OnClick = CreateEvent(this, &TfrmMain::miPasteClick);
	miAppend->OnClick = CreateEvent(this, &TfrmMain::miAppendClick);
	miCopyDecimal->OnClick = CreateEvent(this, &TfrmMain::miCopyDecClick);
	miCopyHexadecimal->OnClick = CreateEvent(this, &TfrmMain::miCopyHexClick);
	miCopyOctal->OnClick = CreateEvent(this, &TfrmMain::miCopyOctClick);
	miCopyBinary->OnClick = CreateEvent(this, &TfrmMain::miCopyBinClick);
	miEditVars->OnClick = CreateEvent(this, &TfrmMain::miEditVarsClick);
	miEditFuncs->OnClick = CreateEvent(this, &TfrmMain::miEditFuncsClick);
	miShowHist->OnClick = CreateEvent(this, &TfrmMain::miShowHistClick);
	miClearHist->OnClick = CreateEvent(this, &TfrmMain::miClearHistClick);
	miShowDecOpts->OnClick = CreateEvent(this, &TfrmMain::miShowDecOptsClick);
	miShowHexOpts->OnClick = CreateEvent(this, &TfrmMain::miShowHexOptsClick);
	miCharFont->OnClick = CreateEvent(this, &TfrmMain::miCharFontClick);
	miHistOpts->OnClick = CreateEvent(this, &TfrmMain::miHistOptsClick);
	miAbout->OnClick = CreateEvent(this, &TfrmMain::miAboutClick);
	miGenHelp->OnClick = CreateEvent(this, &TfrmMain::miGenHelpClick);
	btnOpenHexOptions->OnClick = CreateEvent(this, &TfrmMain::btnOpenHexOptionsClick);
	btnOpenDecOptions->OnClick = CreateEvent(this, &TfrmMain::btnOpenDecOptionsClick);
	tbExit->OnClick = CreateEvent(this, &TfrmMain::tbExitClick);
	tbHistory->OnClick = CreateEvent(this, &TfrmMain::tbHistoryClick);
	tbCopy->OnClick = CreateEvent(this, &TfrmMain::tbCopyClick);
	tbPaste->OnClick = CreateEvent(this, &TfrmMain::tbPasteClick);
	edtInfix->OnKeyDown = CreateEvent(this, &TfrmMain::edtInfixKeyDown);
	edtInfix->OnTextChanged = CreateEvent(this, &TfrmMain::edtInfixTextChanged);
	btnDecimal->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnHexadecimal->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnOctal->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnBinary->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	pnlDec->OnPaint = CreateEvent(this, &TfrmMain::pnlDecPaint);
	chkSep->OnClick = CreateEvent(this, &TfrmMain::chkSepClick);
	cbThousandSep->OnChanged = CreateEvent(this, &TfrmMain::cbThousandSepChanged);
	chkSci->OnClick = CreateEvent(this, &TfrmMain::chkSciClick);
	chkEng->OnClick = CreateEvent(this, &TfrmMain::chkSciClick);
	chkDecDigits->OnClick = CreateEvent(this, &TfrmMain::chkDecDigitsClick);
	spnDecDigits->OnTextChanged = CreateEvent(this, &TfrmMain::spnDecDigitsTextChanged);
	rdDeg->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdGrad->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdRad->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdNormal->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdHtml->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdTex->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdNone->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	chkMinus->OnClick = CreateEvent(this, &TfrmMain::chkMinusClick);
	chkLittleEndian->OnClick = CreateEvent(this, &TfrmMain::chkLittleEndianClick);
	chkBytes->OnClick = CreateEvent(this, &TfrmMain::chkAsBytesClick);
	chkWords->OnClick = CreateEvent(this, &TfrmMain::chkAsWordsClick);
	chkDWords->OnClick = CreateEvent(this, &TfrmMain::chkAsDWordsClick);
	chkIEEESingle->OnClick = CreateEvent(this, &TfrmMain::chkIEEESingleClick);
	chkIEEEDouble->OnClick = CreateEvent(this, &TfrmMain::chkIEEEDoubleClick);
	cbInfix->OnKeyPress = CreateEvent(this, &TfrmMain::cbInfixKeyPress);
	cbInfix->OnChanged = CreateEvent(this, &TfrmMain::cbInfixTextChanged);
	btnFont->OnClick = CreateEvent(this, &TfrmMain::btnFontClick);
	btnCloseDecOptions->OnClick = CreateEvent(this, &TfrmMain::btnCloseDecOptionsClick);
	btnCloseHexOptions->OnClick = CreateEvent(this, &TfrmMain::btnCloseHexOptionsClick);
}


// for fun
	vector<MONITORINFOEX> monitors;
// callback function called by EnumDisplayMonitors for each enabled monitor 
BOOL CALLBACK EnumDispProc(HMONITOR hMon, HDC dcMon, RECT* pRcMon, LPARAM lParam) 
{ 
	MONITORINFOEX mi;
	mi.cbSize = sizeof(MONITORINFOEX);
	if( GetMonitorInfo(hMon, &mi) )
		monitors.push_back(mi);

	return TRUE;	// continue enum
} 
// /for fun
TfrmMain::TfrmMain()
{
	InitializeFormAndControls();
	_wsUserDir = _GetUserDir();
	_GetVirtualDisplaySize();
	// /for fun
	_coMoveDX = _coMoveDY = 0;
	_bAutoSave = false;

	RealNumber::SetMaxLength(70);	// but only display 64
    lengine = new FalconCalc::LittleEngine;
	lengine->displayFormat.useNumberPrefix = true;
	lengine->displayFormat.strThousandSeparator = " "_ss;
	lengine->displayFormat.displWidth = 59;

	lengine->ssNameOfDatFile = SmartString(AppendToPath(_wsUserDir, FalconCalc_DAT_FILE).c_str());
    lengine->ReadTables();
	// add the clipboard and set this window as a "viewer"
	MyClipboard = new Clipboard();	   // messages arrive after
	MyClipboard->Activate( Handle() ); // Handle() is called first

    _chkArr[0] = chkMinus;
    _chkArr[1] = chkBytes;
    _chkArr[2] = chkWords;
    _chkArr[3] = chkDWords;
    _chkArr[4] = chkIEEESingle;
    _chkArr[5] = chkIEEEDouble;
    _chkArr[6] = chkLittleEndian;

    _nDecOptTop = pnlDecOpt->Top();
    _nHexBtnTop = btnOpenHexOptions->Top();
    _busy = false;

    // ?? spnDecDigits->SetValue(20);
    pslHistory = new TStringList;
    pslHistory->SetCaseSensitive(false);
    pslHistory->SetDuplicates(true);  // no duplicates
    pslHistory->SetSorted(false);
    pslHistory->LoadFromFile(AppendToPath(_wsUserDir, FalconCalc_HIST_FILE).c_str());
    _watchdog = 0;
    _watchLimit = 5; // seconds	 
	_maxHistDepth=0; // unlimited

    if(!_LoadState(AppendToPath(_wsUserDir, FalconCalc_CFG_FILE).c_str()))
    {
        ShowDecOptions(false);
        ShowHexOptions(false);
    }

    _added = false;

}
LRESULT TfrmMain::WindowProc(UINT msg, WPARAM w,LPARAM l)
{
	switch(msg)
	{
		case  WM_TIMER:
			    if(_bAutoSave && ++_watchdog >= _watchLimit && lengine->ResultOk() && !_added && !edtInfix->Text().empty())
					    _AddToHistory(edtInfix->Text());
				break;
		case WM_CHANGECBCHAIN: 
				// If the next clipboard viwer window is closing, repair the chain. 
				// Otherwise, pass the message to the next link. 
				MyClipboard->ChangeNextViewer((HWND) w, (HWND) l);
				break;
		case WM_DRAWCLIPBOARD:
				// if the content of the clipboard has been changed
				// enable or disable paste menu and button
			   {
					bool enable = IsClipboardFormatAvailable(CF_UNICODETEXT) || IsClipboardFormatAvailable(CF_TEXT);
					miPaste->SetEnabled(enable);
					tbPaste->SetEnabled(enable);
			   }
				// and pass the message on
				MyClipboard->Forward( msg, w, l); 				
				break;

		default: return Form::WindowProc(msg,w,l);
	}
	return 0;
}
TfrmMain::~TfrmMain()
{
	/* Don't 'delete' the form. Call Destroy() instead which has access to the protected destructor. */
	delete 	MyClipboard;
}

void TfrmMain::Destroy()
{
	lengine->SaveTables();
    _SaveState(AppendToPath(_wsUserDir, FalconCalc_CFG_FILE).c_str());
    pslHistory->SaveToFile(AppendToPath(_wsUserDir, FalconCalc_HIST_FILE).c_str());
    delete pslHistory;
    delete lengine;
	Form::Destroy();
}

void TfrmMain::btnFontClick(void *sender, nlib::EventParameters param)
{
	FontDialog1->SetFont( edtChars->GetFont());
	if(FontDialog1->Show(this))
	{
		edtChars->SetFont(FontDialog1->GetFont());
	}
}

void TfrmMain::edtInfixKeyDown(void *sender, nlib::KeyParameters param)
{
    _watchdog = 0;   // reset counter
	if(edtInfix->Text().empty())
        return;

    if(param.keycode == VK_RETURN)
        _AddToHistory(edtInfix->Text());
    else if(param.keycode != VK_RIGHT && param.keycode != VK_LEFT && param.keycode != VK_UP && param.keycode != VK_DOWN &&
            param.keycode != VK_TAB)
    {
		if(param.keycode != 17 || !param.vkeys.contains(vksCtrl))  // 17 - Ctrl-H
                _added = false;
    }
}

void TfrmMain::pnlDecPaint(void *sender, nlib::PaintParameters param)
{
	sa::GraphicText gtDec;
	Canvas *pCanvas = pnlDec->GetCanvas();
	pCanvas->FillRect(1,1,pnlDec->Width()-4, pnlDec->Height()-1);
	if(pnlDec->Text().empty() )
		return;

	gtDec.SetCanvas(  pCanvas );
	gtDec.SetText(pnlDec->Text(), 0, lengine->displayFormat.expFormat != ExpFormat::rnsfGraph);
	int y = (pnlDec->Height() - gtDec.Box().Height())/2 - gtDec.Box().TopLeft().y;
	if(y < 0)
		y = 0;
	gtDec.Draw(pnlDec->Width() - gtDec.Box().Width()-4, y);
}

void TfrmMain::_GetVirtualDisplaySize()
{
	//----- SA -------------------
	// for fun
	EnumDisplayMonitors(0, 0, EnumDispProc, 0); 	// get all monitors
	// get virtual window size
	RECT r = { 0 };
	//	r.left = r.right=r.top=r.bottom = 0'
	for (size_t i = 0; i < monitors.size(); ++i)
	{
		if (monitors[i].rcMonitor.left < r.left)
			r.left = monitors[i].rcMonitor.left;
		if (monitors[i].rcMonitor.top < r.top)
			r.top = monitors[i].rcMonitor.top;
		if (monitors[i].rcMonitor.bottom > r.bottom)
			r.bottom = monitors[i].rcMonitor.bottom;
		if (monitors[i].rcMonitor.right > r.right)
			r.right = monitors[i].rcMonitor.right;
	}
	if (Left() > r.right || Top() > r.bottom || Bottom() < r.top || Right() < r.left)
	{
		SetLeft(((r.right - r.left) - Width()) / 2);
		SetTop(((r.bottom - r.top) - Height()) / 2);
	}
}

void TfrmMain::_ShowResults()	// from lengine
{
    if(edtInfix->Text().empty())
    {
		_ShowMessageOnAllPanels(L"");
        return;
    }
    if(lengine->resultType== LittleEngine::ResultType::rtDefinition) // function definition?
    {
        _ShowMessageOnAllPanels(L"Definition");
        return;
    }
    else if(lengine->resultType == LittleEngine::ResultType::rtInvalid)
    {
		_ShowMessageOnAllPanels(L"???");
        return;
    }
	// DEBUG
	// SmartString s = lengine->ResultAsDecString();
	// /DEBUG
	pnlDec->SetText(lengine->ResultAsDecString().ToWideString());
	pnlDec->Invalidate();
    pnlHex->SetText(lengine->ResultAsHexString().ToWideString());
    pnlOct->SetText(lengine->ResultAsOctString().ToWideString());
    pnlBin->SetText(lengine->ResultAsBinString().ToWideString());
    edtChars->SetText(lengine->ResultAsCharString().ToWideString());

	SetFocus(edtInfix->Handle());
}

// display same message in all panels
void TfrmMain::_ShowMessageOnAllPanels(wstring s)
{
    pnlDec->SetText(s);
	pnlDec->Invalidate();

    pnlHex->SetText(s);
    pnlOct->SetText(s);
    pnlBin->SetText(s);
    edtChars->SetText(L"");
}

void TfrmMain::edtInfixTextChanged(void *sender, nlib::EventParameters param)
{
	if (_busy)
		return;

	if(edtInfix->Text().empty() )
    {
        _ShowMessageOnAllPanels(L"");
        return;
    }
    wstring s = edtInfix->Text();
	cbInfix->SetText(s);
    try
    {
		lengine->infix = s;
        RealNumber res = lengine->Calculate();
        gbResults->SetText(L"Results");
        _ShowResults();
        s = lengine->Postfix().ToWideString();
    }
    catch(wstring s)
    {
        gbResults->SetText(s);
        _ShowMessageOnAllPanels(L"???");
    }
    catch(SmartString s)
    {
        gbResults->SetText(s.ToWideString());
        _ShowMessageOnAllPanels(L"???");
    }
    catch(...)
    {
        _ShowMessageOnAllPanels(L"???");
    }
	_busy = false;
}

void TfrmMain::rdDegClick(void *sender, nlib::EventParameters param)
{
	lengine->angleUnit = (LongNumber::AngularUnit)((Radiobox*)sender)->Tag();
	edtInfixTextChanged(sender,param);
	SetFocus(edtInfix->Handle());
}

void TfrmMain::spnDecDigitsTextChanged(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.decDigits = UpDownDecDigits->Position();
	if(chkDecDigits->Checked())
		_ShowResults();
	else
		SetFocus(edtInfix->Handle());
}

void TfrmMain::tbCopyClick(void *sender, nlib::EventParameters param)
{
    miCopyClick(sender,param);
}

void TfrmMain::tbExitClick(void *sender, nlib::EventParameters param)
{
	Close();
}

void TfrmMain::tbHistoryClick(void *sender, nlib::EventParameters param)
{
	miShowHistClick(sender,param);
}

void TfrmMain::tbPasteClick(void *sender, nlib::EventParameters param)
{
	miPasteClick(sender,param);
}

void TfrmMain::chkDecDigitsClick(void *sender, nlib::EventParameters param)
{
    if(chkDecDigits->Checked() )
    {
        spnDecDigits->SetEnabled(true);
		lengine->displayFormat.decDigits = UpDownDecDigits->Position();
    }
    else
    {
        spnDecDigits->SetEnabled(false);
        lengine->displayFormat.decDigits = -1;
    }
    _ShowResults();
}

void TfrmMain::chkMinusClick(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.bSignedBinOrHex = chkMinus->Checked();
	_ShowResults();
}

void TfrmMain::chkSciClick(void *sender, nlib::EventParameters param)
{
  if(_busy)
    return;
  _busy = true;
  Checkbox *ps = ((Checkbox*)sender),
            *pd = (ps == chkSci ? chkEng : chkSci);
  lengine->displayFormat.mainFormat = ps->Checked() ? ( (ps == chkSci) ? NumberFormat::rnfSci : NumberFormat::rnfEng) : NumberFormat::rnfGeneral;
  pd->SetChecked(false);
    _ShowResults();
  _busy = false;
}

void TfrmMain::chkSepClick(void *sender, nlib::EventParameters param)
{
    bool b = chkSep->Checked();
    cbThousandSep->SetEnabled(b);
	if (b && cbThousandSep->ItemIndex() >= 0)
	{
		lengine->displayFormat.strThousandSeparator = SmartString((cbThousandSep->ItemIndex() > 0 ? cbThousandSep->Text()[0] : ' '));
	}
	else
		lengine->displayFormat.strThousandSeparator.clear();
    _ShowResults();
}

void TfrmMain::miExitClick(void *sender, nlib::EventParameters param)
{
	Close();
}

void TfrmMain::miCopyClick(void *sender, nlib::EventParameters param)
{
    if(edtInfix->SelLength())
        MyClipboard->SetText(edtInfix->SelText());
    else
        MyClipboard->SetText( edtInfix->Text());
}

void TfrmMain::miPasteClick(void *sender, nlib::EventParameters param)
{
    edtInfix->SetText(edtInfix->Text().substr(0, edtInfix->SelStart()) +
			MyClipboard->GetText() + edtInfix->Text().substr(edtInfix->SelStart(),999));
}

void TfrmMain::miAppendClick(void *sender, nlib::EventParameters param)
{
    edtInfix->SetText( edtInfix->Text() + MyClipboard->GetText());
}

void TfrmMain::miEditVarsClick(void *sender, nlib::EventParameters param)
{
    VarFuncInfo vf;
    lengine->GetVarFuncInfo(vf);

    if(!frmVariables)
	{
        frmVariables = new TfrmVariables;
		frmVariables->SetTopLevelParent(this);
	}
    else
    {
        frmVariables->tcVars->SetSelectedTab( ((MenuItem*)sender)->Tag());
		TabChangeParameters par(((MenuItem*)sender)->Tag());
        frmVariables->tcVarsTabChange(sender, par);
        frmVariables->Show();
        return;
    }
    frmVariables->Setup(vf);
    frmVariables->tcVars->SetSelectedTab( ((MenuItem*)sender)->Tag());
    frmVariables->Show();
	SetFocus(edtInfix->Handle());
}

void TfrmMain::miEditFuncsClick(void *sender, nlib::EventParameters param)
{
	miEditVarsClick(sender, param);
}

// TASK: to show history window below, stacked above or beside main window
// EPECTS:
// RETURNS: nothing
// REMARKS: sets position and size of history window
void TfrmMain::miShowHistClick(void *sender, nlib::EventParameters param)
{
	if(frmHistory)		// already set
	{
		frmHistory->Show();
			return;
	}
	frmHistory = new TfrmHistory;
	frmHistory->SetTopLevelParent(this);
    frmHistory->SetLeft(Left());
    frmHistory->chkSorted->SetChecked(pslHistory->Sorted());
	frmHistory->Snap(0);	// unconditional snap to any side
	frmHistory->lstHistory->Items().SetLines(pslHistory->Lines());
	frmHistory->Show();

	SetFocus(edtInfix->Handle());
}

void TfrmMain::miClearHistClick(void *sender, nlib::EventParameters param)
{
    pslHistory->Clear();
	if(frmHistory)
		frmHistory->lstHistory->Clear();
}

void TfrmMain::miShowDecOptsClick(void *sender, nlib::EventParameters param)
{
	ShowDecOptions(!pnlDecOpt->Visible());
}

void TfrmMain::miShowHexOptsClick(void *sender, nlib::EventParameters param)
{
	ShowHexOptions(!pnlHexOpt->Visible());
}

void TfrmMain::miHistOptsClick(void *sender, nlib::EventParameters param)
{
	frmHistOptions = new TfrmHistOptions;
	frmHistOptions->SetTopLevelParent(this);
    frmHistOptions->Setup(_maxHistDepth, _watchLimit, pslHistory->Sorted() );

	if(frmHistOptions->ShowModal() == mrOk)
    {
        if(frmHistOptions->chkDepth->Checked())
        {
            _maxHistDepth = frmHistOptions->spinDepthBtn->Position();
			pslHistory->SetCapacity(_maxHistDepth);
			if(frmHistory)
				frmHistory->lstHistory->Items().SetLines(pslHistory->Lines());
        }
        if(frmHistOptions->chkAutoSave->Checked())
        {
			wstring str = frmHistOptions->edtInterval->Text();
			int h = 0, m = 0, s = 0;
			int n = swscanf(str.c_str(), L"%d:%d:%d", &h, &m, &s);
			if(n != 3)
			{
				s = m;
				m = h;
				h = 0;
				if(n != 2)
				{
					s = m;
					m = 0;;
				}
			}
            _watchLimit = h*3600 + m*60 + s;
        }
        else
        {
            _watchLimit = 0;
        }
        // Timer1->Enabled = _watchLimit > 0;
		_EnableMyTimer(_watchLimit > 0);
        pslHistory->SetSorted(frmHistOptions->chkSort->Checked(),true);	// first (last entered) line is not sorted
        if(frmHistory)
            frmHistory->lstHistory->Items().SetLines(pslHistory->Lines());

    }
	frmHistOptions->Destroy();
	frmHistOptions = NULL;
}

void TfrmMain::miAboutClick(void *sender, nlib::EventParameters param)
{
	frmAbout = new TfrmAbout;
	frmAbout ->SetTopLevelParent(this);
	frmAbout ->ShowModal();
	frmAbout->Destroy();
}

void TfrmMain::miGenHelpClick(void *sender, nlib::EventParameters param)
{
	frmHelp = new TfrmHelp;
	frmHelp ->SetTopLevelParent(this);
	frmHelp ->ShowModal();
	frmHelp->Destroy();
}

void TfrmMain::miCharFontClick(void *sender, nlib::EventParameters param)
{
	btnFont->Click();
}

void TfrmMain::miCopyDecClick(void *sender, nlib::EventParameters param)
{
	wstring ws = pnlDec->Text();	// reformat for 'normal' number
	int pos;
	if( (pos = ws.find_first_of(_CHART(183)) ) != wstring::npos)
		ws = ws.substr(0,pos) + _CHART('e') + ws.substr(pos+5, ws.length()-pos-5-1);
	MyClipboard->SetText(ws );
}

void TfrmMain::miCopyHexClick(void *sender, nlib::EventParameters param)
{
	MyClipboard->SetText(pnlHex->Text() );
}

void TfrmMain::miCopyOctClick(void *sender, nlib::EventParameters param)
{
	MyClipboard->SetText(pnlOct->Text() );
}

void TfrmMain::miCopyBinClick(void *sender, nlib::EventParameters param)
{
	MyClipboard->SetText(pnlBin->Text() );
}
void TfrmMain::cbThousandSepChanged(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.strThousandSeparator =  SmartString(cbThousandSep->Text()[0]);
	if(lengine->displayFormat.strThousandSeparator == SmartString('s') )
		lengine->displayFormat.strThousandSeparator = " ";
	_ShowResults();
}

void TfrmMain::ShowDecOptions(bool show)
{
    if(pnlDecOpt->Visible() == show)
        return;
    miShowDecOpts->SetChecked(show);
    if(show)
    {
        SetHeight( Height() + pnlDecOpt->Height());
        btnOpenHexOptions->SetTop(_nHexBtnTop);
            // although this is common for both show and not show
            // if this is set AFTER 'pnlDecOpt' is shown the
            // btnCloseHexOptions remains on the screen over the panel in XE
        btnCloseHexOptions->SetTop(btnOpenHexOptions->Top());

        pnlDecOpt->SetTop(_nDecOptTop);
    }
    else
    {
// DEBUG 2 lines
// int hp = pnlDecOpt->Height(),
// h = Height();
        SetHeight(Height() - pnlDecOpt->Height());
// h = Height(); // DEBUG
        btnOpenHexOptions->SetTop(_nDecOptTop);
        btnCloseHexOptions->SetTop(btnOpenHexOptions->Top());
    }
    pnlDecOpt->SetVisible(show);
    pnlHexOpt->SetTop( btnOpenHexOptions->Top() + btnOpenHexOptions->Height()+2);
    btnOpenDecOptions->SetVisible(!show);
    btnCloseDecOptions->SetVisible(show);
}

//---------------------------------------------------------------------------
void TfrmMain::ShowHexOptions(bool show)
{
    if(pnlHexOpt->Visible() == show)
        return;
    miShowHexOpts->SetChecked(show);
    int h = pnlHexOpt->Height()-5;
    if(!show)
        h = -h;
// DEBUG
//int hh = Height();
    SetHeight(Height() + h);
//hh = Height();
    pnlDecOpt->SetTop(_nDecOptTop);

    pnlHexOpt->SetVisible(show);
    btnOpenHexOptions->SetVisible(!show);
    btnCloseHexOptions->SetVisible(show);
}

void TfrmMain::btnCloseDecOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowDecOptions(false);
}

void TfrmMain::btnCloseHexOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowHexOptions(false);
}

void TfrmMain::btnOpenDecOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowDecOptions(true);
}

void TfrmMain::btnOpenHexOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowHexOptions(true);
}

// SA 
void TfrmMain::_EnableMyTimer(bool enable)
{
//	if(_bAutoSave == enable)
//		return;
	if(enable)
		SetTimer(Handle(), (UINT_PTR)0x12, 1000, 0); // Timer1
	else
		KillTimer(Handle(),(UINT_PTR)0x12);
	_bAutoSave = enable;
}

FalconCalc::LittleEngine* TfrmMain::pEngine()
{
	return lengine;
}

/*
* Status file is a text file. its data:
*  	   <ID line>
*	mainformat=<mainformat>
*   decFormat=<# dec. digits (-1* ()-1 if not used>|<exponent format>|<1|0+index of thousand sep. char.* (-1) if not used>|<useFractionSeparator>|<angular unit>
*   hexFormat=<hexFormat>|<is little endian>|<signed bin or hex><IEEE format>
*	fontName=<font name>,
*	fontData=<font size>|<font charset>|<font color>,
*	options=<dec.options visible>|<hex options visile>
*	histOptions=<timeot>|<max. hist depth>|<is history sorted>
*	last=<text of last expression>
*/

static const wstring 
		MAINFORMAT(L"mainFormat="),
		DECFORMAT(L"decFormat="),
		HEXFORMAT(L"hexFormat="),
		FONTNAME(L"fontName="),
		FONTDATA(L"fontData="),
		OPTIONS(L"options="),
		HISTOPTIONS(L"histOptions="),
		LAST(L"last=");


/*=============================================================
 * TASK   : reads line from file splits it up at '|' delimiters
 * PARAMS : fs: open file stream
 *			data: vector of wstrings corresponding to data
 * EXPECTS:
 * GLOBALS:
 * RETURNS: >0 => (# of strings in line + 1) and data filled
 *			==0 => error, equal line not found
 * REMARKS: keeps empty fields as empty wstrings
 *------------------------------------------------------------*/
static int __ReadAndExpandLine(FileStream& fs, std::vector<wstring>& data)
{
	if (fs.eof())	// no more output?
		return 0;

	wchar_t wbuf[1024];
	fs.getline(wbuf, 1023);

	SmartString s(wbuf);

	std::vector<SmartString> sdata;

	s.Trim();
	int n = s.indexOf('=');
	if (n < 0)
		return -1;
	sdata.push_back(s.left(++n));	// name + '='

	if (!s.length())
		sdata.clear();
	else			   // cut name= and get the other fields
		sdata = s.mid(n).Split(SCharT('|'), true);
	data.clear();
	for (auto& s : sdata)
		data.push_back(s.ToWideString());
	return sdata.size();
}

std::wstring TfrmMain::_GetUserDir()
{
	wchar_t buff[2046];
	std::wstring w;
	if (!SHGetFolderPath(NULL, CSIDL_PROFILE, NULL, 0, buff))
	{
		w = buff;

		w += L"\\AppData\\Local\\FalconCalc";
		if (!PathExists(w))
		{
			if (!CreateDirectory(w.c_str(), NULL))
				w = (wstring&)ExecutablePath;
		}
	}
	else
		w = (wstring&)ExecutablePath;

	return w;
}

bool TfrmMain::_SaveState(wstring name)
{
	FileStream fs(name,ios_base::out);

     if(fs.fail())
        return false;
    fs << "FalconCalc State File V1.0\n";
	fs << MAINFORMAT<< (int)lengine->displayFormat.mainFormat << "\n";

	//int u = UpDown1->Position() + (chkDecDigits->Checked() ? 0x100 : 0); // 0x100: checked state. must use Position as num_digits may be -1
	wstring wsep = (chkSep->Checked() ? L"1" : L"0") + (std::to_wstring(cbThousandSep->ItemIndex()));
	fs << DECFORMAT<< lengine->displayFormat.decDigits << "|" << (int)lengine->displayFormat.expFormat 
	   << "|" << wsep <<  "|" << (int)lengine->displayFormat.useFractionSeparator 
	   << "|" << (int)lengine->angleUnit << "\n";

    fs << HEXFORMAT<< (int)lengine->displayFormat.hexFormat << "|"<< (int)lengine->displayFormat.littleEndian << "|"<< 
			(int)lengine->displayFormat.bSignedBinOrHex << "|" << (int)lengine->displayFormat.trippleE <<"\n";

	fs << FONTNAME	<< edtChars->GetFont().Family() << "\n";
	fs << FONTDATA	<< (int)edtChars->GetFont().Size() << "|"<< (int)edtChars->GetFont().CharacterSet() << "|"<< (COLORREF)edtChars->GetFont().GetColor() << "\n";
    fs << OPTIONS	<< pnlDecOpt->Visible() << "|"<< pnlHexOpt->Visible()<<"\n";
    fs << HISTOPTIONS << _watchLimit << "|"<< _maxHistDepth << "|"<< pslHistory->Sorted() << "\n";
    if(!edtInfix->Text().empty())
        fs << LAST <<  edtInfix->Text() << "\n";
    return true;
}
bool TfrmMain::_LoadState(wstring name)
{
	FileStream fs(name,ios_base::in);
    if(fs.fail())
        return false;
	DisplayFormat dspFormat;
//	wstring s;
	wchar_t wbuf[1024];// , nam[1024];
	fs.getline(wbuf,1023);
	
    if(wcscmp(wbuf, L"FalconCalc State File V1.0"))
        return false;
    int n;

	std::vector<wstring> data;
	auto mainFormat = [&]()	-> bool // returns true if not processed, false if processed
	{
		if (data[0] == MAINFORMAT)
		{
			n = std::stoi(data[1]);
			lengine->displayFormat.mainFormat = static_cast<NumberFormat>(n);
			_busy = true;
			switch (lengine->displayFormat.mainFormat)
			{
				case NumberFormat::rnfSci:
					chkSci->SetChecked(true);
					break;
				case NumberFormat::rnfEng:
					chkEng->SetChecked(true);
					break;
			}	   
			_busy = false;
			return true;
		}
		return false;
	};
	auto decFormat = [&]()
	{
		if (data[0] == DECFORMAT)
		{
			_busy = true;
					// 1: decimal digits
			n = std::stoi(data[1]);	// # of decimal digits n > 0 => used digits, n < 0 => used = abs(n+1)
			lengine->displayFormat.decDigits = n;
			if (n >= 0)
				chkDecDigits->SetChecked(true);
			else
				n = std::abs(n + 1);
			UpDownDecDigits->SetPosition(n);
					// 2: exponent display format
			n = std::stoi(data[2]);	// (0)E: 1E5, (1)HTML: 1<sp>12</sup>, (2)TeX: 1^{12}, (3)normal: 1²³
			lengine->displayFormat.expFormat = static_cast<ExpFormat>(n);
			if(lengine->displayFormat.expFormat == ExpFormat::rnsfE)
				rdNone->SetChecked(true);
			else if(lengine->displayFormat.expFormat == ExpFormat::rnsfSciHTML)
				rdHtml->SetChecked(true);
			else if (lengine->displayFormat.expFormat == ExpFormat::rnsfSciTeX)
				rdTex->SetChecked(true);
			else if (lengine->displayFormat.expFormat == ExpFormat::rnsfGraph)
			{
				rdNormal->SetChecked(true);
			}
					// 3: thousand separator string
			if (!data[3].empty())	// can only be '.', ',' and space
			{
				if (data[3][0] == L'1')
					chkSep->SetChecked(true);
				else if (data[3][1] == L'0')
					cbThousandSep->SetItemIndex(0);
				else if (data[3][1] == L'1')
					cbThousandSep->SetItemIndex(1);
				else if (data[3][1] == L'2')
					cbThousandSep->SetItemIndex(2);
				if (chkSep->Checked())
					lengine->displayFormat.strThousandSeparator = cbThousandSep->Text();
			}
					// 4: fraction separator
			if (!data[4].empty())
				lengine->displayFormat.useFractionSeparator = true;
					// 5: angular unit 0:
			if (!data[5].empty())
				lengine->displayFormat.angUnit = static_cast<AngularUnit>(std::stoi(data[5]));

			_busy = false;

			return true;
		}
		return false;

	};
	auto hexFormat = [&]()
	{
		if (data[0] == HEXFORMAT)
		{
			_busy = true;
				// 1. main Hex format
			int n = std::stoi(data[1]);
			lengine->displayFormat.hexFormat = static_cast<HexFormat>(n);
			switch (lengine->displayFormat.hexFormat)
			{
				case HexFormat::rnHexNormal:
					break;
				case HexFormat::rnHexByte:
					chkBytes->SetChecked(true);
					break;
				case HexFormat::rnHexWord:
					chkWords->SetChecked(true);
					break;
				case HexFormat::rnHexDWord:
					chkDWords->SetChecked(true);
					break;
			}
				// 2. endianness
			n = std::stoi(data[2]);
			if (n)
				chkLittleEndian->SetChecked(true);
				// 3. signed bin or hex?
			n = std::stoi(data[3]);
			if (n)
				chkMinus->SetChecked(true);
				// 4. IEEE format
			n = std::stoi(data[4]);
			// n = 0: no check
			if (n==1)
				chkIEEESingle->SetChecked(true);
			else if(n==2)
				chkIEEEDouble->SetChecked(true);
			_busy = false;

			return true;
		}
		return false;

	};
	auto fontName = [&]()
	{
		if (data[0] == FONTNAME)
		{
			Font f = edtChars->GetFont();
			f.SetFamily(data[1]);
			edtChars->SetFont(f);
			return true;
		}
		return false;

	};
	auto fontData = [&]()
	{
		if (data[0] == FONTDATA)
		{
			Font f = edtChars->GetFont();
			f.SetSize(std::stof(data[1]));
			f.SetCharacterSet(static_cast<FontCharacterSets>(std::stoi(data[2])));
			f.SetColor(std::stoul(data[2]));
			return true;
		}
		return false;

	};
	auto options = [&]()
	{
		if (data[0] == OPTIONS)
		{
			pnlDecOpt->SetVisible(std::stoi(data[1]));
			pnlHexOpt->SetVisible(std::stoi(data[2]));
			return true;
		}
		return false;

	};
	auto histOptions = [&]()
	{
		if (data[0] == HISTOPTIONS)
		{
			_watchLimit = std::stoi(data[1]);
			_maxHistDepth = std::stoi(data[2]);
			pslHistory->SetSorted(std::stoi(data[3]));
			return true;
		}
		return false;

	};
	auto last = [&](wstring &lastinfix)
	{
		if (data[0] == LAST)
		{
			lastinfix = data[1];
		}
	};

	wstring wsLlastInfix;
	while ((n = __ReadAndExpandLine(fs, data)))
	{
		if (data[0][data[0].length() - 1] == SCharT('='))	// valid line
		{
			if(!mainFormat() )
				if(!decFormat())
					if(!hexFormat())
						if(!fontName())
							if(!fontData())
								if(!options())
									if(!histOptions())
										last(wsLlastInfix);
		}
	}

	_EnableMyTimer(_watchLimit > 0);
    _busy = false;
    return true;
}
// Adds actual expression to history
// Always inserts line at first position (top of list)
// For sorted list it first inserts the original first line
// then insert the new at the top
// If the expression was already in the list deletes it first from the list
void TfrmMain::_AddToHistory(wstring text)
{
	SmartString ss(text);
	ss.Trim();
	if (LittleEngine::variables.count(ss))		// single variable or function?
	{
		_watchdog = 0;
		return;
	}

    int n;
    if( (n = pslHistory->IndexOf(ss)) >= 0)
    {
        if(n == 0 && pslHistory->Sorted())	// already at top
            return;							// nothing to do
        pslHistory->Delete(n);				// not at top delete expression from inside
    }
	else if(pslHistory->Sorted() )			// then must put original top line in correct position 
	{										// first and add the new line afterwards, because
		SmartString ws = (*pslHistory)[0];		// list may be truncated after adding a new line to it
		pslHistory->Delete(0);				// delete original top line
		pslHistory->Add(ws);					// and insert into string
	}
	
    pslHistory->Insert(0, ss);				// then insert new expression to top of list

    _added = true;
    _watchdog = 0;
    if(frmHistory != 0)
        frmHistory->lstHistory->Items().SetLines(pslHistory->Lines());
}

void TfrmMain::FormClose(void *sender, nlib::FormCloseParameters param)
{

}

void TfrmMain::chkAsBytesClick(void *sender, nlib::EventParameters param)
{
	chkWords->SetChecked(false);
	chkDWords->SetChecked(false);
	bool b = chkBytes->Checked();
	if(b)
		lengine->displayFormat.hexFormat = HexFormat::rnHexByte;
	else
		lengine->displayFormat.hexFormat = HexFormat::rnHexNormal;
	chkLittleEndian->SetEnabled(b);
	_ShowResults();
}

void TfrmMain::chkAsWordsClick(void *sender, nlib::EventParameters param)
{
	chkBytes->SetChecked(false);
	chkDWords->SetChecked(false);
	bool b = chkWords->Checked();
	if (b)
		lengine->displayFormat.hexFormat = HexFormat::rnHexWord;
	else
		lengine->displayFormat.hexFormat = HexFormat::rnHexNormal;
	chkLittleEndian->SetEnabled(b);
	_ShowResults();
}

void TfrmMain::chkAsDWordsClick(void *sender, nlib::EventParameters param)
{
	chkWords->SetChecked(false);
	chkBytes->SetChecked(false);
	bool b = chkDWords->Checked();
	if (b)
		lengine->displayFormat.hexFormat = HexFormat::rnHexDWord;
	else
		lengine->displayFormat.hexFormat = HexFormat::rnHexNormal;
	chkLittleEndian->SetEnabled(b);
	_ShowResults();
}

void TfrmMain::chkIEEEDoubleClick(void *sender, nlib::EventParameters param)
{
	chkIEEESingle->SetChecked(false);
	lengine->displayFormat.trippleE =  chkIEEEDouble->Checked() ? IEEEFormat::rntHexIEEE754Double : IEEEFormat::rntHexNotIEEE;
	_ShowResults();
}

void TfrmMain::chkIEEESingleClick(void *sender, nlib::EventParameters param)
{
	chkIEEEDouble->SetChecked(false);
	lengine->displayFormat.trippleE =  chkIEEESingle->Checked() ? IEEEFormat::rntHexIEEE754Single : IEEEFormat::rntHexNotIEEE;
	_ShowResults();
}

void TfrmMain::chkLittleEndianClick(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.littleEndian =  chkLittleEndian->Checked() ? true: false;
	_ShowResults();
}

void TfrmMain::btnCopyFormatClick(void *sender, nlib::EventParameters param)
{
	Button *pb = reinterpret_cast<Button*>(sender);
	switch (pb->Tag())
	{
		case 0: miCopyDecClick(sender, param); break;
		case 1: MyClipboard->SetText(pnlHex->Text() ); break;
		case 2: MyClipboard->SetText(pnlOct->Text() ); break;
		case 3: MyClipboard->SetText(pnlBin->Text() ); break;
	}
	SetFocus(edtInfix->Handle());
}

void TfrmMain::StartMove(void *sender, nlib::EventParameters param)
{
		// only use it for move and not for resize
	if(frmHistory && frmHistory->InsideSnapAreaFromMain(10) )	// then move it together
	{
		_coMoveDX = (frmHistory->Left() - Left());
		_coMoveDY = (frmHistory->Top()- Top());
	}
	else
		_coMoveDX = _coMoveDY = 0;
}

void TfrmMain::FormMove(void *sender, nlib::EventParameters param)
{
	if(_coMoveDX || _coMoveDY)
	{
		frmHistory->SetTop( Top() + _coMoveDY );
		frmHistory->SetLeft( Left() + _coMoveDX);
	}
}
	// this single funcion deals with Normal, HTML, TeX and E display
void TfrmMain::rdNormalClick(void *sender, nlib::EventParameters param) 
{
	
	lengine->beautification = (LittleEngine::Beautification)((Radiobox*)sender)->Tag();
	//sres.type = sres.mode == bmoNone ? stDecimal : stDecBeautified;
	_ShowResults();
}

void TfrmMain::cbInfixTextChanged(void *sender, nlib::EventParameters param)
{
	if (_busy)
		return;

	_busy = true;
	if (cbInfix->Text().empty())
	{
		lengine->resultValid = LittleEngine::ResValid::rvInvalid;
		_ShowResults();
		return;
	}
	wstring s = cbInfix->Text();
	edtInfix->SetText(s);
	try
	{
		lengine->infix = s;
		RealNumber res = lengine->Calculate();
		gbResults->SetText(L"Results");
		lengine->resultValid = LittleEngine::ResValid::rvOk;
		_ShowResults();
		s = lengine->Postfix().ToWideString();
	}
	catch (wstring s)
	{
		lengine->resultValid = LittleEngine::ResValid::rvInvalid;
		gbResults->SetText(s);

		_ShowResults();
	}
	catch (...)
	{
		lengine->resultValid = LittleEngine::ResValid::rvInvalid;
		_ShowResults();
	}
	_busy = false;
}

void TfrmMain::cbInfixKeyPress(void *sender, nlib::KeyPressParameters param)
{
	;
}

