#include <set>
#include "stdafx_zoli.h"
#include "stdafx_lc.h"
#undef max
#include "wcommon.h"
using namespace nlib;
#include "application.h"
#include "about.h"
#include "help.h"

#include "mainForm.h"

#include "history.h"
#include "histopt.h"

#include "graphictext.h"

#include "calculate.h"

#include "variables.h"

#include <windows.h>
#include <shlobj.h>
#include <iostream>
#include <userenv.h>	// for getting the user directory on windows

using namespace SmString;
using namespace LongNumber;
using namespace FalconCalc;

FalconCalc::LittleEngine *lengine = nullptr;

Clipboard *MyClipboard;

TfrmMain *frmMain;
const wchar_t *FalconCalc_HIST_FILE = L"FalconCalc.hist";
const wchar_t *FalconCalc_DAT_FILE  = L"FalconCalc.dat";
const wchar_t *FalconCalc_CFG_FILE  = L"FalconCalc.cfg";

/****************************************************************************************************************************************/

void TfrmMain::InitializeFormAndControls() /* Control initialization function generated by the designer. Modifications will be lost. */
{
	/* Generated member initialization. Do not modify. */
	SetLeft(777);
	SetTop(436);
	SetText(L"FalconCalc");
	GetFont().SetFamily(L"Tahoma");
	GetFont().SetSize(10);
	SetWantedKeyTypes(nlib::wkArrows | nlib::wkTab | nlib::wkEnter | nlib::wkEscape | nlib::wkOthers);
	SetShowPosition(nlib::fspActiveMonitorCenter);
	SetBorderStyle(nlib::fbsSingle);	// setting to fbsSingle makes this unmoveable
	SetClientRect(nlib::Rect(0, 0, 528, 419 + GetSystemMetrics(SM_CYMENU)));

	FontDialog1 = new nlib::FontDialog();
	FontDialog1->GetFont().SetFamily(L"Tahoma");
	FontDialog1->GetFont().SetSize(8);
	FontDialog1->SetParent(this);

	pmCopy = new nlib::PopupMenu();
	miCopyDec = pmCopy->Add(L"Copy &Decimal");
	miCopyHex = pmCopy->Add(L"Copy He&xadecimal");
	miCopyOct = pmCopy->Add(L"Copy &Octal");
	miCopyBin = pmCopy->Add(L"Copy &Binary");
	miCopySep = pmCopy->Add(L"-");
	miCopyText = pmCopy->Add(L"Copy &Formula");
	pmCopy->SetParent(this);

	mnuMain = new nlib::Menubar();
	miFile = mnuMain->Add(L"&File");
	miExit = miFile->Add(L"E&xit");
	miExit->SetShortcut(L"Alt+X");
	miEdit = mnuMain->Add(L"&Edit");
	miCopy = miEdit->Add(L"&Copy expression");
	miCopy->SetShortcutText(L"Ctrl+C");
	miPaste = miEdit->Add(L"&Paste expression");
	miPaste->SetShortcutText(L"Ctrl+V");
	miAppend = miEdit->Add(L"Paste &After expression");
	separator1 = miEdit->Add(L"-");
	mnuEditCopy = miEdit->Add(L"Cop&y ...");
	miCopyDecimal = mnuEditCopy->Add(L"Copy &Decimal");
	miCopyHexadecimal = mnuEditCopy->Add(L"Copy &Hexadecimal");
	miCopyHexadecimal->SetTag(1);
	miCopyOctal = mnuEditCopy->Add(L"Copy &Octal");
	miCopyOctal->SetTag(2);
	miCopyBinary = mnuEditCopy->Add(L"Copy &Binary");
	miCopyBinary->SetTag(3);
	miData = miEdit->Add(L"&Data...");
	miData->SetTag(1);
	miEditVars = miData->Add(L"Edit User &Variables...");
	miEditVars->SetShortcut(L"Alt+1");
	miEditFuncs = miData->Add(L"Edit User &Functions...");
	miEditFuncs->SetShortcut(L"Alt+2");
	miEditFuncs->SetTag(1);
	separator2 = miEdit->Add(L"-");
	miClearHist = miEdit->Add(L"C&lear History");
	miView = mnuMain->Add(L"&View");
	miShowDecOpts = miView->Add(L"Show &Decimal Options");
	miShowDecOpts->SetShortcutText(L"Ctrl+D");
	miShowHexOpts = miView->Add(L"Show &Hexadecimal  Options");
	miShowHexOpts->SetShortcut(L"Ctrl+X");
	miCharFont = miView->Add(L"&Font For 'As String...' Display");
	miHistory = mnuMain->Add(L"&History");
	miShowHist = miHistory->Add(L"Edit &History");
	miShowHist->SetShortcut(L"Alt+3");
	separator3 = miHistory->Add(L"-");
	miHistOpts = miHistory->Add(L"Histor&y Options...");
	miHelp = mnuMain->Add(L"&Help");
	miAbout = miHelp->Add(L"&About");
	miGenHelp = miHelp->Add(L"&General Help");
	miGenHelp->SetShortcut(L"F1");
	mnuMain->SetParent(this);

	btnOpenHexOptions = new nlib::FlatButton();
	btnOpenHexOptions->SetBounds(nlib::Rect(14, 311, 242, 323));
	btnOpenHexOptions->SetText(L"-----------Hex. options------------------");
	btnOpenHexOptions->SetVisible(false);
	btnOpenHexOptions->GetFont().SetFamily(L"Tahoma");
	btnOpenHexOptions->GetFont().SetSize(10);
	btnOpenHexOptions->SetParentFont(false);
	btnOpenHexOptions->SetTabOrder(10);
	btnOpenHexOptions->SetParent(this);

	btnOpenDecOptions = new nlib::FlatButton();
	btnOpenDecOptions->SetBounds(nlib::Rect(14, 175, 242, 187));
	btnOpenDecOptions->SetText(L"-----------Decimal options--------------");
	btnOpenDecOptions->SetVisible(false);
	btnOpenDecOptions->GetFont().SetFamily(L"Tahoma");
	btnOpenDecOptions->GetFont().SetSize(10);
	btnOpenDecOptions->SetParentFont(false);
	btnOpenDecOptions->SetTabOrder(9);
	btnOpenDecOptions->SetParent(this);

	pToolbar = new nlib::Panel();
	pToolbar->SetBounds(nlib::Rect(0, 0, 528, 29));
	pToolbar->SetAlignment(nlib::alTop);
	pToolbar->SetTabOrder(1);
	pToolbar->SetInnerBorderStyle(nlib::pbsNone);
	pToolbar->SetParent(this);

	tbExit = new nlib::FlatButton();
	tbExit->SetBounds(nlib::Rect(0, 0, 23, 23));
	tbExit->GetFont().SetFamily(L"Tahoma");
	tbExit->GetFont().SetSize(10);
	tbExit->SetParentFont(false);
	tbExit->SetTabOrder(0);
	tbExit->SetParent(pToolbar);

	Bevel1 = new nlib::Bevel();
	Bevel1->SetBounds(nlib::Rect(26, 1, 28, 22));
	Bevel1->SetShape(nlib::bstLeftLine);
	Bevel1->SetParent(pToolbar);

	tbHistory = new nlib::FlatButton();
	tbHistory->SetBounds(nlib::Rect(31, 0, 54, 23));
	tbHistory->GetFont().SetFamily(L"Tahoma");
	tbHistory->GetFont().SetSize(10);
	tbHistory->SetParentFont(false);
	tbHistory->SetTabOrder(1);
	tbHistory->SetParent(pToolbar);

	tbCopy = new nlib::FlatButton();
	tbCopy->SetBounds(nlib::Rect(55, 0, 78, 23));
	tbCopy->GetFont().SetFamily(L"Tahoma");
	tbCopy->GetFont().SetSize(10);
	tbCopy->SetParentFont(false);
	tbCopy->SetTabOrder(2);
	tbCopy->SetParent(pToolbar);

	tbPaste = new nlib::FlatButton();
	tbPaste->SetBounds(nlib::Rect(79, 0, 102, 23));
	tbPaste->SetEnabled(false);
	tbPaste->GetFont().SetFamily(L"Tahoma");
	tbPaste->GetFont().SetSize(10);
	tbPaste->SetParentFont(false);
	tbPaste->SetTabOrder(3);
	tbPaste->SetParent(pToolbar);

	edtInfix = new nlib::Edit();
	edtInfix->SetBounds(nlib::Rect(8, 29, 513, 50));
	edtInfix->SetAnchors(nlib::caLeft | nlib::caTop);
	edtInfix->GetFont().SetFamily(L"Tahoma");
	edtInfix->GetFont().SetSize(10);
	edtInfix->SetParentFont(false);
	edtInfix->SetTabOrder(0);
	edtInfix->SetParent(this);

	btnClearInfix = new nlib::FlatButton();
	btnClearInfix->SetBounds(nlib::Rect(492, 29, 513, 50));
	btnClearInfix->GetFont().SetFamily(L"Tahoma");
	btnClearInfix->GetFont().SetSize(10);
	btnClearInfix->GetFont().SetBold(true);
	btnClearInfix->SetParentFont(false);
	btnClearInfix->SetText(L"x");
	btnClearInfix->SetBorderStyle(nlib::BorderStyles::bsSingle);
	btnClearInfix->SetParent(this);

	gbResults = new nlib::Groupbox();
	gbResults->SetBounds(nlib::Rect(16, 52, 521, 175));
	gbResults->SetText(L"Result");
	gbResults->SetPadding(nlib::Rect(0, 0, 0, 0));
	gbResults->GetFont().SetFamily(L"Tahoma");
	gbResults->GetFont().SetSize(10);
	gbResults->SetParentFont(false);
	gbResults->SetTabOrder(2);
	gbResults->SetParent(this);

	btnDecimal = new nlib::Button();
	btnDecimal->SetBounds(nlib::Rect(1, 16, 80, 39));
	btnDecimal->SetText(L"Deci&mal");
	btnDecimal->SetTabOrder(1);
	btnDecimal->SetTooltipText(L"Copy decimal number to clipboard");
	btnDecimal->SetParent(gbResults);

	btnHexadecimal = new nlib::Button();
	btnHexadecimal->SetTag(1);
	btnHexadecimal->SetBounds(nlib::Rect(1, 41, 80, 64));
	btnHexadecimal->SetText(L"&Hexadecimal");
	btnHexadecimal->SetTabOrder(2);
	btnHexadecimal->SetTooltipText(L"Copy hexadec. number to clipboard");
	btnHexadecimal->SetParent(gbResults);

	btnOctal = new nlib::Button();
	btnOctal->SetTag(2);
	btnOctal->SetBounds(nlib::Rect(2, 67, 81, 90));
	btnOctal->SetText(L"O&ctal");
	btnOctal->SetTabOrder(4);
	btnOctal->SetTooltipText(L"Copy octal number to clipboard");
	btnOctal->SetParent(gbResults);

	btnBinary = new nlib::Button();
	btnBinary->SetTag(3);
	btnBinary->SetBounds(nlib::Rect(2, 94, 81, 117));
	btnBinary->SetText(L"&Binary");
	btnBinary->SetTabOrder(6);
	btnBinary->SetTooltipText(L"Copy binary number to clipboard");
	btnBinary->SetParent(gbResults);

	pnlDec = new nlib::Panel();
	pnlDec->SetBounds(nlib::Rect(83, 15, 500, 40));
	pnlDec->GetFont().SetFamily(L"Arial");
	pnlDec->GetFont().SetSize(10);
	pnlDec->GetFont().SetCharacterSet(nlib::fcsAnsi);
	pnlDec->GetFont().SetOutputQuality(nlib::foqDraft);
	pnlDec->SetParentFont(false);
	pnlDec->SetTabOrder(0);
	pnlDec->SetShowText(false);
	pnlDec->SetInnerBorderStyle(nlib::pbsSunken);
	pnlDec->SetTextAlignment(nlib::taRight);
	pnlDec->SetParent(gbResults);

	pnlHex = new nlib::Panel();
	pnlHex->SetBounds(nlib::Rect(83, 41, 500, 66));
	pnlHex->GetFont().SetFamily(L"Arial");
	pnlHex->GetFont().SetSize(10);
	pnlHex->SetParentFont(false);
	pnlHex->SetTabOrder(3);
	pnlHex->SetInnerBorderStyle(nlib::pbsSunken);
	pnlHex->SetTextAlignment(nlib::taRight);
	pnlHex->SetParent(gbResults);

	pnlOct = new nlib::Panel();
	pnlOct->SetBounds(nlib::Rect(83, 67, 500, 92));
	pnlOct->GetFont().SetFamily(L"Arial");
	pnlOct->GetFont().SetSize(10);
	pnlOct->SetParentFont(false);
	pnlOct->SetTabOrder(5);
	pnlOct->SetInnerBorderStyle(nlib::pbsSunken);
	pnlOct->SetTextAlignment(nlib::taRight);
	pnlOct->SetParent(gbResults);

	pnlBin = new nlib::Panel();
	pnlBin->SetBounds(nlib::Rect(83, 93, 500, 118));
	pnlBin->GetFont().SetFamily(L"Arial");
	pnlBin->GetFont().SetSize(10);
	pnlBin->SetParentFont(false);
	pnlBin->SetTabOrder(7);
	pnlBin->SetInnerBorderStyle(nlib::pbsSunken);
	pnlBin->SetTextAlignment(nlib::taRight);
	pnlBin->SetParent(gbResults);

	pnlDecOpt = new nlib::Panel();
	pnlDecOpt->SetBounds(nlib::Rect(8, 191, 513, 301));
	pnlDecOpt->SetTabOrder(3);
	pnlDecOpt->SetInnerBorderStyle(nlib::pbsNone);
	pnlDecOpt->SetParent(this);

	gbDecOptions = new nlib::Groupbox();
	gbDecOptions->SetBounds(nlib::Rect(11, 1, 230, 105));
	gbDecOptions->SetText(L"Decimal options");
	gbDecOptions->SetPadding(nlib::Rect(0, 0, 0, 0));
	gbDecOptions->GetFont().SetFamily(L"Tahoma");
	gbDecOptions->GetFont().SetSize(10);
	gbDecOptions->SetParentFont(false);
	gbDecOptions->SetTabOrder(0);
	gbDecOptions->SetParent(pnlDecOpt);

	chkSep = new nlib::Checkbox();
	chkSep->SetBounds(nlib::Rect(8, 16, 165, 33));
	chkSep->SetText(L"Use t&housand separator:");
	chkSep->GetFont().SetFamily(L"Tahoma");
	chkSep->GetFont().SetSize(10);
	chkSep->SetParentFont(false);
	chkSep->SetTabOrder(0);
	chkSep->SetState(nlib::csChecked);
	chkSep->SetParent(gbDecOptions);

	chkDecDelim = new nlib::Checkbox();
	chkDecDelim->SetBounds(nlib::Rect(8, 31, 160, 47));
	chkDecDelim->SetText(L"Use decimal separator");
	chkDecDelim->SetTabOrder(6);
	chkDecDelim->SetParent(gbDecOptions);

	cbThousandSep = new nlib::Combobox();
	cbThousandSep->SetBounds(nlib::Rect(166, 13, 217, 40));
	cbThousandSep->SetText(L"spc");
	cbThousandSep->GetFont().SetFamily(L"Tahoma");
	cbThousandSep->GetFont().SetSize(10);
	cbThousandSep->SetParentFont(false);
	cbThousandSep->SetTabOrder(1);
	cbThousandSep->SetType(nlib::ctDropdownList);
	cbThousandSep->Items().Add(L"spc");
	cbThousandSep->Items().Add(L",");
	cbThousandSep->Items().Add(L".");
	cbThousandSep->Items().Add(L";");
	cbThousandSep->SetItemIndex(0);
	cbThousandSep->SetParent(gbDecOptions);

	chkSci = new nlib::Checkbox();
	chkSci->SetBounds(nlib::Rect(8, 45, 141, 62));
	chkSci->SetText(L"&Scientific format");
	chkSci->GetFont().SetFamily(L"Tahoma");
	chkSci->GetFont().SetSize(10);
	chkSci->SetParentFont(false);
	chkSci->SetTabOrder(2);
	chkSci->SetParent(gbDecOptions);

	chkEng = new nlib::Checkbox();
	chkEng->SetBounds(nlib::Rect(8, 62, 149, 79));
	chkEng->SetText(L"Engeneering f&ormat");
	chkEng->GetFont().SetFamily(L"Tahoma");
	chkEng->GetFont().SetSize(10);
	chkEng->SetParentFont(false);
	chkEng->SetTabOrder(3);
	chkEng->SetParent(gbDecOptions);

	chkDecDigits = new nlib::Checkbox();
	chkDecDigits->SetBounds(nlib::Rect(8, 80, 149, 97));
	chkDecDigits->SetText(L"&Decimal digits:");
	chkDecDigits->GetFont().SetFamily(L"Tahoma");
	chkDecDigits->GetFont().SetSize(10);
	chkDecDigits->SetParentFont(false);
	chkDecDigits->SetTabOrder(4);
	chkDecDigits->SetParent(gbDecOptions);

	spnDecDigits = new nlib::Edit();
	spnDecDigits->SetBounds(nlib::Rect(166, 77, 202, 98));
	spnDecDigits->SetText(L"0");
	spnDecDigits->GetFont().SetFamily(L"Tahoma");
	spnDecDigits->GetFont().SetSize(10);
	spnDecDigits->SetParentFont(false);
	spnDecDigits->SetTabOrder(5);
	spnDecDigits->SetParent(gbDecOptions);

	UpDownDecDigits = new nlib::UpDown();
	UpDownDecDigits->SetBounds(nlib::Rect(177, 77, 194, 98));
	UpDownDecDigits->SetMaxValue(80);
	UpDownDecDigits->SetParent(gbDecOptions);

	gbAngleUnit = new nlib::Groupbox();
	gbAngleUnit->SetBounds(nlib::Rect(236, 7, 492, 53));
	gbAngleUnit->SetText(L"Angles in");
	gbAngleUnit->SetPadding(nlib::Rect(0, 0, 0, 0));
	gbAngleUnit->GetFont().SetFamily(L"Tahoma");
	gbAngleUnit->GetFont().SetSize(10);
	gbAngleUnit->SetParentFont(false);
	gbAngleUnit->SetTabOrder(1);
	gbAngleUnit->SetParent(pnlDecOpt);

	rdDeg = new nlib::Radiobox();
	rdDeg->SetTag(0);
	rdDeg->SetBounds(nlib::Rect(11, 19, 59, 35));
	rdDeg->SetText(L"De&g");
	rdDeg->GetFont().SetFamily(L"Tahoma");
	rdDeg->GetFont().SetSize(10);
	rdDeg->SetParentFont(false);
	rdDeg->SetTabOrder(0);
	rdDeg->SetTooltipText(L"Degrees");
	rdDeg->SetChecked(true);
	rdDeg->SetParent(gbAngleUnit);

	rdRad = new nlib::Radiobox();
	rdRad->SetTag(1);
	rdRad->SetBounds(nlib::Rect(59, 19, 114, 35));
	rdRad->SetText(L"&Rad");
	rdRad->GetFont().SetFamily(L"Tahoma");
	rdRad->GetFont().SetSize(10);
	rdRad->SetParentFont(false);
	rdRad->SetTabOrder(1);
	rdRad->SetTooltipText(L"Radians");
	rdRad->SetParent(gbAngleUnit);

	rdGrad = new nlib::Radiobox();
	rdGrad->SetTag(2);
	rdGrad->SetBounds(nlib::Rect(116, 19, 172, 35));
	rdGrad->SetText(L"&Grad");
	rdGrad->GetFont().SetFamily(L"Tahoma");
	rdGrad->GetFont().SetSize(10);
	rdGrad->SetParentFont(false);
	rdGrad->SetTabOrder(2);
	rdGrad->SetTooltipText(L"360º = 400 grad");
	rdGrad->SetParent(gbAngleUnit);


	rdTurn = new nlib::Radiobox();
	rdTurn->SetTag(3);
	rdTurn->SetBounds(nlib::Rect(184, 19, 248, 37));
	rdTurn->SetText(L"&Turns");
	rdTurn->SetTabOrder(3);
	rdTurn->SetTooltipText(L"360º = 1 turn");
	rdTurn->SetParent(gbAngleUnit);

	gbDisplayFormat = new nlib::Groupbox();
	gbDisplayFormat->SetBounds(nlib::Rect(236, 59, 492, 105));
	gbDisplayFormat->SetText(L"Display as");
	gbDisplayFormat->SetPadding(nlib::Rect(0, 0, 0, 0));
	gbDisplayFormat->GetFont().SetFamily(L"Tahoma");
	gbDisplayFormat->GetFont().SetSize(10);
	gbDisplayFormat->SetParentFont(false);
	gbDisplayFormat->SetTabOrder(2);
	gbDisplayFormat->SetParent(pnlDecOpt);

	rdNormal = new nlib::Radiobox();
	rdNormal->SetBounds(nlib::Rect(11, 19, 91, 35));
	rdNormal->SetText(L"Norm&al");
	rdNormal->GetFont().SetFamily(L"Tahoma");
	rdNormal->GetFont().SetSize(10);
	rdNormal->SetParentFont(false);
	rdNormal->SetTabOrder(0);
	rdNormal->SetChecked(true);
	rdNormal->SetTooltipText(L"Exponent display with 10's power");
	rdNormal->SetParent(gbDisplayFormat);

	rdHtml = new nlib::Radiobox();
	rdHtml->SetTag(1);
	rdHtml->SetBounds(nlib::Rect(77, 20, 141, 36));
	rdHtml->SetText(L"&HTML");
	rdHtml->GetFont().SetFamily(L"Tahoma");
	rdHtml->GetFont().SetSize(10);
	rdHtml->SetParentFont(false);
	rdHtml->SetTabOrder(1);
	rdHtml->SetTooltipText(L"Exponent display with <sup>x</sup>");
	rdHtml->SetParent(gbDisplayFormat);

	rdTex = new nlib::Radiobox();
	rdTex->SetTag(2);
	rdTex->SetBounds(nlib::Rect(142, 20, 190, 36));
	rdTex->SetText(L"&TeX");
	rdTex->GetFont().SetFamily(L"Tahoma");
	rdTex->GetFont().SetSize(10);
	rdTex->SetParentFont(false);
	rdTex->SetTabOrder(2);
	rdTex->SetTooltipText(L"Exponent display with {10^x}");
	rdTex->SetParent(gbDisplayFormat);

	rdNone = new nlib::Radiobox();
	rdNone->SetTag(3);
	rdNone->SetBounds(nlib::Rect(198, 20, 238, 36));
	rdNone->SetText(L"E");
	rdNone->SetTabOrder(3);
	rdNone->SetTooltipText(L"Exponent display as 'Ex'");
	rdNone->SetParent(gbDisplayFormat);

	pnlHexOpt = new nlib::Panel();
	pnlHexOpt->SetBounds(nlib::Rect(8, 325, 515, 407));
	pnlHexOpt->SetTabOrder(4);
	pnlHexOpt->SetInnerBorderStyle(nlib::pbsNone);
	pnlHexOpt->SetParent(this);

	gbHexOptions = new nlib::Groupbox();
	gbHexOptions->SetBounds(nlib::Rect(8, 1, 490, 75));
	gbHexOptions->SetText(L"Hexadecimal Options");
	gbHexOptions->SetPadding(nlib::Rect(0, 0, 0, 0));
	gbHexOptions->GetFont().SetFamily(L"Tahoma");
	gbHexOptions->GetFont().SetSize(10);
	gbHexOptions->SetParentFont(false);
	gbHexOptions->SetTabOrder(0);
	gbHexOptions->SetParent(pnlHexOpt);

	chkMinus = new nlib::Checkbox();
	chkMinus->SetBounds(nlib::Rect(8, 18, 102, 35));
	chkMinus->SetText(L"M&inus sign");
	chkMinus->GetFont().SetFamily(L"Tahoma");
	chkMinus->GetFont().SetSize(10);
	chkMinus->SetParentFont(false);
	chkMinus->SetTabOrder(0);
	chkMinus->SetTooltipText(L"Absolute value of negative numbers are shown with a minus sign");
	chkMinus->SetParent(gbHexOptions);

	chkHexPrefix = new nlib::Checkbox();
	chkHexPrefix->SetBounds(nlib::Rect(8, 52, 111, 68));
	chkHexPrefix->SetText(L"0x p&refix");
	chkHexPrefix->SetTabOrder(7);
	chkHexPrefix->SetChecked(true);
	chkHexPrefix->SetParent(gbHexOptions);

	chkLittleEndian = new nlib::Checkbox();
	chkLittleEndian->SetTag(6);
	chkLittleEndian->SetBounds(nlib::Rect(360, 52, 446, 69));
	chkLittleEndian->SetText(L"&Little endian");
	chkLittleEndian->GetFont().SetFamily(L"Tahoma");
	chkLittleEndian->GetFont().SetSize(10);
	chkLittleEndian->SetParentFont(false);
	chkLittleEndian->SetTabOrder(1);
	chkLittleEndian->SetTooltipText(L"Left to right order of bytes from least significant to most significant (Intel ordering)");
	chkLittleEndian->SetParent(gbHexOptions);

	chkBytes = new nlib::Checkbox();
	chkBytes->SetTag(1);
	chkBytes->SetBounds(nlib::Rect(116, 18, 202, 35));
	chkBytes->SetText(L"As B&ytes");
	chkBytes->GetFont().SetFamily(L"Tahoma");
	chkBytes->GetFont().SetSize(10);
	chkBytes->SetParentFont(false);
	chkBytes->SetTabOrder(2);
	chkBytes->SetParent(gbHexOptions);

	chkWords = new nlib::Checkbox();
	chkWords->SetTag(2);
	chkWords->SetBounds(nlib::Rect(116, 35, 202, 52));
	chkWords->SetText(L"As &Words");
	chkWords->GetFont().SetFamily(L"Tahoma");
	chkWords->GetFont().SetSize(10);
	chkWords->SetParentFont(false);
	chkWords->SetTabOrder(3);
	chkWords->SetParent(gbHexOptions);

	chkDWords = new nlib::Checkbox();
	chkDWords->SetTag(3);
	chkDWords->SetBounds(nlib::Rect(116, 52, 202, 69));
	chkDWords->SetText(L"As DWo&rds");
	chkDWords->GetFont().SetFamily(L"Tahoma");
	chkDWords->GetFont().SetSize(10);
	chkDWords->SetParentFont(false);
	chkDWords->SetTabOrder(4);
	chkDWords->SetParent(gbHexOptions);

	chkIEEESingle = new nlib::Checkbox();
	chkIEEESingle->SetTag(4);
	chkIEEESingle->SetBounds(nlib::Rect(203, 18, 321, 35));
	chkIEEESingle->SetText(L"As IEE &754 single");
	chkIEEESingle->GetFont().SetFamily(L"Tahoma");
	chkIEEESingle->GetFont().SetSize(10);
	chkIEEESingle->SetParentFont(false);
	chkIEEESingle->SetTabOrder(5);
	chkIEEESingle->SetTooltipText(L"Single precision floating point format");
	chkIEEESingle->SetParent(gbHexOptions);

	chkIEEEDouble = new nlib::Checkbox();
	chkIEEEDouble->SetTag(5);
	chkIEEEDouble->SetBounds(nlib::Rect(203, 35, 321, 52));
	chkIEEEDouble->SetText(L"As IEE 7&54 double");
	chkIEEEDouble->GetFont().SetFamily(L"Tahoma");
	chkIEEEDouble->GetFont().SetSize(10);
	chkIEEEDouble->SetParentFont(false);
	chkIEEEDouble->SetTabOrder(6);
	chkIEEEDouble->SetTooltipText(L"Double precision floating point format");
	chkIEEEDouble->SetParent(gbHexOptions);

	Label1 = new nlib::Label();
	Label1->SetBounds(nlib::Rect(256, 177, 313, 193));
	Label1->SetText(L"As String:");
	Label1->GetFont().SetFamily(L"Tahoma");
	Label1->GetFont().SetSize(10);
	Label1->SetParentFont(false);
	Label1->SetParent(this);

	edtChars = new nlib::Edit();
	edtChars->SetBounds(nlib::Rect(317, 176, 438, 197));
	edtChars->GetFont().SetFamily(L"Tahoma");
	edtChars->GetFont().SetSize(10);
	edtChars->SetParentFont(false);
	edtChars->SetTabOrder(5);
	edtChars->SetReadOnly(true);
	edtChars->SetParent(this);

	btnFont = new nlib::FlatButton();
	btnFont->SetBounds(nlib::Rect(440, 175, 508, 198));
	btnFont->SetText(L"&Font...");
	btnFont->GetFont().SetFamily(L"Tahoma");
	btnFont->GetFont().SetSize(10);
	btnFont->SetParentFont(false);
	btnFont->SetTabOrder(6);
	btnFont->SetAcceptInput(true);
	btnFont->SetFlat(false);
	btnFont->SetParent(this);

	btnCloseDecOptions = new nlib::FlatButton();
	btnCloseDecOptions->SetBounds(nlib::Rect(14, 175, 242, 187));
	btnCloseDecOptions->SetText(L"-------------------------------------------");
	btnCloseDecOptions->GetFont().SetFamily(L"Tahoma");
	btnCloseDecOptions->GetFont().SetSize(10);
	btnCloseDecOptions->SetParentFont(false);
	btnCloseDecOptions->SetTabOrder(7);
	btnCloseDecOptions->SetParent(this);

	btnCloseHexOptions = new nlib::FlatButton();
	btnCloseHexOptions->SetBounds(nlib::Rect(14, 311, 242, 323));
	btnCloseHexOptions->SetText(L"-------------------------------------------");
	btnCloseHexOptions->GetFont().SetFamily(L"Tahoma");
	btnCloseHexOptions->GetFont().SetSize(10);
	btnCloseHexOptions->SetParentFont(false);
	btnCloseHexOptions->SetTabOrder(8);
	btnCloseHexOptions->SetParent(this);

	SetActiveControl(edtInfix);
	SetMenu(mnuMain);
	btnOpenHexOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28672)));
	btnOpenDecOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28673)));
	tbExit->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28674)));
	tbHistory->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28675)));
	tbCopy->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28676)));
	tbPaste->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28677)));
	pnlDec->SetPopupMenu(pmCopy);
	pnlHex->SetPopupMenu(pmCopy);
	pnlOct->SetPopupMenu(pmCopy);
	pnlBin->SetPopupMenu(pmCopy);
	UpDownDecDigits->SetAttachedEditor(spnDecDigits);
	btnFont->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28678)));
	btnFont->Image()->SetStateCount(2);
	btnCloseDecOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28679)));
	btnCloseHexOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28680)));

	OnStartSizeMove = CreateEvent(this, &TfrmMain::StartMove);
	OnMove = CreateEvent(this, &TfrmMain::FormMove);
	OnEndSizeMove = CreateEvent(this, &TfrmMain::FormSizeMoveEnded);
	OnClose = CreateEvent(this, &TfrmMain::FormClose);
	miCopyDec->OnClick = CreateEvent(this, &TfrmMain::miCopyDecClick);
	miCopyHex->OnClick = CreateEvent(this, &TfrmMain::miCopyHexClick);
	miCopyOct->OnClick = CreateEvent(this, &TfrmMain::miCopyOctClick);
	miCopyBin->OnClick = CreateEvent(this, &TfrmMain::miCopyBinClick);
	miCopyText->OnClick = CreateEvent(this, &TfrmMain::miCopyClick);
	miExit->OnClick = CreateEvent(this, &TfrmMain::miExitClick);
	miCopy->OnClick = CreateEvent(this, &TfrmMain::miCopyClick);
	miPaste->OnClick = CreateEvent(this, &TfrmMain::miPasteClick);
	miAppend->OnClick = CreateEvent(this, &TfrmMain::miAppendClick);
	miCopyDecimal->OnClick = CreateEvent(this, &TfrmMain::miCopyDecClick);
	miCopyHexadecimal->OnClick = CreateEvent(this, &TfrmMain::miCopyHexClick);
	miCopyOctal->OnClick = CreateEvent(this, &TfrmMain::miCopyOctClick);
	miCopyBinary->OnClick = CreateEvent(this, &TfrmMain::miCopyBinClick);
	miEditVars->OnClick = CreateEvent(this, &TfrmMain::miEditVarsClick);
	miEditFuncs->OnClick = CreateEvent(this, &TfrmMain::miEditFuncsClick);
	miShowHist->OnClick = CreateEvent(this, &TfrmMain::miShowHistClick);
	miClearHist->OnClick = CreateEvent(this, &TfrmMain::miClearHistClick);
	miShowDecOpts->OnClick = CreateEvent(this, &TfrmMain::miShowDecOptsClick);
	miShowHexOpts->OnClick = CreateEvent(this, &TfrmMain::miShowHexOptsClick);
	miCharFont->OnClick = CreateEvent(this, &TfrmMain::miCharFontClick);
	miShowHist->OnClick = CreateEvent(this, &TfrmMain::miShowHistClick);
	miHistOpts->OnClick = CreateEvent(this, &TfrmMain::miHistOptsClick);
	miAbout->OnClick = CreateEvent(this, &TfrmMain::miAboutClick);
	miGenHelp->OnClick = CreateEvent(this, &TfrmMain::miGenHelpClick);
	btnOpenHexOptions->OnClick = CreateEvent(this, &TfrmMain::btnOpenHexOptionsClick);
	btnOpenDecOptions->OnClick = CreateEvent(this, &TfrmMain::btnOpenDecOptionsClick);
	tbExit->OnClick = CreateEvent(this, &TfrmMain::tbExitClick);
	tbHistory->OnClick = CreateEvent(this, &TfrmMain::tbHistoryClick);
	tbCopy->OnClick = CreateEvent(this, &TfrmMain::tbCopyClick);
	tbPaste->OnClick = CreateEvent(this, &TfrmMain::tbPasteClick);
	edtInfix->OnKeyDown = CreateEvent(this, &TfrmMain::edtInfixKeyDown);
	edtInfix->OnTextChanged = CreateEvent(this, &TfrmMain::edtInfixTextChanged);
	btnClearInfix->OnClick = CreateEvent(this, &TfrmMain::btnClearInfixClick);
	btnDecimal->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnHexadecimal->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnOctal->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnBinary->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	pnlDec->OnPaint = CreateEvent(this, &TfrmMain::pnlDecPaint);
	chkSep->OnClick = CreateEvent(this, &TfrmMain::chkSepClick);
	cbThousandSep->OnChanged = CreateEvent(this, &TfrmMain::cbThousandSepChanged);
	chkSci->OnClick = CreateEvent(this, &TfrmMain::chkSciClick);
	chkEng->OnClick = CreateEvent(this, &TfrmMain::chkSciClick);
	chkDecDigits->OnClick = CreateEvent(this, &TfrmMain::chkDecDigitsClick);
	chkDecDelim->OnClick = CreateEvent(this, &TfrmMain::chkDecDelimClick);
	spnDecDigits->OnTextChanged = CreateEvent(this, &TfrmMain::spnDecDigitsTextChanged);
	rdDeg->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdGrad->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdRad->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdTurn->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdNormal->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdHtml->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdTex->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdNone->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	chkMinus->OnClick = CreateEvent(this, &TfrmMain::chkMinusClick);
	chkLittleEndian->OnClick = CreateEvent(this, &TfrmMain::chkLittleEndianClick);
	chkHexPrefix->OnClick = CreateEvent(this, &TfrmMain::chkHexPrefixClick);
	chkBytes->OnClick = CreateEvent(this, &TfrmMain::chkAsBytesClick);
	chkWords->OnClick = CreateEvent(this, &TfrmMain::chkAsWordsClick);
	chkDWords->OnClick = CreateEvent(this, &TfrmMain::chkAsDWordsClick);
	chkIEEESingle->OnClick = CreateEvent(this, &TfrmMain::chkIEEESingleClick);
	chkIEEEDouble->OnClick = CreateEvent(this, &TfrmMain::chkIEEEDoubleClick);
	btnFont->OnClick = CreateEvent(this, &TfrmMain::btnFontClick);
	btnCloseDecOptions->OnClick = CreateEvent(this, &TfrmMain::btnCloseDecOptionsClick);
	btnCloseHexOptions->OnClick = CreateEvent(this, &TfrmMain::btnCloseHexOptionsClick);
}

// for fun
	vector<MONITORINFOEX> monitors;
// callback function called by EnumDisplayMonitors for each enabled monitor
BOOL CALLBACK EnumDispProc(HMONITOR hMon, HDC dcMon, RECT* pRcMon, LPARAM lParam)
{
	MONITORINFOEX mi;
	mi.cbSize = sizeof(MONITORINFOEX);
	if( GetMonitorInfo(hMon, &mi) )
		monitors.push_back(mi);

	return TRUE;	// continue enum
}
// /for fun
TfrmMain::TfrmMain()
{
	InitializeFormAndControls();
	wiMain.InitInfo(this, L"frmMain");
	_wsUserDir = _GetUserDir();
	_GetVirtualDisplaySize();
	// /for fun
	_bAutoSave = false;

	RealNumber::SetMaxLength(65);	// but only display 59
    lengine = new FalconCalc::LittleEngine;
	lengine->displayFormat.useNumberPrefix = true;
	lengine->displayFormat.strThousandSeparator = " "_ss;
	lengine->displayFormat.displWidth = 59;

	lengine->ssNameOfDatFile = SmartString(AppendToPath(_wsUserDir, FalconCalc_DAT_FILE).c_str());
	try
	{
		lengine->LoadUserData();	// may throw because of many errors
	}
	catch (...)
	{
		;
	}
	// add the clipboard and set this window as a "viewer"
	MyClipboard = new Clipboard();	   // messages arrive after
	MyClipboard->Activate( Handle() ); // Handle() is called first

    _chkArr[0] = chkMinus;
    _chkArr[1] = chkBytes;
    _chkArr[2] = chkWords;
    _chkArr[3] = chkDWords;
    _chkArr[4] = chkIEEESingle;
    _chkArr[5] = chkIEEEDouble;
    _chkArr[6] = chkLittleEndian;

    _nDecOptTop = pnlDecOpt->Top();
    _nHexBtnTop = btnOpenHexOptions->Top();

    // ?? spnDecDigits->SetValue(20);
    pslHistory = new TStringList;
    pslHistory->SetCaseSensitive(false);
    pslHistory->SetDuplicates(true);  // no duplicates
    pslHistory->SetSorted(false);
    pslHistory->LoadFromFile(AppendToPath(_wsUserDir, FalconCalc_HIST_FILE).c_str());
    _watchdog = 0;
    _watchLimit = 5; // seconds
	_maxHistDepth=0; // unlimited

    if(!_LoadState(AppendToPath(_wsUserDir, FalconCalc_CFG_FILE).c_str()))
    {
        ShowDecOptions(false);
        ShowHexOptions(false);
    }

    _added = false;

}
LRESULT TfrmMain::WindowProc(UINT msg, WPARAM w,LPARAM l)
{
	switch(msg)
	{
		case  WM_TIMER:
			    if(_bAutoSave && ++_watchdog >= _watchLimit && lengine->ResultOk() && !_added && !edtInfix->Text().empty())
					    _AddToHistory(edtInfix->Text());
				break;
		case WM_CHANGECBCHAIN:
				// If the next clipboard viwer window is closing, repair the chain.
				// Otherwise, pass the message to the next link.
				MyClipboard->ChangeNextViewer((HWND) w, (HWND) l);
				break;
		case WM_DRAWCLIPBOARD:
				// if the content of the clipboard has been changed
				// enable or disable paste menu and button
			   {
					bool enable = IsClipboardFormatAvailable(CF_UNICODETEXT) || IsClipboardFormatAvailable(CF_TEXT);
					miPaste->SetEnabled(enable);
					tbPaste->SetEnabled(enable);
			   }
				// and pass the message on
				MyClipboard->Forward( msg, w, l);
				break;

		default: return Form::WindowProc(msg,w,l);
	}
	return 0;
}
TfrmMain::~TfrmMain()
{
	/* Don't 'delete' the form. Call Destroy() instead which has access to the protected destructor. */
	delete 	MyClipboard;
}

void TfrmMain::Destroy()
{
	lengine->SaveUserData();
    _SaveState(AppendToPath(_wsUserDir, FalconCalc_CFG_FILE).c_str());
    pslHistory->SaveToFile(AppendToPath(_wsUserDir, FalconCalc_HIST_FILE).c_str());
    delete pslHistory;
    delete lengine;
	Form::Destroy();
}

void TfrmMain::btnFontClick(void *sender, nlib::EventParameters param)
{
	FontDialog1->SetFont( edtChars->GetFont());
	if(FontDialog1->Show(this))
	{
		edtChars->SetFont(FontDialog1->GetFont());
	}
}

void TfrmMain::edtInfixKeyDown(void *sender, nlib::KeyParameters param)
{
    _watchdog = 0;   // reset counter
	if(edtInfix->Text().empty())
        return;

    if(param.keycode == VK_RETURN)
        _AddToHistory(edtInfix->Text());
    else if(param.keycode != VK_RIGHT && param.keycode != VK_LEFT && param.keycode != VK_UP && param.keycode != VK_DOWN &&
            param.keycode != VK_TAB)
    {
		//if(param.keycode != 17 || !param.vkeys.contains(vksCtrl))  // 17 - Ctrl-H
                _added = false;
    }
}

void TfrmMain::btnClearInfixClick(void* sender, nlib::EventParameters param)
{
	edtInfix->SetText(L"");
}

void TfrmMain::pnlDecPaint(void *sender, nlib::PaintParameters param)
{
	sa::GraphicText gtDec;
	Canvas *pCanvas = pnlDec->GetCanvas();
	pCanvas->FillRect(1,1,pnlDec->Width()-4, pnlDec->Height()-1);
	if(pnlDec->Text().empty() )
		return;

	gtDec.SetCanvas(  pCanvas );
	gtDec.SetText(pnlDec->Text(), 0, lengine->displayFormat.expFormat != ExpFormat::rnsfGraph);
	int y = (pnlDec->Height() - gtDec.Box().Height())/2 - gtDec.Box().TopLeft().y;
	if(y < 0)
		y = 0;
	gtDec.Draw(pnlDec->Width() - gtDec.Box().Width()-4, y);
}

void TfrmMain::_GetVirtualDisplaySize()
{
	//----- SA -------------------
	// for fun
	EnumDisplayMonitors(0, 0, EnumDispProc, 0); 	// get all monitors
	// get virtual window size
	RECT r = { 0 };
	//	r.left = r.right=r.top=r.bottom = 0'
	for (size_t i = 0; i < monitors.size(); ++i)
	{
		if (monitors[i].rcMonitor.left < r.left)
			r.left = monitors[i].rcMonitor.left;
		if (monitors[i].rcMonitor.top < r.top)
			r.top = monitors[i].rcMonitor.top;
		if (monitors[i].rcMonitor.bottom > r.bottom)
			r.bottom = monitors[i].rcMonitor.bottom;
		if (monitors[i].rcMonitor.right > r.right)
			r.right = monitors[i].rcMonitor.right;
	}
	if (Left() > r.right || Top() > r.bottom || Bottom() < r.top || Right() < r.left)
	{
		SetLeft(((r.right - r.left) - Width()) / 2);
		SetTop(((r.bottom - r.top) - Height()) / 2);
	}
}

void TfrmMain::_ShowResults()	// from lengine
{
    if(edtInfix->Text().empty())
    {
		_ShowMessageOnAllPanels(L"");
        return;
    }
    if(lengine->resultType== LittleEngine::ResultType::rtDefinition) // function definition?
    {
        _ShowMessageOnAllPanels(L"Definition");
        return;
    }
    else if(lengine->resultType == LittleEngine::ResultType::rtInvalid)
    {
		_ShowMessageOnAllPanels(L"???");
        return;
    }
	// DEBUG
	// SmartString s = lengine->ResultAsDecString();
	// /DEBUG
	pnlDec->SetText(lengine->ResultAsDecString().ToWideString());
	pnlDec->Invalidate();
    pnlHex->SetText(lengine->ResultAsHexString().ToWideString());
    pnlOct->SetText(lengine->ResultAsOctString().ToWideString());
    pnlBin->SetText(lengine->ResultAsBinString().ToWideString());
    edtChars->SetText(lengine->ResultAsCharString().ToWideString());

	SetFocus(edtInfix->Handle());
}

// display same message in all panels
void TfrmMain::_ShowMessageOnAllPanels(wstring s)
{
    pnlDec->SetText(s);
	pnlDec->Invalidate();

    pnlHex->SetText(s);
    pnlOct->SetText(s);
    pnlBin->SetText(s);
    edtChars->SetText(L"");
}

void TfrmMain::edtInfixTextChanged(void *sender, nlib::EventParameters param)
{
	if (_busy)
		return;

	if(edtInfix->Text().empty() )
    {
        _ShowMessageOnAllPanels(L"");
        return;
    }
    wstring s = edtInfix->Text();
//	cbInfix->SetText(s);
    try
    {
		lengine->infix = s;
        RealNumber res = lengine->Calculate();
        gbResults->SetText(L"Results");
        _ShowResults();
        s = lengine->Postfix().ToWideString();
    }
    catch(wstring s)
    {
        gbResults->SetText(s);
        _ShowMessageOnAllPanels(L"???");
    }
    catch(Trigger_Type tt)
    {
        gbResults->SetText(triggerMap[tt].ToWideString());
        _ShowMessageOnAllPanels(L"???");
    }
    catch(...)
    {
        _ShowMessageOnAllPanels(L"???");
    }
	--_busy;
}

void TfrmMain::rdDegClick(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.angUnit = (LongNumber::AngularUnit)((Radiobox*)sender)->Tag();
	edtInfixTextChanged(sender,param);
	SetFocus(edtInfix->Handle());
}

void TfrmMain::spnDecDigitsTextChanged(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.decDigits = UpDownDecDigits->Position();
	if (chkDecDigits->Checked())
		_ShowResults();
	else
		lengine->displayFormat.decDigits = - (lengine->displayFormat.decDigits+1);	// changed, but not shown
	//else
	//	SetFocus(edtInfix->Handle());
}

void TfrmMain::tbCopyClick(void *sender, nlib::EventParameters param)
{
    miCopyClick(sender,param);
}

void TfrmMain::tbExitClick(void *sender, nlib::EventParameters param)
{
	Close();
}

void TfrmMain::tbHistoryClick(void *sender, nlib::EventParameters param)
{
	miShowHistClick(sender,param);
}

void TfrmMain::tbPasteClick(void *sender, nlib::EventParameters param)
{
	miPasteClick(sender,param);
}

void TfrmMain::chkDecDigitsClick(void *sender, nlib::EventParameters param)
{

	lengine->displayFormat.decDigits = chkDecDigits->Checked() ? UpDownDecDigits->Position() : -1;
    _ShowResults();
}

void TfrmMain::chkDecDelimClick(void* sender, nlib::EventParameters param)
{
	lengine->displayFormat.useFractionSeparator = chkDecDelim->Checked();
	_ShowResults();
}

void TfrmMain::chkMinusClick(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.bSignedBinOrHex = chkMinus->Checked();
	_ShowResults();
}

void TfrmMain::chkHexPrefixClick(void* sender, nlib::EventParameters param)
{
	lengine->displayFormat.useNumberPrefix = chkHexPrefix->Checked();
	_ShowResults();
}

void TfrmMain::chkSciClick(void *sender, nlib::EventParameters param)
{
  if(_busy)
    return;
  ++_busy;
  Checkbox *ps = ((Checkbox*)sender),
            *pd = (ps == chkSci ? chkEng : chkSci);
  lengine->displayFormat.mainFormat = ps->Checked() ? ( (ps == chkSci) ? NumberFormat::rnfSci : NumberFormat::rnfEng) : NumberFormat::rnfGeneral;
  pd->SetChecked(false);
    _ShowResults();
  --_busy;
}

void TfrmMain::chkSepClick(void *sender, nlib::EventParameters param)
{
    bool b = chkSep->Checked();
    cbThousandSep->SetEnabled(b);
	if (b && cbThousandSep->ItemIndex() >= 0)
	{
		lengine->displayFormat.strThousandSeparator = SmartString(cbThousandSep->ItemIndex() > 0 ? cbThousandSep->Text()[0] : ' ');
	}
	else
		lengine->displayFormat.strThousandSeparator.clear();
    _ShowResults();
}

void TfrmMain::miExitClick(void *sender, nlib::EventParameters param)
{
	Close();
}

void TfrmMain::miCopyClick(void *sender, nlib::EventParameters param)
{
    if(edtInfix->SelLength())
        MyClipboard->SetText(edtInfix->SelText());
    else
        MyClipboard->SetText( edtInfix->Text());
}

void TfrmMain::miPasteClick(void *sender, nlib::EventParameters param)
{
    edtInfix->SetText(edtInfix->Text().substr(0, edtInfix->SelStart()) +
			MyClipboard->GetText() + edtInfix->Text().substr(edtInfix->SelStart(),999));
}

void TfrmMain::miAppendClick(void *sender, nlib::EventParameters param)
{
    edtInfix->SetText( edtInfix->Text() + MyClipboard->GetText());
}

void TfrmMain::miEditVarsClick(void *sender, nlib::EventParameters param)
{
	MenuItem* pVarMenu = (MenuItem*)sender;
	int tag = pVarMenu->Tag();		// 0 variables,  1: functions
	if (frmVariables)
	{
		if (tag != frmVariables->tcVars->SelectedTab())		// switch TAB
		{
			frmVariables->tcVars->SetSelectedTab(tag);
			bool bvar = tag ? false : true,
				bfunc = tag ? true : false;
			miEditVars->SetChecked(bvar);
			miEditFuncs->SetChecked(bfunc);
		}
		else
		{
			frmVariables->Close();
			frmVariables = nullptr;
			wiVars.RefreshInfo();
			miEditVars->SetChecked (false);
			miEditFuncs->SetChecked(false);
		}
	}
	else
	{
		OpenVarsOrFunctions(sender, tag, param);
		pVarMenu->SetChecked(true);
	}
	SetFocus(edtInfix->Handle());
}

void TfrmMain::miEditFuncsClick(void *sender, nlib::EventParameters param)
{
	miEditVarsClick(sender, param);
}

// TASK: to show history window below, stacked above or beside main window
// EPECTS:
// RETURNS: nothing
// REMARKS: sets position and size of history window
void TfrmMain::miShowHistClick(void *sender, nlib::EventParameters param)
{
	if(frmHistory)		// already set
	{
		frmHistory->Close();
		((MenuItem*)sender)->SetChecked(false);
		frmHistory = nullptr;
	}
	else
	{
		frmHistory = new TfrmHistory;
		frmHistory->SetTopLevelParent(this);
		frmHistory->SetLeft(Left());
		frmHistory->SetTop(Bottom() + 1);
		frmHistory->chkSorted->SetChecked(pslHistory->Sorted());
		frmHistory->GetSnapSide();
		frmHistory->Snap();
		frmHistory->lstHistory->Items().SetLines(pslHistory->Lines());
		frmHistory->Show();
		((MenuItem*)sender)->SetChecked(true);
	}
	wiHist.InitInfo(frmHistory, L"frmHistory");
	SetFocus(edtInfix->Handle());
}

void TfrmMain::miClearHistClick(void *sender, nlib::EventParameters param)
{
    pslHistory->Clear();
	if(frmHistory)
		frmHistory->lstHistory->Clear();
}

void TfrmMain::miShowDecOptsClick(void *sender, nlib::EventParameters param)
{
	ShowDecOptions(!pnlDecOpt->Visible());
}

void TfrmMain::miShowHexOptsClick(void *sender, nlib::EventParameters param)
{
	ShowHexOptions(!pnlHexOpt->Visible());
}

void TfrmMain::miHistOptsClick(void *sender, nlib::EventParameters param)
{
	frmHistOptions = new TfrmHistOptions;
	frmHistOptions->SetTopLevelParent(this);
    frmHistOptions->Setup(_maxHistDepth, _watchLimit, pslHistory->Sorted() , _minCharLength);

	if(frmHistOptions->ShowModal() == mrOk)
    {
        if(frmHistOptions->chkDepth->Checked())
        {
            _maxHistDepth = frmHistOptions->spinDepthBtn->Position();
			pslHistory->SetCapacity(_maxHistDepth);
			if(frmHistory)
				frmHistory->lstHistory->Items().SetLines(pslHistory->Lines());
        }
		_minCharLength = stoi(frmHistOptions->edtMinLength->Text());
        if(frmHistOptions->chkAutoSave->Checked())
        {
			wstring str = frmHistOptions->edtInterval->Text();
			int h = 0, m = 0, s = 0;
			int n = swscanf(str.c_str(), L"%d:%d:%d", &h, &m, &s);
			if(n != 3)
			{
				s = m;
				m = h;
				h = 0;
				if(n != 2)
				{
					s = m;
					m = 0;;
				}
			}
            _watchLimit = h*3600 + m*60 + s;
        }
        else
        {
            _watchLimit = 0;
        }
        // Timer1->Enabled = _watchLimit > 0;
		_EnableMyTimer(_watchLimit > 0);
        pslHistory->SetSorted(frmHistOptions->chkSort->Checked(),true);	// first (last entered) line is not sorted
        if(frmHistory)
            frmHistory->lstHistory->Items().SetLines(pslHistory->Lines());

    }
	frmHistOptions->Destroy();
	frmHistOptions = NULL;
}

void TfrmMain::miAboutClick(void *sender, nlib::EventParameters param)
{
	frmAbout = new TfrmAbout;
	frmAbout ->SetTopLevelParent(this);
	frmAbout ->ShowModal();
	frmAbout->Destroy();
}

void TfrmMain::miGenHelpClick(void *sender, nlib::EventParameters param)
{
	frmHelp = new TfrmHelp;
	frmHelp ->SetTopLevelParent(this);
	frmHelp ->ShowModal();
	frmHelp->Destroy();
}

void TfrmMain::miCharFontClick(void *sender, nlib::EventParameters param)
{
	btnFont->Click();
}

void TfrmMain::miCopyDecClick(void *sender, nlib::EventParameters param)
{
	wstring ws = pnlDec->Text();	// reformat for 'normal' number
	int pos;
	if( (pos = ws.find_first_of(_CHART(183)) ) != wstring::npos)
		ws = ws.substr(0,pos) + _CHART('e') + ws.substr(pos+5, ws.length()-pos-5-1);
	MyClipboard->SetText(ws );
}

void TfrmMain::miCopyHexClick(void *sender, nlib::EventParameters param)
{
	MyClipboard->SetText(pnlHex->Text() );
}

void TfrmMain::miCopyOctClick(void *sender, nlib::EventParameters param)
{
	MyClipboard->SetText(pnlOct->Text() );
}

void TfrmMain::miCopyBinClick(void *sender, nlib::EventParameters param)
{
	MyClipboard->SetText(pnlBin->Text() );
}
void TfrmMain::cbThousandSepChanged(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.strThousandSeparator =  SmartString(cbThousandSep->ItemIndex() > 0 ? cbThousandSep->Text()[0] : ' ');
	if(lengine->displayFormat.strThousandSeparator == SmartString('s') )
		lengine->displayFormat.strThousandSeparator = " ";
	_ShowResults();
}

void TfrmMain::ShowDecOptions(bool show)
{
    if(pnlDecOpt->Visible() == show)
        return;
    miShowDecOpts->SetChecked(show);
    if(show)
    {
        SetHeight( Height() + pnlDecOpt->Height());
        btnOpenHexOptions->SetTop(_nHexBtnTop);
            // although this is common for both show and not show
            // if this is set AFTER 'pnlDecOpt' is shown the
            // btnCloseHexOptions remains on the screen over the panel in XE
        btnCloseHexOptions->SetTop(btnOpenHexOptions->Top());

        pnlDecOpt->SetTop(_nDecOptTop);
    }
    else
    {
// DEBUG 2 lines
// int hp = pnlDecOpt->Height(),
// h = Height();
        SetHeight(Height() - pnlDecOpt->Height());
// h = Height(); // DEBUG
        btnOpenHexOptions->SetTop(_nDecOptTop);
        btnCloseHexOptions->SetTop(btnOpenHexOptions->Top());
    }
    pnlDecOpt->SetVisible(show);
    pnlHexOpt->SetTop( btnOpenHexOptions->Top() + btnOpenHexOptions->Height()+2);
    btnOpenDecOptions->SetVisible(!show);
    btnCloseDecOptions->SetVisible(show);
}

//---------------------------------------------------------------------------
void TfrmMain::ShowHexOptions(bool show)
{
    if(pnlHexOpt->Visible() == show)
        return;
    miShowHexOpts->SetChecked(show);
    int h = pnlHexOpt->Height()-5;
    if(!show)
        h = -h;
// DEBUG
//int hh = Height();
    SetHeight(Height() + h);
//hh = Height();
    pnlDecOpt->SetTop(_nDecOptTop);

    pnlHexOpt->SetVisible(show);
    btnOpenHexOptions->SetVisible(!show);
    btnCloseHexOptions->SetVisible(show);
}

void TfrmMain::OpenVarsOrFunctions(void* sender, int which, nlib::EventParameters param)
{
	VarFuncInfo vf;
	lengine->GetVarFuncInfo(vf);
	Rect wrect = wiMain.BareVisibleWindowRect();

	if (!frmVariables)
	{
		frmVariables = new TfrmVariables;
		frmVariables->SetTopLevelParent(this);
		frmVariables->SetLeft(wrect.right+1);
		frmVariables->SetTop(WindowRect().top);

		frmVariables->Setup(vf);
		wiVars.InitInfo(frmVariables, L"frmVariables");
	}
	else
	{
		TabChangeParameters par(which);
		frmVariables->tcVarsTabChange(sender, par);
		wiVars.RefreshInfo();
	}
	frmVariables->tcVars->SetSelectedTab(which);
	if (frmVariables->GetSnapSide() != FalconCalc::WindowSide::wsNone)
		frmVariables->Snap();

	frmVariables->Show();

	SetFocus(edtInfix->Handle());
}

void TfrmMain::btnCloseDecOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowDecOptions(false);
}

void TfrmMain::btnCloseHexOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowHexOptions(false);
}

void TfrmMain::btnOpenDecOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowDecOptions(true);
}

void TfrmMain::btnOpenHexOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowHexOptions(true);
}

// SA
void TfrmMain::_EnableMyTimer(bool enable)
{
//	if(_bAutoSave == enable)
//		return;
	if(enable)
		SetTimer(Handle(), (UINT_PTR)0x12, 1000, 0); // Timer1
	else
		KillTimer(Handle(),(UINT_PTR)0x12);
	_bAutoSave = enable;
}

FalconCalc::LittleEngine* TfrmMain::pEngine()
{
	return lengine;
}

/*
* Status file is a text file. its data:
*  	   <ID line>
*	mainformat=<mainformat>
*   decFormat=<# dec. digits (-1* ()-1 if not used>|<exponent format>|<1|0+index of thousand sep. char.* (-1) if not used>|<useFractionSeparator>|<angular unit>
*   hexFormat=<hexFormat>|<is little endian>|<signed bin or hex><IEEE format>
*	fontName=<font name>,
*	fontData=<font size>|<font charset>|<font color>,
*	options=<dec.options visible>|<hex options visile>
*	histOptions=<timeot>|<max. hist depth>|<is history sorted>
*	last=<text of last expression>
*/

static const wstring
		MAINFORMAT(L"mainFormat="),
		DECFORMAT(L"decFormat="),
		HEXFORMAT(L"hexFormat="),
		FONTNAME(L"fontName="),
		FONTDATA(L"fontData="),
		OPTIONS(L"options="),
		HISTOPTIONS(L"histOptions="),
		VARCOLS(L"varCols="),
		LAST(L"last=");


/*=============================================================
 * TASK   : reads line from file splits it up at '|' delimiters
 * PARAMS : fs: open file stream
 *			data: vector of wstrings corresponding to data
 * EXPECTS:
 * GLOBALS:
 * RETURNS: >0 => (# of strings in line + 1) and data filled
 *			==0 => error, equal line not found
 * REMARKS: keeps empty fields as empty wstrings
 *------------------------------------------------------------*/
static int __ReadAndSplitLine(FileStream& fs, std::vector<wstring>& data)
{
	if (fs.eof())	// no more output?
		return 0;

	wchar_t wbuf[1024];
	SmartString s;
	do
	{
		fs.getline(wbuf, 1023);
		s = SmartString(wbuf);
		s.Trim();
	} while (!fs.eof() && s.empty() );

	std::vector<SmartString> sdata;

	int n = s.indexOf('=');
	if (n < 0)
		return -1;
	SmartString name = s.left(++n);	// name + '='

	if (!s.length())
		sdata.clear();
	else			   // cut name= and get the other fields
		sdata = s.mid(n).Split(SCharT('|'), true);
	data.clear();
	data.push_back(name.ToWideString());
	for (auto& s : sdata)
		data.push_back(s.ToWideString());
	return data.size();
}

std::wstring TfrmMain::_GetUserDir()
{
	wchar_t buff[2046];
	std::wstring w;
	if (!SHGetFolderPath(NULL, CSIDL_PROFILE, NULL, 0, buff))
	{
		w = buff;

		w += L"\\AppData\\Local\\FalconCalc";
		if (!PathExists(w))
		{
			if (!CreateDirectory(w.c_str(), NULL))
				w = (wstring&)ExecutablePath;
		}
	}
	else
		w = (wstring&)ExecutablePath;

	return w;
}

bool TfrmMain::_SaveState(wstring name)
{
	FileStream fs(name,ios_base::out);

     if(fs.fail())
        return false;
    fs << STATE_VER_STRING << "\n";
	fs << MAINFORMAT<< (int)lengine->displayFormat.mainFormat << "\n";

	//int u = UpDown1->Position() + (chkDecDigits->Checked() ? 0x100 : 0); // 0x100: checked state. must use Position as num_digits may be -1
	wstring wsep = (chkSep->Checked() ? L"1" : L"0") + (std::to_wstring(cbThousandSep->ItemIndex()));
	fs << DECFORMAT<< lengine->displayFormat.decDigits << "|" << (int)lengine->displayFormat.expFormat
	   << "|" << wsep <<  "|" << (int)lengine->displayFormat.useFractionSeparator
	   << "|" << (int)lengine->AngleUnit() << "\n";

    fs << HEXFORMAT<< (int)lengine->displayFormat.hexFormat << "|"<< (int)lengine->displayFormat.littleEndian << "|"<<
			(int)lengine->displayFormat.bSignedBinOrHex << "|" << (int)lengine->displayFormat.trippleE <<"|" << (int)lengine->displayFormat.useNumberPrefix << "\n";

	fs << FONTNAME	<< edtChars->GetFont().Family() << "\n";
	fs << FONTDATA	<< (int)edtChars->GetFont().Size() << "|"<< (int)edtChars->GetFont().CharacterSet() << "|"<< (COLORREF)edtChars->GetFont().GetColor() << "\n";
    fs << OPTIONS	<< pnlDecOpt->Visible() << "|"<< pnlHexOpt->Visible()<<"\n";
    fs << HISTOPTIONS << _watchLimit << "|"<< _maxHistDepth << "|"<< pslHistory->Sorted() << "|" << _minCharLength << "\n";
	fs << VARCOLS; 
	for (int i = 0; i < 2; ++i)
		for (int col = 0; col < 4; ++col)
		{
			fs << TfrmVariables::_colW[i][col];
			if(i != 1 || col != 3)
				fs << "|";
		}
    if(!edtInfix->Text().empty())
        fs << LAST <<  edtInfix->Text() << "\n";
    return true;
}
bool TfrmMain::_LoadState(wstring name)
{
	FileStream fs(name,ios_base::in);
    if(fs.fail())
        return false;
	DisplayFormat dspFormat;
//	wstring s;
	wchar_t wbuf[1024];// , nam[1024];
	fs.getline(wbuf,1023);

    if(wcscmp(wbuf, STATE_VER_STRING) )
        return false;

    int n, val =0;

	std::vector<wstring> data;
	auto mainFormat = [&]()	-> bool // returns true if not processed, false if processed
	{
		if (n==2 && data[0] == MAINFORMAT)	// only one field
		{
			val = std::stoi(data[1]);
			lengine->displayFormat.mainFormat = static_cast<NumberFormat>(val);
			++_busy;
			switch (lengine->displayFormat.mainFormat)
			{
				case NumberFormat::rnfSci:
					chkSci->SetChecked(true);
					break;
				case NumberFormat::rnfEng:
					chkEng->SetChecked(true);
					break;
			}
			--_busy;
			return true;
		}
		return false;
	};
	auto decFormat = [&]()
	{
		if (n == 6 && data[0] == DECFORMAT)		// 6 fields
		{
			++_busy;
					// 1: decimal digits
			val = std::stoi(data[1]);	// # of decimal digits n > 0 => used digits, n < 0 => used = abs(n+1)
			lengine->displayFormat.decDigits = val;
			if (val >= 0)
				chkDecDigits->SetChecked(true);
			else
				val = std::abs(val + 1);
			UpDownDecDigits->SetPosition(val);
					// 2: exponent display format
			val = std::stoi(data[2]);	// (0)E: 1E5, (1)HTML: 1<sp>12</sup>, (2)TeX: 1^{12}, (3)normal: 1²³
			lengine->displayFormat.expFormat = static_cast<ExpFormat>(val);
			if(lengine->displayFormat.expFormat == ExpFormat::rnsfE)
				rdNone->SetChecked(true);
			else if(lengine->displayFormat.expFormat == ExpFormat::rnsfSciHTML)
				rdHtml->SetChecked(true);
			else if (lengine->displayFormat.expFormat == ExpFormat::rnsfSciTeX)
				rdTex->SetChecked(true);
			else if (lengine->displayFormat.expFormat == ExpFormat::rnsfGraph)
			{
				rdNormal->SetChecked(true);
			}
					// 3: thousand separator string
			if (!data[3].empty())	// can only be '.', ',' and space
			{
				if (data[3][0] == L'1')
					chkSep->SetChecked(true);
				else if (data[3][1] == L'0')
					cbThousandSep->SetItemIndex(0);
				else if (data[3][1] == L'1')
					cbThousandSep->SetItemIndex(1);
				else if (data[3][1] == L'2')
					cbThousandSep->SetItemIndex(2);
				if (chkSep->Checked())
					lengine->displayFormat.strThousandSeparator = SmartString(cbThousandSep->ItemIndex() > 0 ? cbThousandSep->Text()[0] : ' ');
			}
					// 4: fraction separator
			if (!data[4].empty() && data[4] == L"1")
				chkDecDelim->SetState(nlib::csChecked);
					// 5: angular unit 0:
			if (!data[5].empty())
				lengine->displayFormat.angUnit = static_cast<AngularUnit>(std::stoi(data[5]));

			--_busy;

			return true;
		}
		return false;

	};
	auto hexFormat = [&]()
	{
		if (n == 6 && data[0] == HEXFORMAT)	// 5 fields
		{
			++_busy;
				// 1. main Hex format
			int val = std::stoi(data[1]);
			lengine->displayFormat.hexFormat = static_cast<HexFormat>(val);
			switch (lengine->displayFormat.hexFormat)
			{
				case HexFormat::rnHexNormal:
					break;
				case HexFormat::rnHexByte:
					chkBytes->SetChecked(true);
					break;
				case HexFormat::rnHexWord:
					chkWords->SetChecked(true);
					break;
				case HexFormat::rnHexDWord:
					chkDWords->SetChecked(true);
					break;
			}
				// 2. endianness
			val = std::stoi(data[2]);
			if (val)
				chkLittleEndian->SetChecked(true);
				// 3. signed bin or hex?
			val = std::stoi(data[3]);
			if (val)
				chkMinus->SetChecked(true);
				// 4. IEEE format
			val = std::stoi(data[4]);
			// val = 0: no check
			if (val==1)
				chkIEEESingle->SetChecked(true);
			else if(val==2)
				chkIEEEDouble->SetChecked(true);
			--_busy;
				// 5. number prefix is used on hex. numbers
			val = std::stoi(data[5]);
			lengine->displayFormat.useNumberPrefix = val;
			chkHexPrefix->SetChecked(val);
			return true;
		}
		return false;

	};
	auto fontName = [&]()
	{
		if (n==2 && data[0] == FONTNAME)  // 2 fields
		{
			Font f = edtChars->GetFont();
			f.SetFamily(data[1]);
			edtChars->SetFont(f);
			return true;
		}
		return false;

	};
	auto fontData = [&]()
	{
		if (n == 3 && data[0] == FONTDATA)	// 3 fields
		{
			Font f = edtChars->GetFont();
			f.SetSize(std::stof(data[1]));
			f.SetCharacterSet(static_cast<FontCharacterSets>(std::stoi(data[2])));
			f.SetColor(std::stoul(data[2]));
			return true;
		}
		return false;

	};
	auto options = [&]()					  // 3 fields
	{
		if (n == 3 && data[0] == OPTIONS)
		{
			ShowDecOptions(std::stoi(data[1])!=0);
			ShowHexOptions(std::stoi(data[2])!=0);
			return true;
		}
		return false;

	};
	auto histOptions = [&]()
	{
		if (n == 5 && data[0] == HISTOPTIONS)	// 5 fields
		{
			_watchLimit = std::stoi(data[1]);
			_maxHistDepth = std::stoi(data[2]);
			pslHistory->SetSorted(std::stoi(data[3]));
			_minCharLength = std::stoi(data[4]);
			return true;
		}
		return false;

	};
	auto varCols = [&]()
		{
			if (n == 9 && data[0] == VARCOLS)
			{
				for (int i = 0; i < 2; ++i)
					for (int col = 0; col < 4; ++col)
						TfrmVariables::_colW[i][col] = std::stoi(data[col + 4 * i+1]);
				return true;
			}
			return false;
		};
	auto last = [&](wstring &lastinfix)		
	{
		if (n==2 && data[0] == LAST)
		{
			lastinfix = data[1];
		}
	};

	wstring wsLlastInfix;

	while ((n = __ReadAndSplitLine(fs, data)))
	{
		if (data[0][data[0].length() - 1] == SCharT('='))	// valid line
		{
			if(!mainFormat() )
				if(!decFormat())
					if(!hexFormat())
						if(!fontName())
							if(!fontData())
								if(!options())
									if(!histOptions())
										if(!varCols())
											last(wsLlastInfix);
		}
	}

	_EnableMyTimer(_watchLimit > 0);
    --_busy;
    return true;
}
// Adds actual expression to history
// Always inserts line at first position (top of list)
// For sorted list it first inserts the original first line
// then insert the new at the top
// If the expression was already in the list deletes it first from the list
void TfrmMain::_AddToHistory(wstring text)
{
	SmartString ss(text);
	ss.Trim();

	if (_minCharLength >= ss.length())	// do not add to short strings
		return;

	if (LittleEngine::variables.count(ss) || LongNumber::constantsMap.count(ss) )		// single, already defined variable?
	{
		_added = true;	// so won't try it to add again
		_watchdog = 0;
		return;
	}

    int n;
    if( (n = pslHistory->IndexOf(ss)) >= 0)
    {
        if(n == 0 && pslHistory->Sorted())	// already at top
            return;							// nothing to do
        pslHistory->Delete(n);				// not at top delete expression from inside
    }
	else if(pslHistory->Sorted() )			// then must put original top line in correct position
	{										// first and add the new line afterwards, because
		SmartString ws = (*pslHistory)[0];		// list may be truncated after adding a new line to it
		pslHistory->Delete(0);				// delete original top line
		pslHistory->Add(ws);					// and insert into string
	}

    pslHistory->Insert(0, ss);				// then insert new expression to top of list

    _added = true;
    _watchdog = 0;
    if(frmHistory != 0)
        frmHistory->lstHistory->Items().SetLines(pslHistory->Lines());
}

void TfrmMain::FormClose(void *sender, nlib::FormCloseParameters param)
{
	if (frmHistory)
		frmHistory->Close();
	if (frmVariables)
		frmVariables->Close();
}

void TfrmMain::chkAsBytesClick(void *sender, nlib::EventParameters param)
{
	chkWords->SetChecked(false);
	chkDWords->SetChecked(false);
	bool b = chkBytes->Checked();
	if(b)
		lengine->displayFormat.hexFormat = HexFormat::rnHexByte;
	else
		lengine->displayFormat.hexFormat = HexFormat::rnHexNormal;
//	chkLittleEndian->SetEnabled(b);
	_ShowResults();
}

void TfrmMain::chkAsWordsClick(void *sender, nlib::EventParameters param)
{
	chkBytes->SetChecked(false);
	chkDWords->SetChecked(false);
	bool b = chkWords->Checked();
	if (b)
		lengine->displayFormat.hexFormat = HexFormat::rnHexWord;
	else
		lengine->displayFormat.hexFormat = HexFormat::rnHexNormal;
//	chkLittleEndian->SetEnabled(b);
	_ShowResults();
}

void TfrmMain::chkAsDWordsClick(void *sender, nlib::EventParameters param)
{
	chkWords->SetChecked(false);
	chkBytes->SetChecked(false);
	bool b = chkDWords->Checked();
	if (b)
		lengine->displayFormat.hexFormat = HexFormat::rnHexDWord;
	else
		lengine->displayFormat.hexFormat = HexFormat::rnHexNormal;
//	chkLittleEndian->SetEnabled(b);
	_ShowResults();
}

void TfrmMain::chkIEEEDoubleClick(void *sender, nlib::EventParameters param)
{
	chkIEEESingle->SetChecked(false);
	lengine->displayFormat.trippleE =  chkIEEEDouble->Checked() ? IEEEFormat::rntHexIEEE754Double : IEEEFormat::rntHexNotIEEE;
	_ShowResults();
}

void TfrmMain::chkIEEESingleClick(void *sender, nlib::EventParameters param)
{
	chkIEEEDouble->SetChecked(false);
	lengine->displayFormat.trippleE =  chkIEEESingle->Checked() ? IEEEFormat::rntHexIEEE754Single : IEEEFormat::rntHexNotIEEE;
	_ShowResults();
}

void TfrmMain::chkLittleEndianClick(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.littleEndian =  chkLittleEndian->Checked() ? true: false;
	_ShowResults();
}

void TfrmMain::btnCopyFormatClick(void *sender, nlib::EventParameters param)
{
	Button *pb = reinterpret_cast<Button*>(sender);
	switch (pb->Tag())
	{
		case 0: miCopyDecClick(sender, param); break;
		case 1: MyClipboard->SetText(pnlHex->Text() ); break;
		case 2: MyClipboard->SetText(pnlOct->Text() ); break;
		case 3: MyClipboard->SetText(pnlBin->Text() ); break;
	}
	SetFocus(edtInfix->Handle());
}

void TfrmMain::StartMove(void *sender, nlib::EventParameters param)
{
	++_inMoving;
}

void TfrmMain::FormSizeMoveEnded(void* sender, nlib::SizePositionChangedParameters param)
{
	--_inMoving;
	wiMain.RefreshInfo();

	if (frmHistory && !frmHistory->Snapped())
		if (frmHistory->GetSnapSide() != FalconCalc::wsNone)
			frmHistory->Snap();

	if (frmVariables && !frmVariables->Snapped())
		if (frmVariables->GetSnapSide() != FalconCalc::wsNone)
			frmVariables->Snap();
}

void TfrmMain::FormMove(void *sender, nlib::EventParameters param)
{
	wiMain.RefreshInfo();
	if (frmHistory && frmHistory->Snapped())
		frmHistory->Snap();

	if (frmVariables && frmVariables->Snapped())
		frmVariables->Snap();
}
	// this single funcion deals with Normal, HTML, TeX and E display
void TfrmMain::rdNormalClick(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.expFormat= (LongNumber::ExpFormat)((Radiobox*)sender)->Tag();
	//sres.type = sres.mode == bmoNone ? stDecimal : stDecBeautified;
	_ShowResults();
}
