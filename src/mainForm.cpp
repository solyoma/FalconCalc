#include <set>

#include "common.h"
#include "stdafx_zoli.h"
#include "stdafx_lc.h"
#undef max

#include <windows.h>
#include <shlobj.h>
#include <iostream>
#include <userenv.h>	// for getting the user directory on windows

#include "wcommon.h"
using namespace nlib;

#include "application.h"
#include "about.h"
#include "help.h"

#include "mainForm.h"
#include "frmLocale.h"

#include "history.h"
#include "histopt.h"

#include "graphictext.h"

#include "SmartString.h"
using namespace SmString;
#include "LongNumber.h"
using namespace LongNumber;

using namespace FalconCalc;
using namespace std;

#include "common.h"
#include "calculate.h"
#include "resource.h"
#include "variables.h"
#include "translations.h"

Clipboard *MyClipboard;

TfrmMain *frmMain;

/*
* Status file is a text file. its data:
*  	   <ID line>
*	mainformat=<mainformat>
*   decFormat=<# dec. digits (-1* ()-1 if not used>|<exponent format>|<1|0+index of thousand sep. char.* (-1) if not used>|<useFractionSeparator>|<angular unit>
*   hexFormat=<hexFormat>|<is little endian>|<signed bin or hex><IEEE format>
*	fontName=<font name>,
*	fontData=<font size>|<font charset>|<font color>,
*	options=<dec.options visible>|<hex options visile>
*	histOptions=<timeot>|<max. hist depth>|<is history sorted>
*	last=<text of last expression>
*/

static const SmartString
MAINFORMAT("mainFormat="),
DECFORMAT("decFormat="),
HEXFORMAT("hexFormat="),
FONTNAME("fontName="),
FONTDATA("fontData="),
OPTIONS("options="),
HISTOPTIONS("histOptions="),
VARCOLS("varCols="),
LANGUAGE("language="),
LAST("last=");

/*=============================================================
 * TASK   : reads line from file splits it up at '|' delimiters
 * PARAMS : fs: open file stream
 *			data: vector of wstrings corresponding to data
 * EXPECTS:
 * GLOBALS:
 * RETURNS: >0 => (# of strings in line + 1) and data filled
 *			==0 => error, equal line not found
 * REMARKS: keeps empty fields as empty wstrings
 *------------------------------------------------------------*/
static int __ReadAndSplitLine(std::ifstream& fs, SmartStringVector& data)
{
	if (fs.eof())	// no more output?
		return 0;

	char wbuf[1024];
	SmartString s;
	do
	{
		fs.getline(wbuf, 1023);
		s = SmartString(wbuf);
		s.Trim();
	} while (!fs.eof() && s.empty());

	SmartStringVector sdata;

	int n = s.indexOf('=');
	if (n < 0)
		return -1;
	SmartString name = s.left(++n);	// name + '='

	if (!s.length())
		sdata.clear();
	else			   // cut name= and get the other fields
		sdata = s.mid(n).Split(SCharT('|'), true);
	data.clear();
	data.push_back(name);
	for (auto& s : sdata)
		data.push_back(s);
	return data.size();
}

/****************************************************************************************************************************************/

void TfrmMain::InitializeFormAndControls() /* Control initialization function generated by the designer. Modifications will be lost. */
{
	/* Generated member initialization. Do not modify. */
	SetLeft(777);
	SetTop(436);

#if defined(_DEBUG)
	SetText(L"FalconCalc - Debug");
#else
	SetText(L"FalconCalc");
#endif
	GetFont().SetFamily(L"Tahoma");
	GetFont().SetSize(10);
	SetWantedKeyTypes(nlib::wkArrows | nlib::wkTab | nlib::wkEnter | nlib::wkEscape | nlib::wkOthers);
	SetShowPosition(nlib::fspActiveMonitorCenter);
	SetBorderStyle(nlib::fbsSingle);	// setting to fbsSingle makes this unmoveable
	SetClientRect(nlib::Rect(0, 0, 528, 419 + GetSystemMetrics(SM_CYMENU)));

	// DEBUG 
	#ifdef _DEBUG
	//DebugEnumResources();
	#endif
	// /DEBUG
	MyLoadWindowIcon(this);

	FontDialog1 = new nlib::FontDialog();
	FontDialog1->GetFont().SetFamily(L"Tahoma");
	FontDialog1->GetFont().SetSize(8);
	FontDialog1->SetParent(this);

	pmCopy = new nlib::PopupMenu();
	miCopyDec = pmCopy->Add(lt.GetTranslationFor(FCT_COPYDEC));
	miCopyHex = pmCopy->Add(lt.GetTranslationFor(FCT_COPYHEX));
	miCopyOct = pmCopy->Add(lt.GetTranslationFor(FCT_COPYOCT));
	miCopyBin = pmCopy->Add(lt.GetTranslationFor(FCT_COPYBIN));
	miCopySep = pmCopy->Add(L"-");
	miCopyText = pmCopy->Add(lt.GetTranslationFor(FCT_COPYTEXT));
	pmCopy->SetParent(this);

	mnuMain = new nlib::Menubar();
	miFile = mnuMain->Add(lt.GetTranslationFor(FCT_FILE));
	miExit = miFile->Add(lt.GetTranslationFor(FCT_EXIT));
	miExit->SetShortcut(L"CTRL+W");
	miEdit = mnuMain->Add(lt.GetTranslationFor(FCT_EDIT));
	miCopy = miEdit->Add(lt.GetTranslationFor(FCT_COPYEXPR));
	miCopy->SetShortcutText(L"Ctrl+C");
	miPaste = miEdit->Add(lt.GetTranslationFor(FCT_PASTEEXPR));
	miPaste->SetShortcutText(L"Ctrl+V");
	miAppend = miEdit->Add(lt.GetTranslationFor(FCT_APPEND));
	miAppend->SetShortcut(L"Ctrl+Shift+V");
	separator1 = miEdit->Add(L"-");
	miShowHist = miEdit->Add(lt.GetTranslationFor(FCT_SHOWHIST));
	separator3a = miEdit->Add(L"-");
	mnuEditCopy = miEdit->Add(lt.GetTranslationFor(FCT_EDITCOPY));
	miCopyDecimal = mnuEditCopy->Add(lt.GetTranslationFor(FCT_COPYDEC));
	miCopyHexadecimal = mnuEditCopy->Add(lt.GetTranslationFor(FCT_COPYHEX));
	miCopyHexadecimal->SetTag(1);
	miCopyOctal = mnuEditCopy->Add(lt.GetTranslationFor(FCT_COPYOCT));
	miCopyOctal->SetTag(2);
	miCopyBinary = mnuEditCopy->Add(lt.GetTranslationFor(FCT_COPYBIN));
	miCopyBinary->SetTag(3);
	miData = miEdit->Add(lt.GetTranslationFor(FCT_DATA));
	miData->SetTag(1);
	miEditVars = miData->Add(lt.GetTranslationFor(FCT_EDITVARS));
	miEditVars->SetShortcut(L"Alt+1");
	miEditFuncs = miData->Add(lt.GetTranslationFor(FCT_EDITFUNCS));
	miEditFuncs->SetShortcut(L"Alt+2");
	miEditFuncs->SetTag(1);
	separator2 = miEdit->Add(L"-");
	miClearHist = miEdit->Add(lt.GetTranslationFor(FCT_CLEARHIST));
	miView = mnuMain->Add(lt.GetTranslationFor(FCT_VIEW));
	miShowDecOpts = miView->Add(lt.GetTranslationFor(FCT_SHOWDECOPTS));
	miShowDecOpts->SetShortcutText(L"Ctrl+D");
	miShowHexOpts = miView->Add(lt.GetTranslationFor(FCT_SHOWHEXOPTS));
	miShowHexOpts->SetShortcut(L"Ctrl+X");
	miShowHist->SetShortcut(L"Alt+3");
	mnuOptions = mnuMain->Add(lt.GetTranslationFor(FCT_OPTIONS));
	miLanguage = mnuOptions->Add(lt.GetTranslationFor(FCT_LANGUAGE));
	separator3 = mnuOptions->Add(L"-");
	miHistOpts = mnuOptions->Add(lt.GetTranslationFor(FCT_HISTOPTS));
	miLocale = mnuOptions->Add(lt.GetTranslationFor(FCT_LOCALE));
	miCharFont = mnuOptions->Add(lt.GetTranslationFor(FCT_CHARFONT));
	miSetEn  = miLanguage->Add(lt.GetTranslationFor(FCT_SETEN));
	miSetHun = miLanguage->Add(lt.GetTranslationFor(FCT_SETHUN));
	miHelp = mnuMain->Add(lt.GetTranslationFor(FCT_HELP));
	miAbout = miHelp->Add(lt.GetTranslationFor(FCT_ABOUT));
	miGenHelp = miHelp->Add(lt.GetTranslationFor(FCT_GENHELP));
	miGenHelp->SetShortcut(L"F1");
	mnuMain->SetParent(this);

	btnOpenHexOptions = new nlib::ToolButton();
	btnOpenHexOptions->SetBounds(nlib::Rect(14, 311, 242, 323));
	btnOpenHexOptions->SetText(lt.GetTranslationFor(FCT_HEXOPTSOPENER));
	btnOpenHexOptions->SetVisible(false);
	btnOpenHexOptions->GetFont().SetFamily(L"Tahoma");
	btnOpenHexOptions->GetFont().SetSize(10);
	btnOpenHexOptions->SetParentFont(false);
	btnOpenHexOptions->SetTabOrder(10);
	btnOpenHexOptions->SetParent(this);

	btnOpenDecOptions = new nlib::ToolButton();
	btnOpenDecOptions->SetBounds(nlib::Rect(14, 175, 242, 187));
	btnOpenDecOptions->SetText(lt.GetTranslationFor(FCT_DECOPTSOPENER));
	btnOpenDecOptions->SetVisible(false);
	btnOpenDecOptions->GetFont().SetFamily(L"Tahoma");
	btnOpenDecOptions->GetFont().SetSize(10);
	btnOpenDecOptions->SetParentFont(false);
	btnOpenDecOptions->SetTabOrder(9);
	btnOpenDecOptions->SetParent(this);

	pToolbar = new nlib::Panel();
	pToolbar->SetBounds(nlib::Rect(0, 0, 528, 29));
	pToolbar->SetAlignment(nlib::alTop);
	pToolbar->SetTabOrder(1);
	pToolbar->SetInnerBorderStyle(nlib::pbsNone);
	pToolbar->SetParent(this);

	tbExit = new nlib::ToolButton();
	tbExit->SetBounds(nlib::Rect(0, 0, 23, 23));
	tbExit->GetFont().SetFamily(L"Tahoma");
	tbExit->GetFont().SetSize(10);
	tbExit->SetParentFont(false);
	tbExit->SetTabOrder(0);
	tbExit->SetParent(pToolbar);

	Bevel1 = new nlib::Bevel();
	Bevel1->SetBounds(nlib::Rect(26, 1, 28, 22));
	Bevel1->SetShape(nlib::bstLeftLine);
	Bevel1->SetParent(pToolbar);

	tbHistory = new nlib::ToolButton();
	tbHistory->SetBounds(nlib::Rect(31, 0, 54, 23));
	tbHistory->GetFont().SetFamily(L"Tahoma");
	tbHistory->GetFont().SetSize(10);
	tbHistory->SetParentFont(false);
	tbHistory->SetParent(pToolbar);

	tbCopy = new nlib::ToolButton();
	tbCopy->SetBounds(nlib::Rect(55, 0, 78, 23));
	tbCopy->GetFont().SetFamily(L"Tahoma");
	tbCopy->GetFont().SetSize(10);
	tbCopy->SetParentFont(false);
	tbCopy->SetParent(pToolbar);

	tbPaste = new nlib::ToolButton();
	tbPaste->SetBounds(nlib::Rect(79, 0, 102, 23));
	tbPaste->SetEnabled(false);
	tbPaste->GetFont().SetFamily(L"Tahoma");
	tbPaste->GetFont().SetSize(10);
	tbPaste->SetParentFont(false);
	tbPaste->SetParent(pToolbar);

	cbInfix = new nlib::Combobox();
	cbInfix->SetBounds(nlib::Rect(8, 29, 492, 50));
	cbInfix->SetAnchors(nlib::caLeft | nlib::caTop);
	cbInfix->GetFont().SetFamily(L"Calibri");
	cbInfix->GetFont().SetSize(12);
	cbInfix->SetParentFont(false);
	cbInfix->SetTabOrder(0);
	cbInfix->SetParent(this);

	cbInfix->SetWantedKeyTypes(wkOthers | wkArrows | wkEnter);

	btnClearInfix = new nlib::ToolButton();
	btnClearInfix->SetBounds(nlib::Rect(492, 29, 513, 50));
	btnClearInfix->GetFont().SetFamily(L"Tahoma");
	btnClearInfix->GetFont().SetSize(10);
	btnClearInfix->GetFont().SetBold(true);
	btnClearInfix->SetParentFont(false);
	btnClearInfix->SetText(L"x");
	btnClearInfix->SetBorderStyle(nlib::BorderStyles::bsSingle);
	btnClearInfix->SetParent(this);

	gbResults = new nlib::Groupbox();
	gbResults->SetBounds(nlib::Rect(16, 54, 521, 175));
	gbResults->SetText(lt.GetTranslationFor(FCT_DEC));
	gbResults->SetPadding(nlib::Rect(0, 0, 0, 0));
	gbResults->GetFont().SetFamily(L"Tahoma");
	gbResults->GetFont().SetSize(10);
	gbResults->SetParentFont(false);
	gbResults->SetParent(this);

	btnDecimal = new nlib::Button();
	btnDecimal->SetBounds(nlib::Rect(1, 16, 80, 39));
	btnDecimal->SetText(lt.GetTranslationFor(FCT_DEC));
	btnDecimal->SetTabOrder(1);
	btnDecimal->SetTooltipText(lt.GetTranslationFor(FCT_TIPDEC));
	btnDecimal->SetParent(gbResults);

	btnHexadecimal = new nlib::Button();
	btnHexadecimal->SetTag(1);
	btnHexadecimal->SetBounds(nlib::Rect(1, 41, 80, 64));
	btnHexadecimal->SetText(lt.GetTranslationFor(FCT_HEX));
	btnHexadecimal->SetTabOrder(2);
	btnHexadecimal->SetTooltipText(lt.GetTranslationFor(FCT_TIPHEX));
	btnHexadecimal->SetParent(gbResults);

	btnOctal = new nlib::Button();
	btnOctal->SetTag(2);
	btnOctal->SetBounds(nlib::Rect(2, 67, 81, 90));
	btnOctal->SetText(lt.GetTranslationFor(FCT_OCT));
	btnOctal->SetTabOrder(3);
	btnOctal->SetTooltipText(lt.GetTranslationFor(FCT_TIPOCT));
	btnOctal->SetParent(gbResults);

	btnBinary = new nlib::Button();
	btnBinary->SetTag(4);
	btnBinary->SetBounds(nlib::Rect(2, 94, 81, 117));
	btnBinary->SetText(lt.GetTranslationFor(FCT_BIN));
	btnBinary->SetTabOrder(4);
	btnBinary->SetTooltipText(lt.GetTranslationFor(FCT_TIPBIN));
	btnBinary->SetParent(gbResults);

	pnlDec = new nlib::Panel();
	pnlDec->SetBounds(nlib::Rect(83, 15, 500, 40));
	pnlDec->GetFont().SetFamily(L"Arial");
	pnlDec->GetFont().SetSize(10);
	pnlDec->GetFont().SetCharacterSet(nlib::fcsAnsi);
	pnlDec->GetFont().SetOutputQuality(nlib::foqDraft);
	pnlDec->SetParentFont(false);
	pnlDec->SetShowText(false);
	pnlDec->SetInnerBorderStyle(nlib::pbsSunken);
	pnlDec->SetTextAlignment(nlib::taRight);
	pnlDec->SetParent(gbResults);

	pnlHex = new nlib::Panel();
	pnlHex->SetBounds(nlib::Rect(83, 41, 500, 66));
	pnlHex->GetFont().SetFamily(L"Arial");
	pnlHex->GetFont().SetSize(10);
	pnlHex->SetParentFont(false);
	pnlHex->SetInnerBorderStyle(nlib::pbsSunken);
	pnlHex->SetTextAlignment(nlib::taRight);
	pnlHex->SetParent(gbResults);

	pnlOct = new nlib::Panel();
	pnlOct->SetBounds(nlib::Rect(83, 67, 500, 92));
	pnlOct->GetFont().SetFamily(L"Arial");
	pnlOct->GetFont().SetSize(10);
	pnlOct->SetParentFont(false);
	pnlOct->SetInnerBorderStyle(nlib::pbsSunken);
	pnlOct->SetTextAlignment(nlib::taRight);
	pnlOct->SetParent(gbResults);

	pnlBin = new nlib::Panel();
	pnlBin->SetBounds(nlib::Rect(83, 93, 500, 118));
	pnlBin->GetFont().SetFamily(L"Arial");
	pnlBin->GetFont().SetSize(10);
	pnlBin->SetParentFont(false);
	pnlBin->SetInnerBorderStyle(nlib::pbsSunken);
	pnlBin->SetTextAlignment(nlib::taRight);
	pnlBin->SetParent(gbResults);

	pnlDecOpt = new nlib::Panel();
	pnlDecOpt->SetBounds(nlib::Rect(8, 191, 513, 301));
	pnlDecOpt->SetInnerBorderStyle(nlib::pbsNone);
	pnlDecOpt->SetParent(this);

	gbDecOptions = new nlib::Groupbox();
	gbDecOptions->SetBounds(nlib::Rect(11, 1, 230, 105));
	gbDecOptions->SetText(lt.GetTranslationFor(FCT_DEC));
	gbDecOptions->SetPadding(nlib::Rect(0, 0, 0, 0));
	gbDecOptions->GetFont().SetFamily(L"Tahoma");
	gbDecOptions->GetFont().SetSize(10);
	gbDecOptions->SetParentFont(false);
	gbDecOptions->SetParent(pnlDecOpt);

	chkThousandSep = new nlib::Checkbox();
	chkThousandSep->SetBounds(nlib::Rect(8, 16, 165, 33));
	chkThousandSep->SetText(lt.GetTranslationFor(FCT_THOUSAND));
	chkThousandSep->GetFont().SetFamily(L"Tahoma");
	chkThousandSep->GetFont().SetSize(10);
	chkThousandSep->SetParentFont(false);
	chkThousandSep->SetTabOrder(5);
	chkThousandSep->SetState(nlib::csChecked);
	chkThousandSep->SetParent(gbDecOptions);

	chkDecDelim = new nlib::Checkbox();
	chkDecDelim->SetBounds(nlib::Rect(8, 33, 160, 47));
	chkDecDelim->SetText(lt.GetTranslationFor(FCT_DECSEP));
	chkDecDelim->SetTabOrder(7);
	chkDecDelim->SetParent(gbDecOptions);

	cbThousandSep = new nlib::Combobox();
	cbThousandSep->SetBounds(nlib::Rect(166, 13, 217, 40));
	cbThousandSep->SetText(L"spc");
	cbThousandSep->GetFont().SetFamily(L"Tahoma");
	cbThousandSep->GetFont().SetSize(10);
	cbThousandSep->SetParentFont(false);
	cbThousandSep->SetTabOrder(6);
	cbThousandSep->SetType(nlib::ctDropdownList);
	cbThousandSep->Items().Add(L"spc");
	cbThousandSep->Items().Add(L",");
	cbThousandSep->Items().Add(L".");
	cbThousandSep->Items().Add(L";");
	cbThousandSep->SetItemIndex(0);
	cbThousandSep->SetParent(gbDecOptions);

	chkSci = new nlib::Checkbox();
	chkSci->SetBounds(nlib::Rect(8, 48, 158, 62));
	chkSci->SetText(lt.GetTranslationFor(FCT_SCI));
	chkSci->GetFont().SetFamily(L"Tahoma");
	chkSci->GetFont().SetSize(10);
	chkSci->SetParentFont(false);
	chkSci->SetTabOrder(2);
	chkSci->SetParent(gbDecOptions);

	chkEng = new nlib::Checkbox();
	chkEng->SetBounds(nlib::Rect(8, 64, 149, 79));
	chkEng->SetText(lt.GetTranslationFor(FCT_ENG));
	chkEng->GetFont().SetFamily(L"Tahoma");
	chkEng->GetFont().SetSize(10);
	chkEng->SetParentFont(false);
	chkEng->SetTabOrder(9);
	chkEng->SetParent(gbDecOptions);

	chkDecDigits = new nlib::Checkbox();
	chkDecDigits->SetBounds(nlib::Rect(8, 80, 149, 97));
	chkDecDigits->SetText(lt.GetTranslationFor(FCT_DDIGITS));
	chkDecDigits->GetFont().SetFamily(L"Tahoma");
	chkDecDigits->GetFont().SetSize(10);
	chkDecDigits->SetParentFont(false);
	chkDecDigits->SetTabOrder(10);
	chkDecDigits->SetParent(gbDecOptions);

	spnDecDigits = new nlib::Edit();
	spnDecDigits->SetBounds(nlib::Rect(166, 77, 202, 98));
	spnDecDigits->SetText(L"0");
	spnDecDigits->GetFont().SetFamily(L"Tahoma");
	spnDecDigits->GetFont().SetSize(10);
	spnDecDigits->SetParentFont(false);
	spnDecDigits->SetTabOrder(11);
	spnDecDigits->SetParent(gbDecOptions);

	UpDownDecDigits = new nlib::UpDown();
	UpDownDecDigits->SetBounds(nlib::Rect(177, 77, 194, 98));
	UpDownDecDigits->SetMaxValue(80);
	UpDownDecDigits->SetParent(gbDecOptions);

	gbAngleUnit = new nlib::Groupbox();
	gbAngleUnit->SetBounds(nlib::Rect(236, 7, 492, 53));
	gbAngleUnit->SetText(lt.GetTranslationFor(FCT_ANGLEF));
	gbAngleUnit->SetPadding(nlib::Rect(0, 0, 0, 0));
	gbAngleUnit->GetFont().SetFamily(L"Tahoma");
	gbAngleUnit->GetFont().SetSize(10);
	gbAngleUnit->SetParentFont(false);
	gbAngleUnit->SetParent(pnlDecOpt);

	rdDeg = new nlib::Radiobox();
	rdDeg->SetTag(0);
	rdDeg->SetBounds(nlib::Rect(11, 19, 59, 35));
	rdDeg->SetText(lt.GetTranslationFor(FCT_DEG));
	rdDeg->GetFont().SetFamily(L"Tahoma");
	rdDeg->GetFont().SetSize(10);
	rdDeg->SetParentFont(false);
	rdDeg->SetTabOrder(0);
	rdDeg->SetTooltipText(lt.GetTranslationFor(FCT_TIPDEG));
	rdDeg->SetChecked(true);
	rdDeg->SetParent(gbAngleUnit);

	rdRad = new nlib::Radiobox();
	rdRad->SetTag(1);
	rdRad->SetBounds(nlib::Rect(59, 19, 114, 35));
	rdRad->SetText(lt.GetTranslationFor(FCT_RAD));
	rdRad->GetFont().SetFamily(L"Tahoma");
	rdRad->GetFont().SetSize(10);
	rdRad->SetParentFont(false);
	rdRad->SetTabOrder(1);
	rdRad->SetTooltipText(lt.GetTranslationFor(FCT_TIPRAD));
	rdRad->SetParent(gbAngleUnit);

	rdGrad = new nlib::Radiobox();
	rdGrad->SetTag(2);
	rdGrad->SetBounds(nlib::Rect(116, 19, 172, 35));
	rdGrad->SetText(lt.GetTranslationFor(FCT_GRAD));
	rdGrad->GetFont().SetFamily(L"Tahoma");
	rdGrad->GetFont().SetSize(10);
	rdGrad->SetParentFont(false);
	rdGrad->SetTabOrder(14);
	rdGrad->SetTooltipText(lt.GetTranslationFor(FCT_TIPGRAD));
	rdGrad->SetParent(gbAngleUnit);


	rdTurn = new nlib::Radiobox();
	rdTurn->SetTag(3);
	rdTurn->SetBounds(nlib::Rect(184, 19, 248, 37));
	rdTurn->SetText(lt.GetTranslationFor(FCT_TURN));
	rdTurn->SetTabOrder(15);
	rdTurn->SetTooltipText(lt.GetTranslationFor(FCT_TIPTURN));
	rdTurn->SetParent(gbAngleUnit);

	gbDisplayFormat = new nlib::Groupbox();
	gbDisplayFormat->SetBounds(nlib::Rect(236, 59, 492, 105));
	gbDisplayFormat->SetText(lt.GetTranslationFor(FCT_DISPLAS));
	gbDisplayFormat->SetPadding(nlib::Rect(0, 0, 0, 0));
	gbDisplayFormat->GetFont().SetFamily(L"Tahoma");
	gbDisplayFormat->GetFont().SetSize(10);
	gbDisplayFormat->SetParentFont(false);
	gbDisplayFormat->SetParent(pnlDecOpt);

	rdNormal = new nlib::Radiobox();
	rdNormal->SetBounds(nlib::Rect(11, 19, 91, 35));
	rdNormal->SetText(lt.GetTranslationFor(FCT_NORMAL));
	rdNormal->GetFont().SetFamily(L"Tahoma");
	rdNormal->GetFont().SetSize(10);
	rdNormal->SetParentFont(false);
	rdNormal->SetTabOrder(16);
	rdNormal->SetChecked(true);
	rdNormal->SetTooltipText(lt.GetTranslationFor(FCT_TIPDPOV));
	rdNormal->SetParent(gbDisplayFormat);

	rdHtml = new nlib::Radiobox();
	rdHtml->SetTag(1);
	rdHtml->SetBounds(nlib::Rect(77, 20, 141, 36));
	rdHtml->SetText(lt.GetTranslationFor(FCT_HTML));
	rdHtml->GetFont().SetFamily(L"Tahoma");
	rdHtml->GetFont().SetSize(10);
	rdHtml->SetParentFont(false);
	rdHtml->SetTabOrder(17);
	rdHtml->SetTooltipText(lt.GetTranslationFor(FCT_TIPDHTML));
	rdHtml->SetParent(gbDisplayFormat);

	rdTex = new nlib::Radiobox();
	rdTex->SetTag(2);
	rdTex->SetBounds(nlib::Rect(142, 20, 190, 36));
	rdTex->SetText(lt.GetTranslationFor(FCT_TEX));
	rdTex->GetFont().SetFamily(L"Tahoma");
	rdTex->GetFont().SetSize(10);
	rdTex->SetParentFont(false);
	rdTex->SetTabOrder(18);
	rdTex->SetTooltipText(lt.GetTranslationFor(FCT_TIPDTEX));
	rdTex->SetParent(gbDisplayFormat);

	rdNone = new nlib::Radiobox();
	rdNone->SetTag(3);
	rdNone->SetBounds(nlib::Rect(198, 20, 238, 36));
	rdNone->SetText(L"E");
	rdNone->SetTabOrder(19);
	rdNone->SetTooltipText(lt.GetTranslationFor(FCT_TIPDE));
	rdNone->SetParent(gbDisplayFormat);

	pnlHexOpt = new nlib::Panel();
	pnlHexOpt->SetBounds(nlib::Rect(8, 325, 515, 407));
	pnlHexOpt->SetInnerBorderStyle(nlib::pbsNone);
	pnlHexOpt->SetParent(this);

	gbHexOptions = new nlib::Groupbox();
	gbHexOptions->SetBounds(nlib::Rect(8, 1, 490, 75));
	gbHexOptions->SetText(lt.GetTranslationFor(FCT_HEXOPTS));
	gbHexOptions->SetPadding(nlib::Rect(0, 0, 0, 0));
	gbHexOptions->GetFont().SetFamily(L"Tahoma");
	gbHexOptions->GetFont().SetSize(10);
	gbHexOptions->SetParentFont(false);
	gbHexOptions->SetParent(pnlHexOpt);

	chkMinus = new nlib::Checkbox();
	chkMinus->SetBounds(nlib::Rect(8, 18, 102, 35));
	chkMinus->SetText(lt.GetTranslationFor(FCT_HEXMIN));
	chkMinus->GetFont().SetFamily(L"Tahoma");
	chkMinus->GetFont().SetSize(10);
	chkMinus->SetParentFont(false);
	chkMinus->SetTabOrder(20);
	chkMinus->SetTooltipText(lt.GetTranslationFor(FCT_TIPNEGH));
	chkMinus->SetParent(gbHexOptions);

	chkHexPrefix = new nlib::Checkbox();
	chkHexPrefix->SetBounds(nlib::Rect(8, 52, 111, 68));
	chkHexPrefix->SetText(lt.GetTranslationFor(FCT_HEXPREFIX));
	chkHexPrefix->SetTabOrder(7);
	chkHexPrefix->SetChecked(true);
	chkHexPrefix->SetParent(gbHexOptions);

	chkLittleEndian = new nlib::Checkbox();
	chkLittleEndian->SetTag(6);
	chkLittleEndian->SetBounds(nlib::Rect(360, 52, 496, 69));
	chkLittleEndian->SetText(lt.GetTranslationFor(FCT_LITTLEE));
	chkLittleEndian->GetFont().SetFamily(L"Tahoma");
	chkLittleEndian->GetFont().SetSize(10);
	chkLittleEndian->SetParentFont(false);
	chkLittleEndian->SetTabOrder(21);
	chkLittleEndian->SetTooltipText(lt.GetTranslationFor(FCT_TIPINT));
	chkLittleEndian->SetParent(gbHexOptions);

	chkBytes = new nlib::Checkbox();
	chkBytes->SetTag(1);
	chkBytes->SetBounds(nlib::Rect(116, 18, 202, 35));
	chkBytes->SetText(lt.GetTranslationFor(FCT_BYTES));
	chkBytes->GetFont().SetFamily(L"Tahoma");
	chkBytes->GetFont().SetSize(10);
	chkBytes->SetParentFont(false);
	chkBytes->SetTabOrder(22);
	chkBytes->SetParent(gbHexOptions);

	chkWords = new nlib::Checkbox();
	chkWords->SetTag(2);
	chkWords->SetBounds(nlib::Rect(116, 35, 202, 52));
	chkWords->SetText(lt.GetTranslationFor(FCT_WORDS));
	chkWords->GetFont().SetFamily(L"Tahoma");
	chkWords->GetFont().SetSize(10);
	chkWords->SetParentFont(false);
	chkWords->SetTabOrder(23);
	chkWords->SetParent(gbHexOptions);

	chkDWords = new nlib::Checkbox();
	chkDWords->SetTag(3);
	chkDWords->SetBounds(nlib::Rect(116, 52, 212, 69));
	chkDWords->SetText(lt.GetTranslationFor(FCT_DWORDS));
	chkDWords->GetFont().SetFamily(L"Tahoma");
	chkDWords->GetFont().SetSize(10);
	chkDWords->SetParentFont(false);
	chkDWords->SetTabOrder(24);
	chkDWords->SetParent(gbHexOptions);

	chkIEEESingle = new nlib::Checkbox();
	chkIEEESingle->SetTag(4);
	chkIEEESingle->SetBounds(nlib::Rect(213, 18, 331, 35));
	chkIEEESingle->SetText(lt.GetTranslationFor(FCT_SINGLE));
	chkIEEESingle->GetFont().SetFamily(L"Tahoma");
	chkIEEESingle->GetFont().SetSize(10);
	chkIEEESingle->SetParentFont(false);
	chkIEEESingle->SetTabOrder(25);
	chkIEEESingle->SetTooltipText(lt.GetTranslationFor(FCT_TIPSP));
	chkIEEESingle->SetParent(gbHexOptions);

	chkIEEEDouble = new nlib::Checkbox();
	chkIEEEDouble->SetTag(5);
	chkIEEEDouble->SetBounds(nlib::Rect(213, 35, 331, 52));
	chkIEEEDouble->SetText(lt.GetTranslationFor(FCT_DOUBLE));
	chkIEEEDouble->GetFont().SetFamily(L"Tahoma");
	chkIEEEDouble->GetFont().SetSize(10);
	chkIEEEDouble->SetParentFont(false);
	chkIEEEDouble->SetTabOrder(26);
	chkIEEEDouble->SetTooltipText(lt.GetTranslationFor(FCT_TIPDP));
	chkIEEEDouble->SetParent(gbHexOptions);

	Label1 = new nlib::Label();
	Label1->SetBounds(nlib::Rect(256, 177, 313, 193));
	Label1->SetText(lt.GetTranslationFor(FCT_STRING));
	Label1->GetFont().SetFamily(L"Tahoma");
	Label1->GetFont().SetSize(10);
	Label1->SetParentFont(false);
	Label1->SetParent(this);

	edtChars = new nlib::Edit();
	edtChars->SetBounds(nlib::Rect(317, 176, 438, 197));
	edtChars->GetFont().SetFamily(L"Calibri");
	edtChars->GetFont().SetSize(11);
	edtChars->SetParentFont(false);
	edtChars->SetTabOrder(27);
	edtChars->SetReadOnly(true);
	edtChars->SetParent(this);

	btnFont = new nlib::ToolButton();
	btnFont->SetBounds(nlib::Rect(440, 175, 508, 198));
	btnFont->SetText(lt.GetTranslationFor(FCT_FONT));
	btnFont->GetFont().SetFamily(L"Tahoma");
	btnFont->GetFont().SetSize(10);
	btnFont->SetParentFont(false);
	btnFont->SetTabOrder(28);
	btnFont->SetAcceptInput(true);
	btnFont->SetFlat(false);
	btnFont->SetParent(this);

	btnCloseDecOptions = new nlib::ToolButton();
	btnCloseDecOptions->SetBounds(nlib::Rect(14, 175, 242, 187));
	btnCloseDecOptions->SetText(L"-------------------------------------------");
	btnCloseDecOptions->GetFont().SetFamily(L"Tahoma");
	btnCloseDecOptions->GetFont().SetSize(10);
	btnCloseDecOptions->SetParentFont(false);
	btnCloseDecOptions->SetTabOrder(7);
	btnCloseDecOptions->SetParent(this);

	btnCloseHexOptions = new nlib::ToolButton();
	btnCloseHexOptions->SetBounds(nlib::Rect(14, 311, 242, 323));
	btnCloseHexOptions->SetText(L"-------------------------------------------");
	btnCloseHexOptions->GetFont().SetFamily(L"Tahoma");
	btnCloseHexOptions->GetFont().SetSize(10);
	btnCloseHexOptions->SetParentFont(false);
	btnCloseHexOptions->SetTabOrder(8);
	btnCloseHexOptions->SetParent(this);

	//SetActiveControl(btnOpenDecOptions);
	//PostMessage(Handle(), WM_NEXTDLGCTL, (WPARAM)cbInfix->Handle(), TRUE); // set focus to ComboBox after window is shown

	SetMenu(mnuMain);
	btnOpenHexOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28672)));
	btnOpenDecOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28673)));
	tbExit->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28674)));
	tbHistory->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28675)));
	tbCopy->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28676)));
	tbPaste->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28677)));
	pnlDec->SetPopupMenu(pmCopy);
	pnlHex->SetPopupMenu(pmCopy);
	pnlOct->SetPopupMenu(pmCopy);
	pnlBin->SetPopupMenu(pmCopy);
	UpDownDecDigits->SetAttachedEditor(spnDecDigits);
	btnFont->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28678)));
	btnFont->Image()->SetStateCount(2);
	btnCloseDecOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28679)));
	btnCloseHexOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28680)));

	OnStartSizeMove = CreateEvent(this, &TfrmMain::StartMove);
	OnMove = CreateEvent(this, &TfrmMain::FormMove);
	OnEndSizeMove = CreateEvent(this, &TfrmMain::FormSizeMoveEnded);
	OnClose = CreateEvent(this, &TfrmMain::FormClose);

	btnBinary->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnClearInfix->OnClick = CreateEvent(this, &TfrmMain::btnClearInfixClick);
	btnCloseDecOptions->OnClick = CreateEvent(this, &TfrmMain::btnCloseDecOptionsClick);
	btnCloseHexOptions->OnClick = CreateEvent(this, &TfrmMain::btnCloseHexOptionsClick);
	btnDecimal->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnFont->OnClick = CreateEvent(this, &TfrmMain::btnFontClick);
	btnHexadecimal->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnOctal->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnOpenDecOptions->OnClick = CreateEvent(this, &TfrmMain::btnOpenDecOptionsClick);
	btnOpenHexOptions->OnClick = CreateEvent(this, &TfrmMain::btnOpenHexOptionsClick);
	cbInfix->OnChanged = CreateEvent(this, &TfrmMain::cbInfixChanged);
	cbInfix->OnKeyDown = CreateEvent(this, &TfrmMain::cbInfixKeyDown);
	cbInfix->OnTextChanged = CreateEvent(this, &TfrmMain::cbInfixTextChanged);
	cbThousandSep->OnChanged = CreateEvent(this, &TfrmMain::cbThousandSepChanged);
	chkBytes->OnClick = CreateEvent(this, &TfrmMain::chkAsBytesClick);
	chkDecDelim->OnClick = CreateEvent(this, &TfrmMain::chkDecDelimClick);
	chkDecDigits->OnClick = CreateEvent(this, &TfrmMain::chkDecDigitsClick);
	chkDWords->OnClick = CreateEvent(this, &TfrmMain::chkAsDWordsClick);
	chkEng->OnClick = CreateEvent(this, &TfrmMain::chkSciClick);
	chkHexPrefix->OnClick = CreateEvent(this, &TfrmMain::chkHexPrefixClick);
	chkIEEEDouble->OnClick = CreateEvent(this, &TfrmMain::chkIEEEDoubleClick);
	chkIEEESingle->OnClick = CreateEvent(this, &TfrmMain::chkIEEESingleClick);
	chkLittleEndian->OnClick = CreateEvent(this, &TfrmMain::chkLittleEndianClick);
	chkMinus->OnClick = CreateEvent(this, &TfrmMain::chkMinusClick);
	chkSci->OnClick = CreateEvent(this, &TfrmMain::chkSciClick);
	chkThousandSep->OnClick = CreateEvent(this, &TfrmMain::chkSepClick);
	chkWords->OnClick = CreateEvent(this, &TfrmMain::chkAsWordsClick);
	miAbout->OnClick = CreateEvent(this, &TfrmMain::miAboutClick);
	miAppend->OnClick = CreateEvent(this, &TfrmMain::miAppendClick);
	miCharFont->OnClick = CreateEvent(this, &TfrmMain::miCharFontClick);
	miClearHist->OnClick = CreateEvent(this, &TfrmMain::miClearHistClick);
	miCopy->OnClick = CreateEvent(this, &TfrmMain::miCopyClick);
	miCopyBin->OnClick = CreateEvent(this, &TfrmMain::miCopyBinClick);
	miCopyBinary->OnClick = CreateEvent(this, &TfrmMain::miCopyBinClick);
	miCopyDec->OnClick = CreateEvent(this, &TfrmMain::miCopyDecClick);
	miCopyDecimal->OnClick = CreateEvent(this, &TfrmMain::miCopyDecClick);
	miCopyHex->OnClick = CreateEvent(this, &TfrmMain::miCopyHexClick);
	miCopyHexadecimal->OnClick = CreateEvent(this, &TfrmMain::miCopyHexClick);
	miCopyOct->OnClick = CreateEvent(this, &TfrmMain::miCopyOctClick);
	miCopyOctal->OnClick = CreateEvent(this, &TfrmMain::miCopyOctClick);
	miCopyText->OnClick = CreateEvent(this, &TfrmMain::miCopyClick);
	miEditFuncs->OnClick = CreateEvent(this, &TfrmMain::miEditFuncsClick);
	miEditVars->OnClick = CreateEvent(this, &TfrmMain::miEditVarsClick);
	miExit->OnClick = CreateEvent(this, &TfrmMain::miExitClick);
	miGenHelp->OnClick = CreateEvent(this, &TfrmMain::miGenHelpClick);
	miHistOpts->OnClick = CreateEvent(this, &TfrmMain::miHistOptsClick);
	miLocale->OnClick = CreateEvent(this, &TfrmMain::miSetLocale);
	miPaste->OnClick = CreateEvent(this, &TfrmMain::miPasteClick);
	miSetEn->OnClick = CreateEvent(this, &TfrmMain::miSetEnClick);
	miSetHun->OnClick = CreateEvent(this, &TfrmMain::miSetHunClick);
	miShowDecOpts->OnClick = CreateEvent(this, &TfrmMain::miShowDecOptsClick);
	miShowHexOpts->OnClick = CreateEvent(this, &TfrmMain::miShowHexOptsClick);
	miShowHist->OnClick = CreateEvent(this, &TfrmMain::miShowHistClick);
	miShowHist->OnClick = CreateEvent(this, &TfrmMain::miShowHistClick);
	pnlDec->OnPaint = CreateEvent(this, &TfrmMain::pnlDecPaint);
	rdDeg->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdGrad->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdHtml->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdNone->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdNormal->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdRad->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdTex->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdTurn->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	spnDecDigits->OnTextChanged = CreateEvent(this, &TfrmMain::spnDecDigitsTextChanged);
	tbCopy->OnClick = CreateEvent(this, &TfrmMain::tbCopyClick);
	tbExit->OnClick = CreateEvent(this, &TfrmMain::tbExitClick);
	tbHistory->OnClick = CreateEvent(this, &TfrmMain::tbHistoryClick);
	tbPaste->OnClick = CreateEvent(this, &TfrmMain::tbPasteClick);

//	OnKeyUp = CreateEvent(this, &TfrmMain::KeyUpOverride);
	SetKeyPreview(true);	// so the form gets the keyboard messages first

	SetActiveControl(cbInfix);
}

/*=============================================================
 * TASK   : when language cjange change all texts
 * PARAMS :
 * EXPECTS:
 * GLOBALS:
 * RETURNS:
 * REMARKS:
 *------------------------------------------------------------*/
void TfrmMain::_SetupForLanguage()
{
	trigger.SetLanguage(lt.GetLanguage());	// for error messages

	btnBinary->SetText(lt.GetTranslationFor(FCT_BIN));
	btnBinary->SetTooltipText(lt.GetTranslationFor(FCT_TIPBIN));
	btnDecimal->SetText(lt.GetTranslationFor(FCT_DEC));
	btnDecimal->SetTooltipText(lt.GetTranslationFor(FCT_TIPDEC));
	btnFont->SetText(lt.GetTranslationFor(FCT_FONT));
	btnHexadecimal->SetText(lt.GetTranslationFor(FCT_HEX));
	btnHexadecimal->SetTooltipText(lt.GetTranslationFor(FCT_TIPHEX));
	btnOctal->SetText(lt.GetTranslationFor(FCT_OCT));
	btnOctal->SetTooltipText(lt.GetTranslationFor(FCT_TIPOCT));
	btnOpenDecOptions->SetText(lt.GetTranslationFor(FCT_DECOPTSOPENER));
	btnOpenHexOptions->SetText(lt.GetTranslationFor(FCT_HEXOPTSOPENER));
	chkBytes->SetText(lt.GetTranslationFor(FCT_BYTES));
	chkDecDelim->SetText(lt.GetTranslationFor(FCT_DECSEP));
	chkDecDigits->SetText(lt.GetTranslationFor(FCT_DDIGITS));
	chkDWords->SetText(lt.GetTranslationFor(FCT_DWORDS));
	chkEng->SetText(lt.GetTranslationFor(FCT_ENG));
	chkHexPrefix->SetText(lt.GetTranslationFor(FCT_HEXPREFIX));
	chkIEEEDouble->SetText(lt.GetTranslationFor(FCT_DOUBLE));
	chkIEEEDouble->SetTooltipText(lt.GetTranslationFor(FCT_TIPDP));
	chkIEEESingle->SetText(lt.GetTranslationFor(FCT_SINGLE));
	chkIEEESingle->SetTooltipText(lt.GetTranslationFor(FCT_TIPSP));
	chkLittleEndian->SetText(lt.GetTranslationFor(FCT_LITTLEE));
	chkLittleEndian->SetTooltipText(lt.GetTranslationFor(FCT_TIPINT));
	chkMinus->SetText(lt.GetTranslationFor(FCT_HEXMIN));
	chkMinus->SetTooltipText(lt.GetTranslationFor(FCT_TIPNEGH));
	chkSci->SetText(lt.GetTranslationFor(FCT_SCI));
	chkThousandSep->SetText(lt.GetTranslationFor(FCT_THOUSAND));
	chkWords->SetText(lt.GetTranslationFor(FCT_WORDS));
	gbAngleUnit->SetText(lt.GetTranslationFor(FCT_ANGLEF));
	gbDecOptions->SetText(lt.GetTranslationFor(FCT_DECOPTS));
	gbDisplayFormat->SetText(lt.GetTranslationFor(FCT_DISPLAS));
	gbHexOptions->SetText(lt.GetTranslationFor(FCT_HEXOPTS));
	gbResults->SetText(lt.GetTranslationFor(FCT_DEC));
	Label1->SetText(lt.GetTranslationFor(FCT_STRING));
	miAbout->SetText(lt.GetTranslationFor(FCT_ABOUT));
	miAppend->SetText(lt.GetTranslationFor(FCT_APPEND));
	miCharFont->SetText(lt.GetTranslationFor(FCT_CHARFONT));
	miClearHist->SetText(lt.GetTranslationFor(FCT_CLEARHIST));
	miCopy->SetText(lt.GetTranslationFor(FCT_COPYEXPR));
	miCopyBin->SetText(lt.GetTranslationFor(FCT_COPYBIN));
	miCopyBinary->SetText(lt.GetTranslationFor(FCT_COPYBIN));
	miCopyDec->SetText(lt.GetTranslationFor(FCT_COPYDEC));
	miCopyDecimal->SetText(lt.GetTranslationFor(FCT_COPYDEC));
	miCopyHex->SetText(lt.GetTranslationFor(FCT_COPYHEX));
	miCopyHexadecimal->SetText(lt.GetTranslationFor(FCT_COPYHEX));
	miCopyOct->SetText(lt.GetTranslationFor(FCT_COPYOCT));
	miCopyOctal->SetText(lt.GetTranslationFor(FCT_COPYOCT));
	miCopyText->SetText(lt.GetTranslationFor(FCT_COPYTEXT));
	miData->SetText(lt.GetTranslationFor(FCT_DATA));
	miEdit->SetText(lt.GetTranslationFor(FCT_EDIT));
	miEditFuncs->SetText(lt.GetTranslationFor(FCT_EDITFUNCS));
	miEditVars->SetText(lt.GetTranslationFor(FCT_EDITVARS));
	miExit->SetText(lt.GetTranslationFor(FCT_EXIT));
	miFile->SetText(lt.GetTranslationFor(FCT_FILE));
	miGenHelp->SetText(lt.GetTranslationFor(FCT_GENHELP));
	miHelp->SetText(lt.GetTranslationFor(FCT_HELP));
	miHistOpts->SetText(lt.GetTranslationFor(FCT_HISTOPTS));
	miLanguage->SetText(lt.GetTranslationFor(FCT_LANGUAGE));
	miLocale->SetText(lt.GetTranslationFor(FCT_LOCALE));
	miPaste->SetText(lt.GetTranslationFor(FCT_PASTEEXPR));
	miSetEn->SetChecked(lt.GetLanguage() == AppLanguage::lanEng);
	miSetEn->SetText(lt.GetTranslationFor(FCT_SETEN));
	miSetHun->SetChecked(lt.GetLanguage() == AppLanguage::lanHun);
	miSetHun->SetText(lt.GetTranslationFor(FCT_SETHUN));
	miShowDecOpts->SetText(lt.GetTranslationFor(FCT_SHOWDECOPTS));
	miShowHexOpts->SetText(lt.GetTranslationFor(FCT_SHOWHEXOPTS));
	miShowHist->SetText(lt.GetTranslationFor(FCT_SHOWHIST));
	miView->SetText(lt.GetTranslationFor(FCT_VIEW));
	mnuEditCopy->SetText(lt.GetTranslationFor(FCT_EDITCOPY));
	mnuOptions->SetText(lt.GetTranslationFor(FCT_OPTIONS));
	rdDeg->SetText(lt.GetTranslationFor(FCT_DEG));
	rdDeg->SetTooltipText(lt.GetTranslationFor(FCT_TIPDEG));
	rdGrad->SetText(lt.GetTranslationFor(FCT_GRAD));
	rdGrad->SetTooltipText(lt.GetTranslationFor(FCT_TIPGRAD));
	rdHtml->SetText(lt.GetTranslationFor(FCT_HTML));
	rdHtml->SetTooltipText(lt.GetTranslationFor(FCT_TIPDHTML));
	rdNone->SetTooltipText(lt.GetTranslationFor(FCT_TIPDE));
	rdNormal->SetText(lt.GetTranslationFor(FCT_NORMAL));
	rdNormal->SetTooltipText(lt.GetTranslationFor(FCT_TIPDPOV));
	rdRad->SetText(lt.GetTranslationFor(FCT_RAD));
	rdRad->SetTooltipText(lt.GetTranslationFor(FCT_TIPRAD));
	rdTex->SetText(lt.GetTranslationFor(FCT_TEX));
	rdTex->SetTooltipText(lt.GetTranslationFor(FCT_TIPDTEX));
	rdTurn->SetText(lt.GetTranslationFor(FCT_TURN));
	rdTurn->SetTooltipText(lt.GetTranslationFor(FCT_TIPTURN));
}

bool TfrmMain::_SaveState(SmartString name)
{
	std::ofstream fs(name.toUtf8String(), ios_base::out);

     if(fs.fail())
        return false;
    fs << STATE_ID_STRING << VERSION_STRING << "\n";
	fs << LANGUAGE << (lt.GetLanguage() == AppLanguage::lanHun ? "hu" : "en") << "\n";
	fs << MAINFORMAT<< (int)lengine->displayFormat.mainFormat << "\n";

	//int u = UpDown1->Position() + (chkDecDigits->Checked() ? 0x100 : 0); // 0x100: checked state. must use Position as num_digits may be -1
	std::string wsep = (chkThousandSep->Checked() ? "1" : "0") + (std::to_string(cbThousandSep->ItemIndex()));
	fs << DECFORMAT<< lengine->displayFormat.decDigits << "|" << (int)lengine->displayFormat.expFormat
	   << "|" << wsep <<  "|" << (int)lengine->displayFormat.useFractionSeparator
	   << "|" << (int)lengine->AngleUnit() << "\n";

    fs << HEXFORMAT<< (int)lengine->displayFormat.hexFormat << "|"<< (int)lengine->displayFormat.littleEndian << "|"<<
			(int)lengine->displayFormat.bSignedBinOrHex << "|" << (int)lengine->displayFormat.trippleE <<"|" << (int)lengine->displayFormat.useNumberPrefix << "\n";

	fs << FONTNAME	<< SmartString(edtChars->GetFont().Family()) << "\n";
	fs << FONTDATA	<< (int)edtChars->GetFont().Size() << "|"<< (int)edtChars->GetFont().CharacterSet() << "|"<< (COLORREF)edtChars->GetFont().GetColor() << "\n";
	int angleOption = rdDeg->Checked() ? 0 : rdRad->Checked() ? 1 : rdGrad->Checked() ? 2 : 3;
	int showOption = rdNormal->Checked() ? 0 : rdHtml->Checked() ? 1 : rdTex->Checked() ? 2 : 3;
    fs << OPTIONS	<< pnlDecOpt->Visible() << "|"<< pnlHexOpt->Visible()<<"|"<<angleOption<<"|"<<showOption <<"\n";
    fs << HISTOPTIONS << _watchLimit << "|"<< _maxHistDepth << "|"<< slHistory.IsSorted() << "|" << _minCharLength << "\n";
	fs << VARCOLS; 
	for (int i = 0; i < 2; ++i)
		for (int col = 0; col < 4; ++col)
		{
			fs << TfrmVariables::_colW[i][col];
			if(i != 1 || col != 3)
				fs << "|";
		}
	fs << "\n";
    if(!cbInfix->Text().empty())
        fs << LAST <<  SmartString(cbInfix->Text()) << "\n";
    return true;
}


bool TfrmMain::_LoadState(SmartString name)
{
	std::ifstream fs(name.toUtf8String(), ios_base::in);
    if(fs.fail())
        return false;
	DisplayFormat dspFormat;
//	wstring s;
	char wbuf[1024];// , nam[1024];
	fs.getline(wbuf,1023);

    if(strncmp(wbuf, STATE_ID_STRING, strlen(STATE_ID_STRING)) )
        return false;
	// TODO: check version string

    int n, val =0;

	//lt.SetLanguage(Language::none); // default

	SmartStringVector data;
	auto language = [&]()
	{
		if (n == 2 && data[0] == LANGUAGE)	// only one field
		{
			AppLanguage lang = data[1] == SmartString("hu") ? AppLanguage::lanHun : AppLanguage::lanEng;
			lt.SetLanguage(lang);
			switch(lang)
			{
				default:
				case AppLanguage::lanEng: 
					miSetEn->SetChecked(false); // no need to uncheck 'Hungarian'
					break;
				case AppLanguage::lanHun:	
					miSetEn->SetChecked(false);
					miSetHun->SetChecked(true);
					break;
			}
			_SetupForLanguage();
			
			return true;
		}
		return false;
		};
	auto mainFormat = [&]()	-> bool // returns true if not processed, false if processed
	{
		if (n==2 && data[0] == MAINFORMAT)	// only one field
		{
			val = std::stoi(data[1].toUtf8String());
			lengine->displayFormat.mainFormat = static_cast<NumberFormat>(val);
			++_busy;
			switch (lengine->displayFormat.mainFormat)
			{
				case NumberFormat::rnfSci:
					chkSci->SetChecked(true);
					break;
				case NumberFormat::rnfEng:
					chkEng->SetChecked(true);
					break;
			}
			--_busy;
			return true;
		}
		return false;
	};
	auto decFormat = [&]()
	{
		if (n == 6 && data[0] == DECFORMAT)		// 6 fields
		{
			++_busy;
					// 1: decimal digits
			val = std::stoi(data[1].toUtf8String());	// # of decimal digits n > 0 => used digits, n < 0 => used = abs(n+1)
			lengine->displayFormat.decDigits = val;
			if (val >= 0)
				chkDecDigits->SetChecked(true);
			else
				val = std::abs(val + 1);
			UpDownDecDigits->SetPosition(val);
					// 2: exponent display format
			val = std::stoi(data[2].toUtf8String());	// (0)E: 1E5, (1)HTML: 1<sp>12</sup>, (2)TeX: 1^{12}, (3)normal: 1²³
			lengine->displayFormat.expFormat = static_cast<ExpFormat>(val);
			if(lengine->displayFormat.expFormat == ExpFormat::rnsfE)
				rdNone->SetChecked(true);
			else if(lengine->displayFormat.expFormat == ExpFormat::rnsfSciHTML)
				rdHtml->SetChecked(true);
			else if (lengine->displayFormat.expFormat == ExpFormat::rnsfSciTeX)
				rdTex->SetChecked(true);
			else if (lengine->displayFormat.expFormat == ExpFormat::rnsfGraph)
			{
				rdNormal->SetChecked(true);
			}
					// 3: thousand separator string
			if (!data[3].empty())	// can only be '.', ',' and space
			{
				if (data[3][0] == L'1')
					chkThousandSep->SetChecked(true);
				else if (data[3][1] == u'0')
					cbThousandSep->SetItemIndex(0);
				else if (data[3][1] == u'1')
					cbThousandSep->SetItemIndex(1);
				else if (data[3][1] == u'2')
					cbThousandSep->SetItemIndex(2);
				if (chkThousandSep->Checked())
					lengine->displayFormat.strThousandSeparator = SmartString(cbThousandSep->ItemIndex() > 0 ? cbThousandSep->Text()[0] : ' ');
			}
					// 4: fraction separator
			if (!data[4].empty() && data[4] == SmartString("1"))
				chkDecDelim->SetState(nlib::csChecked);
					// 5: angular unit 0:
			if (!data[5].empty())
				lengine->displayFormat.angUnit = static_cast<AngularUnit>(std::stoi(data[5].toUtf8String()));

			--_busy;

			return true;
		}
		return false;

	};
	auto hexFormat = [&]()
	{
		if (n == 6 && data[0] == HEXFORMAT)	// 5 fields
		{
			++_busy;
				// 1. main Hex format
			int val = std::stoi(data[1].toUtf8String());
			lengine->displayFormat.hexFormat = static_cast<HexFormat>(val);
			switch (lengine->displayFormat.hexFormat)
			{
				case HexFormat::rnHexNormal:
					break;
				case HexFormat::rnHexByte:
					chkBytes->SetChecked(true);
					break;
				case HexFormat::rnHexWord:
					chkWords->SetChecked(true);
					break;
				case HexFormat::rnHexDWord:
					chkDWords->SetChecked(true);
					break;
			}
				// 2. endianness
			val = std::stoi(data[2].toUtf8String());
			if (val)
				chkLittleEndian->SetChecked(true);
				// 3. signed bin or hex?
			val = std::stoi(data[3].toUtf8String());
			if (val)
				chkMinus->SetChecked(true);
				// 4. IEEE format
			val = std::stoi(data[4].toUtf8String());
			// val = 0: no check
			if (val==1)
				chkIEEESingle->SetChecked(true);
			else if(val==2)
				chkIEEEDouble->SetChecked(true);
			--_busy;
				// 5. number prefix is used on hex. numbers
			val = std::stoi(data[5].toUtf8String());
			lengine->displayFormat.useNumberPrefix = val;
			chkHexPrefix->SetChecked(val);
			return true;
		}
		return false;

	};
	auto fontName = [&]()
	{
		if (n==2 && data[0] == FONTNAME)  // 2 fields
		{
			Font f = edtChars->GetFont();
			f.SetFamily(data[1].ToWideString());
			edtChars->SetFont(f);
			return true;
		}
		return false;

	};
	auto fontData = [&]()
	{
		if (n == 4 && data[0] == FONTDATA)	// 3 fields
		{
			Font f = edtChars->GetFont();
			f.SetSize(std::stof(data[1].toUtf8String()));
			f.SetCharacterSet(static_cast<FontCharacterSets>(std::stoi(data[2].toUtf8String())));
			n = data[3][0] == L'#' ? 1 : 0;
			f.SetColor(std::stoul(data[3].mid(n).toUtf8String()));
			return true;
		}
		return false;

	};
	auto options = [&]()					  // 3 fields
	{
		if (n == 5 && data[0] == OPTIONS)
		{
			ShowDecOptions(std::stoi(data[1].toUtf8String())!=0);
			ShowHexOptions(std::stoi(data[2].toUtf8String())!=0);
			rdDeg->SetChecked(false);			// default: true
			switch (data[3].at(0).Unicode())
			{
				case '0':	rdDeg->SetChecked(true);   break;
				case '1':	rdRad->SetChecked(true);   break;
				case '2':	rdDeg->SetChecked(true);   break;
				case '3':	rdTurn->SetChecked(true);  break;
				default:  break;
			}
			rdNormal->SetChecked(false);	// default
			switch (data[4].at(0).Unicode())
			{
				case '0':	rdNormal->SetChecked(true); break;
				case '1':	rdHtml->SetChecked(true);  break;
				case '2':	rdTex->SetChecked(true);   break;
				case '3':	rdNone->SetChecked(true);  break;
				default:  break;
			}
			return true;
		}
		return false;

	};
	auto histOptions = [&]()
	{
		if (n == 5 && data[0] == HISTOPTIONS)	// 5 fields
		{								
			_watchLimit			= std::stoi(data[1].toUtf8String());
			_maxHistDepth		= std::stoi(data[2].toUtf8String());
			slHistory.SetSorted(  std::stoi(data[3].toUtf8String()));
			_minCharLength		= std::stoi(data[4].toUtf8String());
			return true;
		}
		return false;

	};
	auto varCols = [&]()
		{
			if (n == 9 && data[0] == VARCOLS)
			{
				for (int i = 0; i < 2; ++i)
					for (int col = 0; col < 4; ++col)
						TfrmVariables::_colW[i][col] = std::stoi(data[col + 4 * i+1].toUtf8String());
				return true;
			}
			return false;
		};
	auto last = [&](SmartString &lastinfix)		
	{
		if (n==2 && data[0] == LAST)
		{
			cbInfix->SetText((lastinfix = data[1]).ToWideString());
			cbInfixTextChanged(nullptr, nlib::EventParameters());
		}
	};

	SmartString wsLlastInfix;

	while ((n = __ReadAndSplitLine(fs, data)))
	{
		if (data[0][data[0].length() - 1] == SCharT('='))	// valid line
		{
			if (!language())
				if(!mainFormat() )
					if(!decFormat())
						if(!hexFormat())
							if(!fontName())
								if(!fontData())
									if(!options())
										if(!histOptions())
											if(!varCols())
												last(wsLlastInfix);
		}
	}

	_EnableMyTimer(_watchLimit > 0);
    --_busy;
    return true;
}

// for fun
std::vector<MONITORINFOEX> monitors;
// callback function called by EnumDisplayMonitors for each enabled monitor
BOOL CALLBACK EnumDispProc(HMONITOR hMon, HDC dcMon, RECT* pRcMon, LPARAM lParam)
{
	MONITORINFOEX mi;
	mi.cbSize = sizeof(MONITORINFOEX);
	if( GetMonitorInfo(hMon, &mi) )
		monitors.push_back(mi);

	return TRUE;	// continue enum
}
// /for fun
TfrmMain::TfrmMain()
{
	InitializeFormAndControls();
	wiMain.InitInfo(this, L"frmMain");
	_GetVirtualDisplaySize();
	// /for fun
	_bAutoSave = false;

	RealNumber::SetMaxLength(65);	// but only display 59

	lengine = new FalconCalc::LittleEngine;			// this remain valid when the program is running
	lengine->displayFormat.useNumberPrefix = true;
	lengine->displayFormat.strThousandSeparator = " "_ss;
	lengine->displayFormat.displWidth = MAX_OUTPUT_WIDTH;

	lengine->ssNameOfDatFile = (UserDir() + SmartString(FalconCalc_Dat_File));
	try
	{
		lengine->LoadUserData();	// may throw because of many errors
	}
	catch (...)
	{
		;
	}
	// add the clipboard and set this window as a "viewer"
	MyClipboard = new Clipboard();	   // messages arrive after
	MyClipboard->Activate( Handle() ); // Handle() is called first

	_chkArr[0] = chkMinus;
    _chkArr[1] = chkBytes;
    _chkArr[2] = chkWords;
    _chkArr[3] = chkDWords;
    _chkArr[4] = chkIEEESingle;
    _chkArr[5] = chkIEEEDouble;
    _chkArr[6] = chkLittleEndian;

    _nDecOptTop = pnlDecOpt->Top();
    _nHexBtnTop = btnOpenHexOptions->Top();

    _watchdog = 0;
    _watchLimit = 5; // seconds
	_maxHistDepth=0; // unlimited

    if(!_LoadState(UserDir() + SmartString(FalconCalc_State_File)) )
    {
        ShowDecOptions(false);
        ShowHexOptions(false);
    }
    slHistory.LoadFromFile(UserDir() + SmartString(FalconCalc_Hist_File));
		// add max 20 items from slHistory to combo box
	for (size_t i = 0; i < slHistory.size() && i < 20; i++)
		if (cbInfix->Text() != slHistory[i].ToWideString())
			cbInfix->AddItem(slHistory[i].ToWideString(), nullptr);
    _added = false;

}
LRESULT TfrmMain::WindowProc(UINT msg, WPARAM w,LPARAM l)
{
	switch(msg)
	{
		case  WM_TIMER:
			if (_bAutoSave && ++_watchdog >= _watchLimit && lengine->ResultOk() && !_added && !cbInfix->Text().empty())
				_AddToHistory(cbInfix->Text());
				break;
		case WM_CHANGECBCHAIN:
				// If the next clipboard viwer window is closing, repair the chain.
				// Otherwise, pass the message to the next link.
				MyClipboard->ChangeNextViewer((HWND) w, (HWND) l);
				break;
		case WM_DRAWCLIPBOARD:
				// if the content of the clipboard has been changed
				// enable or disable paste menu and button
			   {
					bool enable = IsClipboardFormatAvailable(CF_UNICODETEXT) || IsClipboardFormatAvailable(CF_TEXT);
					miPaste->SetEnabled(enable);
					tbPaste->SetEnabled(enable);
			   }
				// and pass the message on
				MyClipboard->Forward( msg, w, l);
				break;
		//case WM_SHOWWINDOW:
		//		SetActiveControl(btnOpenDecOptions);
				//PostMessage(Handle(), WM_NEXTDLGCTL, (WPARAM)cbInfix->Handle(), TRUE); // set focus to ComboBox after window is shown
			//SetActiveControl(cbInfix);
				break;
		default: return Form::WindowProc(msg,w,l);
	}
	return 0;
}
TfrmMain::~TfrmMain()
{
	/* Don't 'delete' the form. Call Destroy() instead which has access to the protected destructor. */
	delete 	MyClipboard;
}

void TfrmMain::Destroy()
{
	lengine->SaveUserData();
    _SaveState(UserDir() + SmartString(FalconCalc_State_File));
	slHistory.SaveToFile(UserDir() + SmartString( FalconCalc_Hist_File) );
	delete lengine;
	Form::Destroy();
}

void TfrmMain::btnFontClick(void *sender, nlib::EventParameters param)
{
	FontDialog1->SetFont( edtChars->GetFont());
	if(FontDialog1->Show(this))
	{
		edtChars->SetFont(FontDialog1->GetFont());
	}
}

void TfrmMain::btnClearInfixClick(void* sender, nlib::EventParameters param)
{
	cbInfix->SetText(L"");
	lengine->infix = L"";
	_ShowResults();
}

void TfrmMain::pnlDecPaint(void *sender, nlib::PaintParameters param)
{
	sa::GraphicText gtDec;
	Canvas *pCanvas = pnlDec->GetCanvas();
	pCanvas->FillRect(1,1,pnlDec->Width()-4, pnlDec->Height()-1);
	if(pnlDec->Text().empty() )
		return;

	gtDec.SetCanvas(  pCanvas );
	gtDec.SetText(pnlDec->Text(), 0, lengine->displayFormat.expFormat != ExpFormat::rnsfGraph);
	int y = (pnlDec->Height() - gtDec.Box().Height())/2 - gtDec.Box().TopLeft().y;
	if(y < 0)
		y = 0;
	gtDec.Draw(pnlDec->Width() - gtDec.Box().Width()-4, y);
}

void TfrmMain::_GetVirtualDisplaySize()
{
	//----- SA -------------------
	// for fun
	EnumDisplayMonitors(0, 0, EnumDispProc, 0); 	// get all monitors
	// get virtual window size
	RECT r = { 0 };
	//	r.left = r.right=r.top=r.bottom = 0'
	for (size_t i = 0; i < monitors.size(); ++i)
	{
		if (monitors[i].rcMonitor.left < r.left)
			r.left = monitors[i].rcMonitor.left;
		if (monitors[i].rcMonitor.top < r.top)
			r.top = monitors[i].rcMonitor.top;
		if (monitors[i].rcMonitor.bottom > r.bottom)
			r.bottom = monitors[i].rcMonitor.bottom;
		if (monitors[i].rcMonitor.right > r.right)
			r.right = monitors[i].rcMonitor.right;
	}
	if (Left() > r.right || Top() > r.bottom || Bottom() < r.top || Right() < r.left)
	{
		SetLeft(((r.right - r.left) - Width()) / 2);
		SetTop(((r.bottom - r.top) - Height()) / 2);
	}
}

void TfrmMain::_ShowResults()	// from lengine
{
    if(lengine->infix.empty())
    {
		_ShowMessageOnAllPanels(L"");
        return;
    }
    if(lengine->resultType== LittleEngine::ResultType::rtDefinition) // function definition?
    {
        _ShowMessageOnAllPanels(L"Definition");
        return;
    }
    else if(lengine->resultType == LittleEngine::ResultType::rtInvalid)
    {
		_ShowMessageOnAllPanels(L"???");
        return;
    }
	// DEBUG
	// SmartString s = lengine->ResultAsDecString();
	// /DEBUG
	pnlDec->SetText(lengine->ResultAsDecString().ToWideString());
	pnlDec->Invalidate();
    pnlHex->SetText(lengine->ResultAsHexString().ToWideString());
    pnlOct->SetText(lengine->ResultAsOctString().ToWideString());
    pnlBin->SetText(lengine->ResultAsBinString().ToWideString());
    edtChars->SetText(lengine->ResultAsCharString().ToWideString());

	SetFocus(cbInfix->Handle());
}

// display same message in all panels
void TfrmMain::_ShowMessageOnAllPanels(wstring s)
{
    pnlDec->SetText(s);
	pnlDec->Invalidate();

    pnlHex->SetText(s);
    pnlOct->SetText(s);
    pnlBin->SetText(s);
    edtChars->SetText(L"");
}

// Hack SA: to get selected index and text from combobox
class CBIndexChangedParams // just single selection SA
{
	int _selIndex = -1;
	int _stringLength = 0;
	wchar_t* _buffer = nullptr;
public:


	CBIndexChangedParams()
	{
		HWND handle = frmMain->cbInfix->Handle();
		_selIndex = SendMessage(handle, CB_GETCURSEL, 0, 0);
		if(_selIndex < 0 || _selIndex >= frmMain->cbInfix->Count() )
			return;
		// get text
		_stringLength = (int)SendMessage(handle, CB_GETLBTEXTLEN, (WPARAM)_selIndex, 0);
		_buffer = new wchar_t[_stringLength + 1];
		SendMessage(handle, CB_GETLBTEXT, (WPARAM)_selIndex, (LPARAM)_buffer);
	}
	~CBIndexChangedParams() 
	{ 
		delete _buffer; 
	}

	constexpr int Index() const { return _selIndex; }
	std::wstring Text() const 
	{ 
		return std::wstring(_buffer); 
	}
};

void TfrmMain::_CBInfixChanged(void *pParams)
{
	if (_busy)
		return;
	++_busy;
	CBIndexChangedParams* params = (CBIndexChangedParams*)pParams;
    try
    {		  
		std::wstring s;
		if(params)
			s = params->Text();
		else
			s = cbInfix->Text();

		if(s.empty() )
		{
			_ShowMessageOnAllPanels(L"");
			--_busy;
			return;
		}

		int n = cbInfix->SelStart();
		lengine->infix = s;
        RealNumber res = lengine->Calculate();
        gbResults->SetText(lt.GetTranslationFor(FCT_RESULT));
        _ShowResults();

		cbInfix->SetSelLength(0);
		cbInfix->SetSelStart(n);

        s = lengine->Postfix().ToWideString();
    }
    catch(wstring s)
    {
        gbResults->SetText(s);
        _ShowMessageOnAllPanels(L"???");
    }
    catch(EngineErrorCodes tt)
    {
        gbResults->SetText(lt.GetTranslationFor(tt));
        _ShowMessageOnAllPanels(L"???");
    }
    catch(...)
    {
        _ShowMessageOnAllPanels(L"???");
    }
	--_busy;
}
					  // called when current index changed for combo box
void TfrmMain::cbInfixChanged(void* sender, nlib::EventParameters param)
{
	CBIndexChangedParams params;
	_CBInfixChanged(&params);
}
					  // called when typing changed the text in the combobox's edit box
void TfrmMain::cbInfixTextChanged(void *sender, nlib::EventParameters param)
{
	_CBInfixChanged();
}

void TfrmMain::cbInfixKeyDown(void* sender, nlib::KeyParameters param)
{
	_watchdog = 0;   // reset counter

	if (cbInfix->Text().empty())
		return;
	lengine->resultType = LittleEngine::ResultType::rtUndef;

	if (param.keycode == VK_RETURN)
		_AddToHistory(cbInfix->Text());
	else if (param.keycode == VK_ESCAPE)
	{
		btnClearInfixClick(nullptr, nlib::EventParameters());
	}
	else if (param.keycode != VK_RIGHT && param.keycode != VK_LEFT && param.keycode != VK_UP && param.keycode != VK_DOWN &&
		param.keycode != VK_TAB)
	{
		//if(param.keycode != 17 || !param.vkeys.contains(vksCtrl))  // 17 - Ctrl-H
		_added = false;
	}
}

void TfrmMain::rdDegClick(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.angUnit = (LongNumber::AngularUnit)((Radiobox*)sender)->Tag();
	cbInfixTextChanged(sender,param);
	SetFocus(cbInfix->Handle());
}

void TfrmMain::spnDecDigitsTextChanged(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.decDigits = UpDownDecDigits->Position();
	if (chkDecDigits->Checked())
		_ShowResults();
	else
		lengine->displayFormat.decDigits = - (lengine->displayFormat.decDigits+1);	// changed, but not shown
	//else
	//	SetFocus(cbInfix->Handle());
}

void TfrmMain::tbCopyClick(void *sender, nlib::EventParameters param)
{
    miCopyClick(sender,param);
}

void TfrmMain::tbExitClick(void *sender, nlib::EventParameters param)
{
	Close();
}

void TfrmMain::tbHistoryClick(void *sender, nlib::EventParameters param)
{
	miShowHistClick(miShowHist,param);
}

void TfrmMain::tbPasteClick(void *sender, nlib::EventParameters param)
{
	miPasteClick(sender,param);
}

void TfrmMain::chkDecDigitsClick(void *sender, nlib::EventParameters param)
{

	lengine->displayFormat.decDigits = chkDecDigits->Checked() ? UpDownDecDigits->Position() : -1;
    _ShowResults();
}

void TfrmMain::chkDecDelimClick(void* sender, nlib::EventParameters param)
{
	lengine->displayFormat.useFractionSeparator = chkDecDelim->Checked();
	_ShowResults();
}

void TfrmMain::chkMinusClick(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.bSignedBinOrHex = chkMinus->Checked();
	_ShowResults();
}

void TfrmMain::chkHexPrefixClick(void* sender, nlib::EventParameters param)
{
	lengine->displayFormat.useNumberPrefix = chkHexPrefix->Checked();
	_ShowResults();
}

void TfrmMain::chkSciClick(void *sender, nlib::EventParameters param)
{
  if(_busy)
    return;
  ++_busy;
  Checkbox *ps = ((Checkbox*)sender),
            *pd = (ps == chkSci ? chkEng : chkSci);
  lengine->displayFormat.mainFormat = ps->Checked() ? ( (ps == chkSci) ? NumberFormat::rnfSci : NumberFormat::rnfEng) : NumberFormat::rnfGeneral;
  pd->SetChecked(false);
    _ShowResults();
  --_busy;
}

void TfrmMain::chkSepClick(void *sender, nlib::EventParameters param)
{
    bool b = chkThousandSep->Checked();
    cbThousandSep->SetEnabled(b);
	if (b && cbThousandSep->ItemIndex() >= 0)
	{
		lengine->displayFormat.strThousandSeparator = SmartString(cbThousandSep->ItemIndex() > 0 ? cbThousandSep->Text()[0] : ' ');
	}
	else
		lengine->displayFormat.strThousandSeparator.clear();
    _ShowResults();
}

void TfrmMain::miExitClick(void *sender, nlib::EventParameters param)
{
	Close();
}

void TfrmMain::miCopyClick(void *sender, nlib::EventParameters param)
{
    if(cbInfix->SelLength())
        MyClipboard->SetText(cbInfix->SelText());
    else
        MyClipboard->SetText( cbInfix->Text());
}

void TfrmMain::miPasteClick(void *sender, nlib::EventParameters param)
{
    cbInfix->SetText(cbInfix->Text().substr(0, cbInfix->SelStart()) +
			MyClipboard->GetText() + cbInfix->Text().substr(cbInfix->SelStart(),999));
}

void TfrmMain::miAppendClick(void *sender, nlib::EventParameters param)
{
    cbInfix->SetText( cbInfix->Text() + MyClipboard->GetText());
}

void TfrmMain::miEditVarsClick(void *sender, nlib::EventParameters param)
{
	MenuItem* pVarMenu = (MenuItem*)sender;
	int tag = pVarMenu->Tag();		// 0 variables,  1: functions
	if (frmVariables)
	{
		if (tag != frmVariables->tcVars->SelectedTab())		// switch TAB
		{
			frmVariables->tcVars->SetSelectedTab(tag);
			bool bvar = tag ? false : true,
				bfunc = tag ? true : false;
			miEditVars->SetChecked(bvar);
			miEditFuncs->SetChecked(bfunc);
		}
		else
		{
			frmVariables->Close();
			frmVariables = nullptr;
			wiVars.RefreshInfo();
			miEditVars->SetChecked (false);
			miEditFuncs->SetChecked(false);
		}
	}
	else
	{
		OpenVarsOrFunctions(sender, tag, param);
		pVarMenu->SetChecked(true);
	}
	SetFocus(cbInfix->Handle());
}

void TfrmMain::miEditFuncsClick(void *sender, nlib::EventParameters param)
{
	miEditVarsClick(sender, param);
}

// TASK: to show history window below, stacked above or beside main window
// EPECTS:
// RETURNS: nothing
// REMARKS: sets position and size of history window
void TfrmMain::miShowHistClick(void *sender, nlib::EventParameters param)
{
	if(frmHistory)		// already set
	{
		frmHistory->Close();
		((MenuItem*)sender)->SetChecked(false);
		frmHistory = nullptr;
		wiHist.InitInfo(frmHistory, L"frmHistory");
	}
	else
	{
		frmHistory = new TfrmHistory;
		frmHistory->SetTopLevelParent(this);
		frmHistory->SetLeft(Left());
		frmHistory->SetTop(Bottom() + 1);
		frmHistory->chkSorted->SetChecked(slHistory.IsSorted());
		wiHist.InitInfo(frmHistory, L"frmHistory");
		frmHistory->Show();
		frmHistory->GetSnapSide();
		frmHistory->Snap();

		frmHistory->lstHistory->Items().SetLines(slHistory.ToWstringVector());
		((MenuItem*)sender)->SetChecked(true);
	}
	SetFocus(cbInfix->Handle());
}

void TfrmMain::miClearHistClick(void *sender, nlib::EventParameters param)
{
    slHistory.clear();
	if(frmHistory)
		frmHistory->lstHistory->Clear();
}

void TfrmMain::miShowDecOptsClick(void *sender, nlib::EventParameters param)
{
	ShowDecOptions(!pnlDecOpt->Visible());
}

void TfrmMain::miShowHexOptsClick(void *sender, nlib::EventParameters param)
{
	ShowHexOptions(!pnlHexOpt->Visible());
}

void TfrmMain::miHistOptsClick(void *sender, nlib::EventParameters param)
{
	frmHistOptions = new TfrmHistOptions;
	frmHistOptions->SetTopLevelParent(this);
    frmHistOptions->Setup(_maxHistDepth, _watchLimit, slHistory.IsSorted() , _minCharLength);

	if(frmHistOptions->ShowModal() == mrOk)
    {
		if(frmHistOptions->ClearHistory())
			slHistory.clear();
        if(frmHistOptions->chkDepth->Checked())
        {
            _maxHistDepth = frmHistOptions->spinDepthBtn->Position();
			slHistory.reserve(_maxHistDepth);
			if(frmHistory)
				frmHistory->lstHistory->Items().SetLines(slHistory.ToWstringVector());
        }
		_minCharLength = stoi(frmHistOptions->edtMinLength->Text());
        if(frmHistOptions->chkAutoSave->Checked())
        {
			wstring str = frmHistOptions->edtInterval->Text();
			int h = 0, m = 0, s = 0;
			int n = swscanf(str.c_str(), L"%d:%d:%d", &h, &m, &s);
			if(n != 3)
			{
				s = m;
				m = h;
				h = 0;
				if(n != 2)
				{
					s = m;
					m = 0;;
				}
			}
            _watchLimit = h*3600 + m*60 + s;
        }
        else
        {
            _watchLimit = 0;
        }
        // Timer1->Enabled = _watchLimit > 0;
		_EnableMyTimer(_watchLimit > 0);
        slHistory.SetSorted(frmHistOptions->chkSort->Checked());	// first (last entered) line is not sorted
        if(frmHistory)
            frmHistory->lstHistory->Items().SetLines(slHistory.ToWstringVector());

    }
	frmHistOptions->Destroy();
	frmHistOptions = NULL;
}

void TfrmMain::miAboutClick(void *sender, nlib::EventParameters param)
{
	frmAbout = new TfrmAbout;
	frmAbout ->SetTopLevelParent(this);
	frmAbout ->ShowModal();
	frmAbout->Destroy();
}

void TfrmMain::miGenHelpClick(void *sender, nlib::EventParameters param)
{
	frmHelp = new TfrmHelp;
	frmHelp ->SetTopLevelParent(this);
	frmHelp ->ShowModal();
	frmHelp->Destroy();
}

void TfrmMain::miCharFontClick(void *sender, nlib::EventParameters param)
{
	btnFont->Click();
}

void TfrmMain::miCopyDecClick(void *sender, nlib::EventParameters param)
{
	wstring ws = pnlDec->Text();	// reformat for 'normal' number
	int pos;
	if( (pos = ws.find_first_of(_CHART(183)) ) != wstring::npos)
		ws = ws.substr(0,pos) + _CHART('e') + ws.substr(pos+5, ws.length()-pos-5-1);
	MyClipboard->SetText(ws );
}

void TfrmMain::miCopyHexClick(void *sender, nlib::EventParameters param)
{
	MyClipboard->SetText(pnlHex->Text() );
}

void TfrmMain::miCopyOctClick(void *sender, nlib::EventParameters param)
{
	MyClipboard->SetText(pnlOct->Text() );
}

void TfrmMain::miCopyBinClick(void *sender, nlib::EventParameters param)
{
	MyClipboard->SetText(pnlBin->Text() );
}

void TfrmMain::cbThousandSepChanged(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.strThousandSeparator =  SmartString(cbThousandSep->ItemIndex() > 0 ? cbThousandSep->Text()[0] : ' ');
	if(lengine->displayFormat.strThousandSeparator == SmartString('s') )	// 'space'
		lengine->displayFormat.strThousandSeparator = " ";
	_ShowResults();
}

void TfrmMain::ShowDecOptions(bool show)
{
    if(pnlDecOpt->Visible() == show)
        return;
    miShowDecOpts->SetChecked(show);
    if(show)
    {
        SetHeight( Height() + pnlDecOpt->Height());
        btnOpenHexOptions->SetTop(_nHexBtnTop);
            // although this is common for both show and not show
            // if this is set AFTER 'pnlDecOpt' is shown the
            // btnCloseHexOptions remains on the screen over the panel in XE
        btnCloseHexOptions->SetTop(btnOpenHexOptions->Top());

        pnlDecOpt->SetTop(_nDecOptTop);
    }
    else
    {
// DEBUG 2 lines
// int hp = pnlDecOpt->Height(),
// h = Height();
        SetHeight(Height() - pnlDecOpt->Height());
// h = Height(); // DEBUG
        btnOpenHexOptions->SetTop(_nDecOptTop);
        btnCloseHexOptions->SetTop(btnOpenHexOptions->Top());
    }
    pnlDecOpt->SetVisible(show);
    pnlHexOpt->SetTop( btnOpenHexOptions->Top() + btnOpenHexOptions->Height()+2);
    btnOpenDecOptions->SetVisible(!show);
    btnCloseDecOptions->SetVisible(show);
}

//---------------------------------------------------------------------------
void TfrmMain::ShowHexOptions(bool show)
{
    if(pnlHexOpt->Visible() == show)
        return;
    miShowHexOpts->SetChecked(show);
    int h = pnlHexOpt->Height()-5;
    if(!show)
        h = -h;
// DEBUG
//int hh = Height();
    SetHeight(Height() + h);
//hh = Height();
    pnlDecOpt->SetTop(_nDecOptTop);

    pnlHexOpt->SetVisible(show);
    btnOpenHexOptions->SetVisible(!show);
    btnCloseHexOptions->SetVisible(show);
}

void TfrmMain::OpenVarsOrFunctions(void* sender, int which, nlib::EventParameters param)
{
	Rect wrect = wiMain.BareVisibleWindowRect();

	if (!frmVariables)
	{
		frmVariables = new TfrmVariables;
		frmVariables->SetTopLevelParent(this);
		frmVariables->SetLeft(wrect.right+1);
		frmVariables->SetTop(WindowRect().top);

		wiVars.InitInfo(frmVariables, L"frmVariables");
	}
	else
	{
		TabChangeParameters par(which);
		frmVariables->tcVarsTabChange(sender, par);
		wiVars.RefreshInfo();
	}
	frmVariables->tcVars->SetSelectedTab(which);
	if (frmVariables->GetSnapSide() != FalconCalc::WindowSide::wsNone)
		frmVariables->Snap();

	frmVariables->Show();

	SetFocus(cbInfix->Handle());
}

void TfrmMain::btnCloseDecOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowDecOptions(false);
}

void TfrmMain::btnCloseHexOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowHexOptions(false);
}

void TfrmMain::btnOpenDecOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowDecOptions(true);
}

void TfrmMain::btnOpenHexOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowHexOptions(true);
}

// SA
void TfrmMain::_EnableMyTimer(bool enable)
{
//	if(_bAutoSave == enable)
//		return;
	if(enable)
		SetTimer(Handle(), (UINT_PTR)0x12, 1000, 0); // Timer1
	else
		KillTimer(Handle(),(UINT_PTR)0x12);
	_bAutoSave = enable;
}

SmartString TfrmMain::UserDir()
{
	static SmartString _userDir("*");

	if (_userDir[0] != u'*')
		return _userDir;


	wchar_t buff[2046];
	std::wstring w;
	if (!SHGetFolderPath(NULL, CSIDL_PROFILE, NULL, 0, buff))
	{
		w = buff;

		w += L"\\AppData\\Local\\FalconCalc\\";
		if (!PathExists(w))
		{
			if (!CreateDirectory(w.c_str(), NULL))
				w = (wstring&)ExecutablePath;
		}
	}
	else
		w = (wstring&)ExecutablePath;

	return _userDir = SmartString(w);
}


// Adds actual expression to history
// Always inserts line at first position (top of list)
// For sorted list it first inserts the original first line
// then insert the new at the top
// If the expression was already in the list deletes it first from the list
void TfrmMain::_AddToHistory(wstring text)
{
	SmartString ss(text);
	ss.Trim();

	if (_minCharLength >= ss.length())	// do not add too short strings
		return;

	if (lengine->resultType == LittleEngine::ResultType::rtInvalid || lengine->resultType == LittleEngine::ResultType::rtUndef)
	{
		_watchdog = 0;
		return;
	}

	if (LittleEngine::variables.count(ss) || LongNumber::constantsMap.count(ss) )		// single, already defined variable?
	{
		_added = true;	// so won't try it to add again
		_watchdog = 0;
		return;
	}

    int n;
	bool added = false;
    if( (n = cbInfix->Items().IndexOf(ss.ToWideString())) == -1)	// not found
		cbInfix->Items().Insert(0, ss.ToWideString());	// and to combobox

    if( (n = slHistory.IndexOf(ss)) >= 0)	// found in history
    {
        if(n == 0 && slHistory.IsSorted())	// already at top
            return;							// nothing to do
        slHistory.Delete(n);	// not at top delete expression from inside
    }
	else if(slHistory.IsSorted() )			// then must put original top line in correct position
	{										// first and add the new line afterwards, because
		SmartString ws = slHistory[0];		// list may be truncated after adding a new line to it
		slHistory.Delete(0);	// delete original top line
		slHistory.Add(ws);					// and insert into string
		added = true;						// do not add twice
	}
	if (!added)	// then not sorted or already added original top line
		slHistory.insert(slHistory.begin(), ss);	// insert new expression to top of list

	if (_maxHistDepth && slHistory.size() > _maxHistDepth)		// check if history is full
		slHistory.erase(slHistory.begin() + _maxHistDepth, slHistory.end());

    _added = true;
    _watchdog = 0;
    if(frmHistory != 0)
        frmHistory->lstHistory->Items().SetLines(slHistory.ToWstringVector());
}

void TfrmMain::FormClose(void *sender, nlib::FormCloseParameters param)
{
	if (frmHistory)
		frmHistory->Close();
	if (frmVariables)
		frmVariables->Close();
}

void TfrmMain::chkAsBytesClick(void *sender, nlib::EventParameters param)
{
	chkWords->SetChecked(false);
	chkDWords->SetChecked(false);
	bool b = chkBytes->Checked();
	if(b)
		lengine->displayFormat.hexFormat = HexFormat::rnHexByte;
	else
		lengine->displayFormat.hexFormat = HexFormat::rnHexNormal;
//	chkLittleEndian->SetEnabled(b);
	_ShowResults();
}

void TfrmMain::chkAsWordsClick(void *sender, nlib::EventParameters param)
{
	chkBytes->SetChecked(false);
	chkDWords->SetChecked(false);
	bool b = chkWords->Checked();
	if (b)
		lengine->displayFormat.hexFormat = HexFormat::rnHexWord;
	else
		lengine->displayFormat.hexFormat = HexFormat::rnHexNormal;
//	chkLittleEndian->SetEnabled(b);
	_ShowResults();
}

void TfrmMain::chkAsDWordsClick(void *sender, nlib::EventParameters param)
{
	chkWords->SetChecked(false);
	chkBytes->SetChecked(false);
	bool b = chkDWords->Checked();
	if (b)
		lengine->displayFormat.hexFormat = HexFormat::rnHexDWord;
	else
		lengine->displayFormat.hexFormat = HexFormat::rnHexNormal;
//	chkLittleEndian->SetEnabled(b);
	_ShowResults();
}

void TfrmMain::chkIEEEDoubleClick(void *sender, nlib::EventParameters param)
{
	chkIEEESingle->SetChecked(false);
	lengine->displayFormat.trippleE =  chkIEEEDouble->Checked() ? IEEEFormat::rntHexIEEE754Double : IEEEFormat::rntHexNotIEEE;
	_ShowResults();
}

void TfrmMain::chkIEEESingleClick(void *sender, nlib::EventParameters param)
{
	chkIEEEDouble->SetChecked(false);
	lengine->displayFormat.trippleE =  chkIEEESingle->Checked() ? IEEEFormat::rntHexIEEE754Single : IEEEFormat::rntHexNotIEEE;
	_ShowResults();
}

void TfrmMain::miSetEnClick(void* sender, nlib::EventParameters param)
{
	if (lt.SetLanguage(AppLanguage::lanEng))	// then set it up
	_SetupForLanguage();
}

void TfrmMain::miSetHunClick(void* sender, nlib::EventParameters param)
{
	if (lt.SetLanguage(AppLanguage::lanHun))	// then set it up
		_SetupForLanguage();
}

void TfrmMain::chkLittleEndianClick(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.littleEndian =  chkLittleEndian->Checked() ? true: false;
	_ShowResults();
}

void TfrmMain::btnCopyFormatClick(void *sender, nlib::EventParameters param)
{
	Button *pb = reinterpret_cast<Button*>(sender);
	switch (pb->Tag())
	{
		case 0: miCopyDecClick(sender, param); break;
		case 1: MyClipboard->SetText(pnlHex->Text() ); break;
		case 2: MyClipboard->SetText(pnlOct->Text() ); break;
		case 3: MyClipboard->SetText(pnlBin->Text() ); break;
	}
	SetFocus(cbInfix->Handle());
}

void TfrmMain::miSetLocale(void* sender, nlib::EventParameters param)
{
	TfrmLocale *frmLocale = new TfrmLocale();
	SmartString sOldLocName(frmLocale->LocaleName());

	nlib::ModalResults mr = frmLocale->ShowModal();
	if (mr == nlib::mrOk)	// 'Save'
	{
		SmartString sLocName(frmLocale->LocaleName());
		if (sLocName != sOldLocName)
		{
			lengine->clean = false;
			locale loc(sLocName.toUtf8String().c_str());
			cin.imbue(loc);
			cout.imbue(loc);
		}
	}

}

#if 0
void TfrmMain::KeyUpOverride(void* sender, nlib::KeyParameters param)
{
	if (param.keycode == VK_ESCAPE)
	{
		static bool show = true;
		if (show)
		{
			ModalResults res = ShowMessageBox(L"FalconCalc will be minimized to the taskbar.", L"falconCalc - Warning", mbOk, nlib::miInformation);
			show = false;
			ShowWindow(Handle(), SW_MINIMIZE);
		}
		return;
	}
}
#endif

void TfrmMain::StartMove(void *sender, nlib::EventParameters param)
{
	++_inMoving;
}

void TfrmMain::FormSizeMoveEnded(void* sender, nlib::SizePositionChangedParameters param)
{
	--_inMoving;
	wiMain.RefreshInfo();

	if (frmHistory && !frmHistory->Snapped())
		if (frmHistory->GetSnapSide() != FalconCalc::wsNone)
			frmHistory->Snap();

	if (frmVariables && !frmVariables->Snapped())
		if (frmVariables->GetSnapSide() != FalconCalc::wsNone)
			frmVariables->Snap();
}

void TfrmMain::FormMove(void *sender, nlib::EventParameters param)
{
	wiMain.RefreshInfo();
	if (frmHistory && frmHistory->Snapped())
		frmHistory->Snap();

	if (frmVariables && frmVariables->Snapped())
		frmVariables->Snap();
}
	// this single funcion deals with Normal, HTML, TeX and E display
void TfrmMain::rdNormalClick(void *sender, nlib::EventParameters param)
{
	lengine->displayFormat.expFormat= (LongNumber::ExpFormat)((Radiobox*)sender)->Tag();
	//sres.type = sres.mode == bmoNone ? stDecimal : stDecBeautified;
	_ShowResults();
}
