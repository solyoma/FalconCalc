#include "stdafx_zoli.h"
#include "stdafx_lc.h"

using namespace nlib;
#include "application.h"
#include "about.h"
#include "help.h"
#include "history.h"
#include "histopt.h"

#include "graphictext.h"

#include "calculate.h"

#include "main.h"
#include "variables.h"

using namespace LongNumber;

littlecalc::LittleEngine *lengine;


Clipboard *MyClipboard;

TfrmMain *frmMain;
const wstring LITTLECALC_HIST_FILE = L"FalconCalc.hist";
const wchar_t *LITTLECALC_DAT_FILE = L"FalconCalc.dat";
const wchar_t *LITTLECALC_CFG_FILE = L"FalconCalc.cfg";


#if 0
static inline size_t _HexD2Char(_CHART ch)
{ // ch is one hex digit: 0..9,A..F
    ch -= ((ch > '9') ? 'A'-10 : '0');
    return (size_t)ch;
}

static wstring _StringFromHex(STRING_RESULT sres)
{
    STRING_RESULT r = sres;
    r.type = stHex;
    r.hexFormat = hfNormal;
    r.showAs = shaBytes;
    wstring s = r.ToString();
    if(s[0] == '-')       // wstring may start with '-'
        s = s.substr(1);
    if(s[0] == 'T' || s[0] == 'I')
        return L"";
    size_t j = 0;
    size_t i = 0;
    while(i < s.length()-2)
    {
        s[j] = (_HexD2Char(s[i]) << 4) + _HexD2Char(s[i+1]);
        if(s[j] < ' ' )
            s[j] = '.';
            ++j;
        i+=3;
    }
    s[j++] = (_HexD2Char(s[i]) << 4) + _HexD2Char(s[i+1]);
    return s.substr(0,j);
}
#endif

void TfrmMain::InitializeFormAndControls() /* Control initialization function generated by the designer. Modifications will be lost. */
{
	/* Generated member initialization. Do not modify. */
	SetLeft(777);
	SetTop(436);
	SetText(L"FalconCalc");
	GetFont().SetFamily(L"Tahoma");
	GetFont().SetSize(10);
	SetWantedKeyTypes(nlib::wkArrows | nlib::wkTab | nlib::wkEnter | nlib::wkEscape | nlib::wkOthers);
	SetShowPosition(nlib::fspActiveMonitorCenter);
	SetBorderStyle(nlib::fbsSingle);
	SetClientRect(nlib::Rect(0, 0, 528, 372 + GetSystemMetrics(SM_CYMENU)));

	FontDialog1 = new nlib::FontDialog();
	FontDialog1->GetFont().SetFamily(L"Tahoma");
	FontDialog1->GetFont().SetSize(8);
	FontDialog1->SetParent(this);

	pmCopy = new nlib::PopupMenu();
	miCopyDec = pmCopy->Add(L"Copy &Decimal");
	miCopyHex = pmCopy->Add(L"Copy He&xadecimal");
	miCopyOct = pmCopy->Add(L"Copy &Octal");
	miCopyBin = pmCopy->Add(L"Copy &Binary");
	miCopySep = pmCopy->Add(L"-");
	miCopyText = pmCopy->Add(L"Copy &Formula");
	pmCopy->SetParent(this);

	mnuMain = new nlib::Menubar();
	miFile = mnuMain->Add(L"&File");
	miExit = miFile->Add(L"E&xit");
	miExit->SetShortcut(L"Alt+X");
	miEdit = mnuMain->Add(L"&Edit");
	miCopy = miEdit->Add(L"&Copy");
	miCopy->SetShortcutText(L"Ctrl+C");
	miPaste = miEdit->Add(L"&Paste");
	miPaste->SetShortcutText(L"Ctrl+V");
	miAppend = miEdit->Add(L"Paste &After");
	MenuItem1 = miEdit->Add(L"-");
	miCopyDecimal = miEdit->Add(L"Copy &Decimal");
	miCopyHexadecimal = miEdit->Add(L"Copy &Hexadecimal");
	miCopyHexadecimal->SetTag(1);
	miCopyOctal = miEdit->Add(L"Copy &Octal");
	miCopyOctal->SetTag(2);
	miCopyBinary = miEdit->Add(L"Copy &Binary");
	miCopyBinary->SetTag(3);
	MenuItem2 = miEdit->Add(L"-");
	miEditVars = miEdit->Add(L"Edit User &Variables...");
	miEditVars->SetTag(1);
	miEditVars->SetShortcut(L"Ctrl+U");
	miEditFuncs = miEdit->Add(L"Edit User &Functions...");
	miEditFuncs->SetShortcut(L"Ctrl+F");
	MenuItem3 = miEdit->Add(L"-");
	miShowHist = miEdit->Add(L"Edit &History");
	miShowHist->SetShortcut(L"Ctrl+H");
	miClearHist = miEdit->Add(L"C&lear History");
	miOptions = mnuMain->Add(L"&Options");
	miShowDecOpts = miOptions->Add(L"Show &Decimal Options");
	miShowDecOpts->SetShortcutText(L"Ctrl+D");
	miShowHexOpts = miOptions->Add(L"Show &Hexadecimal  Options");
	miShowHexOpts->SetShortcut(L"Ctrl+X");
	miCharFont = miOptions->Add(L"&Font For 'As String...' Display");
	miHistOpts = miOptions->Add(L"Histor&y Options...");
	miHelp = mnuMain->Add(L"&Help");
	miAbout = miHelp->Add(L"&About");
	miGenHelp = miHelp->Add(L"&General Help");
	miGenHelp->SetShortcut(L"F1");
	mnuMain->SetParent(this);

	btnOpenHexOptions = new nlib::FlatButton();
	btnOpenHexOptions->SetBounds(nlib::Rect(14, 279, 242, 291));
	btnOpenHexOptions->SetText(L"-----------Hex. options------------------");
	btnOpenHexOptions->SetVisible(false);
	btnOpenHexOptions->GetFont().SetFamily(L"Tahoma");
	btnOpenHexOptions->GetFont().SetSize(10);
	btnOpenHexOptions->SetParentFont(false);
	btnOpenHexOptions->SetTabOrder(10);
	btnOpenHexOptions->SetParent(this);

	btnOpenDecOptions = new nlib::FlatButton();
	btnOpenDecOptions->SetBounds(nlib::Rect(14, 175, 242, 187));
	btnOpenDecOptions->SetText(L"-----------Decimal options--------------");
	btnOpenDecOptions->SetVisible(false);
	btnOpenDecOptions->GetFont().SetFamily(L"Tahoma");
	btnOpenDecOptions->GetFont().SetSize(10);
	btnOpenDecOptions->SetParentFont(false);
	btnOpenDecOptions->SetTabOrder(9);
	btnOpenDecOptions->SetParent(this);

	pToolbar = new nlib::Panel();
	pToolbar->SetBounds(nlib::Rect(0, 0, 528, 29));
	pToolbar->SetAlignment(nlib::alTop);
	pToolbar->SetTabOrder(1);
	pToolbar->SetInnerBorderStyle(nlib::pbsNone);
	pToolbar->SetParent(this);

	tbExit = new nlib::FlatButton();
	tbExit->SetBounds(nlib::Rect(0, 0, 23, 23));
	tbExit->GetFont().SetFamily(L"Tahoma");
	tbExit->GetFont().SetSize(10);
	tbExit->SetParentFont(false);
	tbExit->SetTabOrder(0);
	tbExit->SetParent(pToolbar);

	Bevel1 = new nlib::Bevel();
	Bevel1->SetBounds(nlib::Rect(26, 1, 28, 22));
	Bevel1->SetShape(nlib::bstLeftLine);
	Bevel1->SetParent(pToolbar);

	tbHistory = new nlib::FlatButton();
	tbHistory->SetBounds(nlib::Rect(31, 0, 54, 23));
	tbHistory->GetFont().SetFamily(L"Tahoma");
	tbHistory->GetFont().SetSize(10);
	tbHistory->SetParentFont(false);
	tbHistory->SetTabOrder(1);
	tbHistory->SetParent(pToolbar);

	tbCopy = new nlib::FlatButton();
	tbCopy->SetBounds(nlib::Rect(55, 0, 78, 23));
	tbCopy->GetFont().SetFamily(L"Tahoma");
	tbCopy->GetFont().SetSize(10);
	tbCopy->SetParentFont(false);
	tbCopy->SetTabOrder(2);
	tbCopy->SetParent(pToolbar);

	tbPaste = new nlib::FlatButton();
	tbPaste->SetBounds(nlib::Rect(79, 0, 102, 23));
	tbPaste->SetEnabled(false);
	tbPaste->GetFont().SetFamily(L"Tahoma");
	tbPaste->GetFont().SetSize(10);
	tbPaste->SetParentFont(false);
	tbPaste->SetTabOrder(3);
	tbPaste->SetParent(pToolbar);

	edtInfix = new nlib::Edit();
	edtInfix->SetBounds(nlib::Rect(8, 29, 513, 50));
	edtInfix->GetFont().SetFamily(L"Tahoma");
	edtInfix->GetFont().SetSize(10);
	edtInfix->SetParentFont(false);
	edtInfix->SetTabOrder(0);
	edtInfix->SetParent(this);

	gbResults = new nlib::Groupbox();
	gbResults->SetBounds(nlib::Rect(16, 52, 521, 175));
	gbResults->SetText(L"Result");
	gbResults->SetPadding(nlib::Rect(0, 0, 0, 0));
	gbResults->GetFont().SetFamily(L"Tahoma");
	gbResults->GetFont().SetSize(10);
	gbResults->SetParentFont(false);
	gbResults->SetTabOrder(2);
	gbResults->SetParent(this);

	btnDecimal = new nlib::Button();
	btnDecimal->SetBounds(nlib::Rect(1, 16, 80, 39));
	btnDecimal->SetText(L"Deci&mal");
	btnDecimal->SetTabOrder(1);
	btnDecimal->SetTooltipText(L"Copy decimal number to clipboard");
	btnDecimal->SetParent(gbResults);

	btnHexadecimal = new nlib::Button();
	btnHexadecimal->SetTag(1);
	btnHexadecimal->SetBounds(nlib::Rect(1, 41, 80, 64));
	btnHexadecimal->SetText(L"&Hexadecimal");
	btnHexadecimal->SetTabOrder(2);
	btnHexadecimal->SetTooltipText(L"Copy hexadec. number to clipboard");
	btnHexadecimal->SetParent(gbResults);

	btnOctal = new nlib::Button();
	btnOctal->SetTag(2);
	btnOctal->SetBounds(nlib::Rect(2, 67, 81, 90));
	btnOctal->SetText(L"O&ctal");
	btnOctal->SetTabOrder(4);
	btnOctal->SetTooltipText(L"Copy octal number to clipboard");
	btnOctal->SetParent(gbResults);

	btnBinary = new nlib::Button();
	btnBinary->SetTag(3);
	btnBinary->SetBounds(nlib::Rect(2, 94, 81, 117));
	btnBinary->SetText(L"&Binary");
	btnBinary->SetTabOrder(6);
	btnBinary->SetTooltipText(L"Copy binary number to clipboard");
	btnBinary->SetParent(gbResults);

	pnlDec = new nlib::Panel();
	pnlDec->SetBounds(nlib::Rect(83, 15, 500, 40));
	pnlDec->GetFont().SetFamily(L"Arial");
	pnlDec->GetFont().SetSize(10);
	pnlDec->GetFont().SetCharacterSet(nlib::fcsAnsi);
	pnlDec->GetFont().SetOutputQuality(nlib::foqDraft);
	pnlDec->SetParentFont(false);
	pnlDec->SetTabOrder(0);
	pnlDec->SetShowText(false);
	pnlDec->SetInnerBorderStyle(nlib::pbsSunken);
	pnlDec->SetTextAlignment(nlib::taRight);
	pnlDec->SetParent(gbResults);

	pnlHex = new nlib::Panel();
	pnlHex->SetBounds(nlib::Rect(83, 41, 500, 66));
	pnlHex->GetFont().SetFamily(L"Arial");
	pnlHex->GetFont().SetSize(10);
	pnlHex->SetParentFont(false);
	pnlHex->SetTabOrder(3);
	pnlHex->SetInnerBorderStyle(nlib::pbsSunken);
	pnlHex->SetTextAlignment(nlib::taRight);
	pnlHex->SetParent(gbResults);

	pnlOct = new nlib::Panel();
	pnlOct->SetBounds(nlib::Rect(83, 67, 500, 92));
	pnlOct->GetFont().SetFamily(L"Arial");
	pnlOct->GetFont().SetSize(10);
	pnlOct->SetParentFont(false);
	pnlOct->SetTabOrder(5);
	pnlOct->SetInnerBorderStyle(nlib::pbsSunken);
	pnlOct->SetTextAlignment(nlib::taRight);
	pnlOct->SetParent(gbResults);

	pnlBin = new nlib::Panel();
	pnlBin->SetBounds(nlib::Rect(83, 93, 500, 118));
	pnlBin->GetFont().SetFamily(L"Arial");
	pnlBin->GetFont().SetSize(10);
	pnlBin->SetParentFont(false);
	pnlBin->SetTabOrder(7);
	pnlBin->SetInnerBorderStyle(nlib::pbsSunken);
	pnlBin->SetTextAlignment(nlib::taRight);
	pnlBin->SetParent(gbResults);

	pnlDecOpt = new nlib::Panel();
	pnlDecOpt->SetBounds(nlib::Rect(8, 191, 513, 277));
	pnlDecOpt->SetTabOrder(3);
	pnlDecOpt->SetInnerBorderStyle(nlib::pbsNone);
	pnlDecOpt->SetParent(this);

	Groupbox1 = new nlib::Groupbox();
	Groupbox1->SetBounds(nlib::Rect(11, 1, 230, 89));
	Groupbox1->SetText(L"Decimal options");
	Groupbox1->SetPadding(nlib::Rect(0, 0, 0, 0));
	Groupbox1->GetFont().SetFamily(L"Tahoma");
	Groupbox1->GetFont().SetSize(10);
	Groupbox1->SetParentFont(false);
	Groupbox1->SetTabOrder(0);
	Groupbox1->SetParent(pnlDecOpt);

	chkSep = new nlib::Checkbox();
	chkSep->SetBounds(nlib::Rect(8, 16, 165, 33));
	chkSep->SetText(L"Use t&housand separator:");
	chkSep->GetFont().SetFamily(L"Tahoma");
	chkSep->GetFont().SetSize(10);
	chkSep->SetParentFont(false);
	chkSep->SetTabOrder(0);
	chkSep->SetState(nlib::csChecked);
	chkSep->SetParent(Groupbox1);

	cbThousandSep = new nlib::Combobox();
	cbThousandSep->SetBounds(nlib::Rect(168, 16, 215, 40));
	cbThousandSep->SetText(L"spc");
	cbThousandSep->GetFont().SetFamily(L"Tahoma");
	cbThousandSep->GetFont().SetSize(10);
	cbThousandSep->SetParentFont(false);
	cbThousandSep->SetTabOrder(1);
	cbThousandSep->SetType(nlib::ctDropdownList);
	cbThousandSep->Items().Add(L"spc");
	cbThousandSep->Items().Add(L",");
	cbThousandSep->Items().Add(L".");
	cbThousandSep->Items().Add(L";");
	cbThousandSep->SetItemIndex(0);
	cbThousandSep->SetParent(Groupbox1);

	chkSci = new nlib::Checkbox();
	chkSci->SetBounds(nlib::Rect(8, 32, 141, 49));
	chkSci->SetText(L"&Scientific format");
	chkSci->GetFont().SetFamily(L"Tahoma");
	chkSci->GetFont().SetSize(10);
	chkSci->SetParentFont(false);
	chkSci->SetTabOrder(2);
	chkSci->SetParent(Groupbox1);

	chkEng = new nlib::Checkbox();
	chkEng->SetBounds(nlib::Rect(8, 48, 149, 65));
	chkEng->SetText(L"Engeneering f&ormat");
	chkEng->GetFont().SetFamily(L"Tahoma");
	chkEng->GetFont().SetSize(10);
	chkEng->SetParentFont(false);
	chkEng->SetTabOrder(3);
	chkEng->SetParent(Groupbox1);

	chkDecDigits = new nlib::Checkbox();
	chkDecDigits->SetBounds(nlib::Rect(8, 64, 149, 81));
	chkDecDigits->SetText(L"&Decimal digits:");
	chkDecDigits->GetFont().SetFamily(L"Tahoma");
	chkDecDigits->GetFont().SetSize(10);
	chkDecDigits->SetParentFont(false);
	chkDecDigits->SetTabOrder(4);
	chkDecDigits->SetParent(Groupbox1);

	spnDecDigits = new nlib::Edit();
	spnDecDigits->SetBounds(nlib::Rect(141, 63, 178, 84));
	spnDecDigits->SetText(L"0");
	spnDecDigits->GetFont().SetFamily(L"Tahoma");
	spnDecDigits->GetFont().SetSize(10);
	spnDecDigits->SetParentFont(false);
	spnDecDigits->SetTabOrder(5);
	spnDecDigits->SetParent(Groupbox1);

	UpDown1 = new nlib::UpDown();
	UpDown1->SetBounds(nlib::Rect(177, 63, 194, 84));
	UpDown1->SetMaxValue(20);
	UpDown1->SetParent(Groupbox1);

	rgAngleUnit = new nlib::Groupbox();
	rgAngleUnit->SetBounds(nlib::Rect(236, 7, 428, 53));
	rgAngleUnit->SetText(L"Angles in");
	rgAngleUnit->SetPadding(nlib::Rect(0, 0, 0, 0));
	rgAngleUnit->GetFont().SetFamily(L"Tahoma");
	rgAngleUnit->GetFont().SetSize(10);
	rgAngleUnit->SetParentFont(false);
	rgAngleUnit->SetTabOrder(1);
	rgAngleUnit->SetParent(pnlDecOpt);

	rdDeg = new nlib::Radiobox();
	rdDeg->SetBounds(nlib::Rect(11, 19, 59, 35));
	rdDeg->SetText(L"De&g");
	rdDeg->GetFont().SetFamily(L"Tahoma");
	rdDeg->GetFont().SetSize(10);
	rdDeg->SetParentFont(false);
	rdDeg->SetTabOrder(0);
	rdDeg->SetChecked(true);
	rdDeg->SetParent(rgAngleUnit);

	rdGrad = new nlib::Radiobox();
	rdGrad->SetTag(1);
	rdGrad->SetBounds(nlib::Rect(59, 19, 115, 35));
	rdGrad->SetText(L"&Grad");
	rdGrad->GetFont().SetFamily(L"Tahoma");
	rdGrad->GetFont().SetSize(10);
	rdGrad->SetParentFont(false);
	rdGrad->SetTabOrder(1);
	rdGrad->SetParent(rgAngleUnit);

	rdRad = new nlib::Radiobox();
	rdRad->SetTag(2);
	rdRad->SetBounds(nlib::Rect(123, 19, 187, 35));
	rdRad->SetText(L"&Rad");
	rdRad->GetFont().SetFamily(L"Tahoma");
	rdRad->GetFont().SetSize(10);
	rdRad->SetParentFont(false);
	rdRad->SetTabOrder(2);
	rdRad->SetParent(rgAngleUnit);

	Groupbox3 = new nlib::Groupbox();
	Groupbox3->SetBounds(nlib::Rect(236, 47, 492, 93));
	Groupbox3->SetText(L"Display");
	Groupbox3->SetPadding(nlib::Rect(0, 0, 0, 0));
	Groupbox3->GetFont().SetFamily(L"Tahoma");
	Groupbox3->GetFont().SetSize(10);
	Groupbox3->SetParentFont(false);
	Groupbox3->SetTabOrder(2);
	Groupbox3->SetParent(pnlDecOpt);

	rdNormal = new nlib::Radiobox();
	rdNormal->SetBounds(nlib::Rect(11, 19, 91, 35));
	rdNormal->SetText(L"Norm&al");
	rdNormal->GetFont().SetFamily(L"Tahoma");
	rdNormal->GetFont().SetSize(10);
	rdNormal->SetParentFont(false);
	rdNormal->SetTabOrder(0);
	rdNormal->SetChecked(true);
	rdNormal->SetParent(Groupbox3);

	rdHtml = new nlib::Radiobox();
	rdHtml->SetTag(1);
	rdHtml->SetBounds(nlib::Rect(77, 20, 141, 36));
	rdHtml->SetText(L"&HTML");
	rdHtml->GetFont().SetFamily(L"Tahoma");
	rdHtml->GetFont().SetSize(10);
	rdHtml->SetParentFont(false);
	rdHtml->SetTabOrder(1);
	rdHtml->SetParent(Groupbox3);

	rdTex = new nlib::Radiobox();
	rdTex->SetTag(2);
	rdTex->SetBounds(nlib::Rect(142, 20, 190, 36));
	rdTex->SetText(L"&TeX");
	rdTex->GetFont().SetFamily(L"Tahoma");
	rdTex->GetFont().SetSize(10);
	rdTex->SetParentFont(false);
	rdTex->SetTabOrder(2);
	rdTex->SetParent(Groupbox3);

	rdNone = new nlib::Radiobox();
	rdNone->SetTag(3);
	rdNone->SetBounds(nlib::Rect(198, 20, 238, 36));
	rdNone->SetText(L"E");
	rdNone->SetTabOrder(3);
	rdNone->SetParent(Groupbox3);

	pnlHexOpt = new nlib::Panel();
	pnlHexOpt->SetBounds(nlib::Rect(8, 293, 515, 375));
	pnlHexOpt->SetTabOrder(4);
	pnlHexOpt->SetInnerBorderStyle(nlib::pbsNone);
	pnlHexOpt->SetParent(this);

	Groupbox2 = new nlib::Groupbox();
	Groupbox2->SetBounds(nlib::Rect(8, 1, 337, 75));
	Groupbox2->SetText(L"Hex Display");
	Groupbox2->SetPadding(nlib::Rect(0, 0, 0, 0));
	Groupbox2->GetFont().SetFamily(L"Tahoma");
	Groupbox2->GetFont().SetSize(10);
	Groupbox2->SetParentFont(false);
	Groupbox2->SetTabOrder(0);
	Groupbox2->SetParent(pnlHexOpt);

	chkMinus = new nlib::Checkbox();
	chkMinus->SetBounds(nlib::Rect(16, 18, 102, 35));
	chkMinus->SetText(L"M&inus sign");
	chkMinus->GetFont().SetFamily(L"Tahoma");
	chkMinus->GetFont().SetSize(10);
	chkMinus->SetParentFont(false);
	chkMinus->SetTabOrder(0);
	chkMinus->SetTooltipText(L"Absolute value of negative numbers are shown with a minus sign");
	chkMinus->SetParent(Groupbox2);

	chkLittleEndian = new nlib::Checkbox();
	chkLittleEndian->SetTag(6);
	chkLittleEndian->SetBounds(nlib::Rect(16, 52, 102, 69));
	chkLittleEndian->SetText(L"&Little endian");
	chkLittleEndian->GetFont().SetFamily(L"Tahoma");
	chkLittleEndian->GetFont().SetSize(10);
	chkLittleEndian->SetParentFont(false);
	chkLittleEndian->SetTabOrder(1);
	chkLittleEndian->SetTooltipText(L"Left to right order of bytes from least significant to most significant (Intel ordering)");
	chkLittleEndian->SetParent(Groupbox2);

	chkBytes = new nlib::Checkbox();
	chkBytes->SetTag(1);
	chkBytes->SetBounds(nlib::Rect(116, 18, 202, 35));
	chkBytes->SetText(L"As B&ytes");
	chkBytes->GetFont().SetFamily(L"Tahoma");
	chkBytes->GetFont().SetSize(10);
	chkBytes->SetParentFont(false);
	chkBytes->SetTabOrder(2);
	chkBytes->SetParent(Groupbox2);

	chkWords = new nlib::Checkbox();
	chkWords->SetTag(2);
	chkWords->SetBounds(nlib::Rect(116, 35, 202, 52));
	chkWords->SetText(L"As &Words");
	chkWords->GetFont().SetFamily(L"Tahoma");
	chkWords->GetFont().SetSize(10);
	chkWords->SetParentFont(false);
	chkWords->SetTabOrder(3);
	chkWords->SetParent(Groupbox2);

	chkDWords = new nlib::Checkbox();
	chkDWords->SetTag(3);
	chkDWords->SetBounds(nlib::Rect(116, 52, 202, 69));
	chkDWords->SetText(L"As DWo&rds");
	chkDWords->GetFont().SetFamily(L"Tahoma");
	chkDWords->GetFont().SetSize(10);
	chkDWords->SetParentFont(false);
	chkDWords->SetTabOrder(4);
	chkDWords->SetParent(Groupbox2);

	chkSingle = new nlib::Checkbox();
	chkSingle->SetTag(4);
	chkSingle->SetBounds(nlib::Rect(203, 18, 321, 35));
	chkSingle->SetText(L"As IEE &754 single");
	chkSingle->GetFont().SetFamily(L"Tahoma");
	chkSingle->GetFont().SetSize(10);
	chkSingle->SetParentFont(false);
	chkSingle->SetTabOrder(5);
	chkSingle->SetTooltipText(L"Single precision floating point format");
	chkSingle->SetParent(Groupbox2);

	chkDouble = new nlib::Checkbox();
	chkDouble->SetTag(5);
	chkDouble->SetBounds(nlib::Rect(203, 35, 321, 52));
	chkDouble->SetText(L"As IEE 7&54 double");
	chkDouble->GetFont().SetFamily(L"Tahoma");
	chkDouble->GetFont().SetSize(10);
	chkDouble->SetParentFont(false);
	chkDouble->SetTabOrder(6);
	chkDouble->SetTooltipText(L"Double precision floating point format");
	chkDouble->SetParent(Groupbox2);

	cbInfix = new nlib::Combobox();
	cbInfix->SetBounds(nlib::Rect(357, 21, 493, 45));
	cbInfix->SetTabOrder(1);
	cbInfix->Items().Add(L"");
	cbInfix->Items().Add(L"1234*5678");
	cbInfix->Items().Add(L"9876*1245.9");
	cbInfix->SetParent(pnlHexOpt);

	Label1 = new nlib::Label();
	Label1->SetBounds(nlib::Rect(256, 177, 313, 193));
	Label1->SetText(L"As String:");
	Label1->GetFont().SetFamily(L"Tahoma");
	Label1->GetFont().SetSize(10);
	Label1->SetParentFont(false);
	Label1->SetParent(this);

	edtChars = new nlib::Edit();
	edtChars->SetBounds(nlib::Rect(317, 176, 438, 197));
	edtChars->GetFont().SetFamily(L"Tahoma");
	edtChars->GetFont().SetSize(10);
	edtChars->SetParentFont(false);
	edtChars->SetTabOrder(5);
	edtChars->SetReadOnly(true);
	edtChars->SetParent(this);

	btnFont = new nlib::FlatButton();
	btnFont->SetBounds(nlib::Rect(440, 175, 508, 198));
	btnFont->SetText(L"&Font...");
	btnFont->GetFont().SetFamily(L"Tahoma");
	btnFont->GetFont().SetSize(10);
	btnFont->SetParentFont(false);
	btnFont->SetTabOrder(6);
	btnFont->SetAcceptInput(true);
	btnFont->SetFlat(false);
	btnFont->SetParent(this);

	btnCloseDecOptions = new nlib::FlatButton();
	btnCloseDecOptions->SetBounds(nlib::Rect(14, 175, 242, 187));
	btnCloseDecOptions->SetText(L"-------------------------------------------");
	btnCloseDecOptions->GetFont().SetFamily(L"Tahoma");
	btnCloseDecOptions->GetFont().SetSize(10);
	btnCloseDecOptions->SetParentFont(false);
	btnCloseDecOptions->SetTabOrder(7);
	btnCloseDecOptions->SetParent(this);

	btnCloseHexOptions = new nlib::FlatButton();
	btnCloseHexOptions->SetBounds(nlib::Rect(14, 279, 242, 291));
	btnCloseHexOptions->SetText(L"-------------------------------------------");
	btnCloseHexOptions->GetFont().SetFamily(L"Tahoma");
	btnCloseHexOptions->GetFont().SetSize(10);
	btnCloseHexOptions->SetParentFont(false);
	btnCloseHexOptions->SetTabOrder(8);
	btnCloseHexOptions->SetParent(this);

	SetActiveControl(edtInfix);
	SetMenu(mnuMain);
	btnOpenHexOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28672)));
	btnOpenDecOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28673)));
	tbExit->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28674)));
	tbHistory->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28675)));
	tbCopy->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28676)));
	tbPaste->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28677)));
	pnlDec->SetPopupMenu(pmCopy);
	pnlHex->SetPopupMenu(pmCopy);
	pnlOct->SetPopupMenu(pmCopy);
	pnlBin->SetPopupMenu(pmCopy);
	UpDown1->SetAttachedEditor(spnDecDigits);
	btnFont->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28678)));
	btnFont->Image()->SetStateCount(2);
	btnCloseDecOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28679)));
	btnCloseHexOptions->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28680)));

	OnStartSizeMove = CreateEvent(this, &TfrmMain::StartMove);
	OnMove = CreateEvent(this, &TfrmMain::FormMove);
	OnClose = CreateEvent(this, &TfrmMain::FormClose);
	miCopyDec->OnClick = CreateEvent(this, &TfrmMain::miCopyDecClick);
	miCopyHex->OnClick = CreateEvent(this, &TfrmMain::miCopyHexClick);
	miCopyOct->OnClick = CreateEvent(this, &TfrmMain::miCopyOctClick);
	miCopyBin->OnClick = CreateEvent(this, &TfrmMain::miCopyBinClick);
	miCopyText->OnClick = CreateEvent(this, &TfrmMain::miCopyClick);
	miExit->OnClick = CreateEvent(this, &TfrmMain::miExitClick);
	miCopy->OnClick = CreateEvent(this, &TfrmMain::miCopyClick);
	miPaste->OnClick = CreateEvent(this, &TfrmMain::miPasteClick);
	miAppend->OnClick = CreateEvent(this, &TfrmMain::miAppendClick);
	miCopyDecimal->OnClick = CreateEvent(this, &TfrmMain::miCopyDecClick);
	miCopyHexadecimal->OnClick = CreateEvent(this, &TfrmMain::miCopyHexClick);
	miCopyOctal->OnClick = CreateEvent(this, &TfrmMain::miCopyOctClick);
	miCopyBinary->OnClick = CreateEvent(this, &TfrmMain::miCopyBinClick);
	miEditVars->OnClick = CreateEvent(this, &TfrmMain::miEditVarsClick);
	miEditFuncs->OnClick = CreateEvent(this, &TfrmMain::miEditFuncsClick);
	miShowHist->OnClick = CreateEvent(this, &TfrmMain::miShowHistClick);
	miClearHist->OnClick = CreateEvent(this, &TfrmMain::miClearHistClick);
	miShowDecOpts->OnClick = CreateEvent(this, &TfrmMain::miShowDecOptsClick);
	miShowHexOpts->OnClick = CreateEvent(this, &TfrmMain::miShowHexOptsClick);
	miCharFont->OnClick = CreateEvent(this, &TfrmMain::miCharFontClick);
	miHistOpts->OnClick = CreateEvent(this, &TfrmMain::miHistOptsClick);
	miAbout->OnClick = CreateEvent(this, &TfrmMain::miAboutClick);
	miGenHelp->OnClick = CreateEvent(this, &TfrmMain::miGenHelpClick);
	btnOpenHexOptions->OnClick = CreateEvent(this, &TfrmMain::btnOpenHexOptionsClick);
	btnOpenDecOptions->OnClick = CreateEvent(this, &TfrmMain::btnOpenDecOptionsClick);
	tbExit->OnClick = CreateEvent(this, &TfrmMain::tbExitClick);
	tbHistory->OnClick = CreateEvent(this, &TfrmMain::tbHistoryClick);
	tbCopy->OnClick = CreateEvent(this, &TfrmMain::tbCopyClick);
	tbPaste->OnClick = CreateEvent(this, &TfrmMain::tbPasteClick);
	edtInfix->OnKeyDown = CreateEvent(this, &TfrmMain::edtInfixKeyDown);
	edtInfix->OnTextChanged = CreateEvent(this, &TfrmMain::edtInfixTextChanged);
	btnDecimal->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnHexadecimal->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnOctal->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	btnBinary->OnClick = CreateEvent(this, &TfrmMain::btnCopyFormatClick);
	pnlDec->OnPaint = CreateEvent(this, &TfrmMain::pnlDecPaint);
	chkSep->OnClick = CreateEvent(this, &TfrmMain::chkSepClick);
	cbThousandSep->OnChanged = CreateEvent(this, &TfrmMain::cbThousandSepChanged);
	chkSci->OnClick = CreateEvent(this, &TfrmMain::chkSciClick);
	chkEng->OnClick = CreateEvent(this, &TfrmMain::chkSciClick);
	chkDecDigits->OnClick = CreateEvent(this, &TfrmMain::chkDecDigitsClick);
	spnDecDigits->OnTextChanged = CreateEvent(this, &TfrmMain::spnDecDigitsTextChanged);
	rdDeg->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdGrad->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdRad->OnClick = CreateEvent(this, &TfrmMain::rdDegClick);
	rdNormal->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdHtml->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdTex->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	rdNone->OnClick = CreateEvent(this, &TfrmMain::rdNormalClick);
	chkMinus->OnClick = CreateEvent(this, &TfrmMain::chkMinusClick);
	chkLittleEndian->OnClick = CreateEvent(this, &TfrmMain::chkLittleEndianClick);
	chkBytes->OnClick = CreateEvent(this, &TfrmMain::chkAsBytesClick);
	chkWords->OnClick = CreateEvent(this, &TfrmMain::chkAsWordsClick);
	chkDWords->OnClick = CreateEvent(this, &TfrmMain::chkAsDWordsClick);
	chkSingle->OnClick = CreateEvent(this, &TfrmMain::chkSingleClick);
	chkDouble->OnClick = CreateEvent(this, &TfrmMain::chkDoubleClick);
	cbInfix->OnKeyPress = CreateEvent(this, &TfrmMain::cbInfixKeyPress);
	cbInfix->OnChanged = CreateEvent(this, &TfrmMain::cbInfixTextChanged);
	btnFont->OnClick = CreateEvent(this, &TfrmMain::btnFontClick);
	btnCloseDecOptions->OnClick = CreateEvent(this, &TfrmMain::btnCloseDecOptionsClick);
	btnCloseHexOptions->OnClick = CreateEvent(this, &TfrmMain::btnCloseHexOptionsClick);
}


// for fun
	vector<MONITORINFOEX> monitors;
// callback function called by EnumDisplayMonitors for each enabled monitor 
BOOL CALLBACK EnumDispProc(HMONITOR hMon, HDC dcMon, RECT* pRcMon, LPARAM lParam) 
{ 
	MONITORINFOEX mi;
	mi.cbSize = sizeof(MONITORINFOEX);
	if( GetMonitorInfo(hMon, &mi) )
		monitors.push_back(mi);

	return TRUE;	// continue enum
} 
// /for fun
TfrmMain::TfrmMain()
{
	InitializeFormAndControls();

	//----- SA -------------------
	// for fun
	EnumDisplayMonitors(0, 0, EnumDispProc, 0); 	// get all monitors
	// get virtual window size
	RECT r = {0};
//	r.left = r.right=r.top=r.bottom = 0'
	for(size_t i = 0; i < monitors.size(); ++i)
	{
		if(monitors[i].rcMonitor.left < r.left)
			r.left = monitors[i].rcMonitor.left;
		if(monitors[i].rcMonitor.top < r.top)
			r.top = monitors[i].rcMonitor.top;
		if(monitors[i].rcMonitor.bottom > r.bottom)
			r.bottom = monitors[i].rcMonitor.bottom;
		if(monitors[i].rcMonitor.right > r.right)
			r.right = monitors[i].rcMonitor.right;
	}	
	if(Left() > r.right || Top() > r.bottom || Bottom() < r.top || Right() < r.left)
	{
		SetLeft( ((r.right-r.left)-Width())/2);
		SetTop( ((r.bottom-r.top)-Height())/2);
	}
	// /for fun
	coMoveDX = coMoveDY = 0;
	bAutoSave = false;
    lengine = new littlecalc::LittleEngine;
    lengine->ReadTables(AppendToPath((wstring &)ExecutablePath, LITTLECALC_DAT_FILE).c_str());
	// add the clipboard and set this window as a "viewer"
	MyClipboard = new Clipboard();	   // messages arrive after
	MyClipboard->Activate( Handle() ); // Handle() is called first

    chkArr[0] = chkMinus;
    chkArr[1] = chkBytes;
    chkArr[2] = chkWords;
    chkArr[3] = chkDWords;
    chkArr[4] = chkSingle;
    chkArr[5] = chkDouble;
    chkArr[6] = chkLittleEndian;

    nDecOptTop = pnlDecOpt->Top();
    nHexBtnTop = btnOpenHexOptions->Top();
    busy = false;

    // ?? spnDecDigits->SetValue(20);
    slHistory = new TStringList;
    slHistory->SetCaseSensitive(false);
    slHistory->SetDuplicates(true);  // no duplicates
    slHistory->SetSorted(false);
//    if(FileExists(LITTLECALC_HIST_FILE) )
    slHistory->LoadFromFile(AppendToPath((wstring&)ExecutablePath, LITTLECALC_HIST_FILE).c_str());
    watchdog = 0;
    watchLimit = 5; // seconds	 
	maxHistDepth=0; // unlimited

    if(!LoadState(AppendToPath((wstring&)ExecutablePath, LITTLECALC_CFG_FILE).c_str()))
    {
        ShowDecOptions(false);
        ShowHexOptions(false);
    }

    added = false;

}
LRESULT TfrmMain::WindowProc(UINT msg, WPARAM w,LPARAM l)
{
	switch(msg)
	{
		case  WM_TIMER:
			    if(bAutoSave && ++watchdog >= watchLimit && lengine->ResultOk() && !added && !edtInfix->Text().empty())
					    AddToHistory(edtInfix->Text());
				break;
		case WM_CHANGECBCHAIN: 
				// If the next clipboard viwer window is closing, repair the chain. 
				// Otherwise, pass the message to the next link. 
				MyClipboard->ChangeNextViewer((HWND) w, (HWND) l);
				break;
		case WM_DRAWCLIPBOARD:
				// if the content of the clipboard has been changed
				// enable or disable paste menu and button
			   {
					bool enable = IsClipboardFormatAvailable(CF_UNICODETEXT) || IsClipboardFormatAvailable(CF_TEXT);
					miPaste->SetEnabled(enable);
					tbPaste->SetEnabled(enable);
			   }
				// and pass the message on
				MyClipboard->Forward( msg, w, l); 				
				break;

		default: return Form::WindowProc(msg,w,l);
	}
	return 0;
}
TfrmMain::~TfrmMain()
{
	/* Don't 'delete' the form. Call Destroy() instead which has access to the protected destructor. */
	delete 	MyClipboard;
}

void TfrmMain::Destroy()
{
	lengine->SaveTables();
    SaveState(AppendToPath((wstring&)ExecutablePath, LITTLECALC_CFG_FILE).c_str());
    slHistory->SaveToFile(AppendToPath((wstring&)ExecutablePath, LITTLECALC_HIST_FILE).c_str());
    delete slHistory;
    delete lengine;
	Form::Destroy();
}

void TfrmMain::btnFontClick(void *sender, nlib::EventParameters param)
{
	FontDialog1->SetFont( edtChars->GetFont());
	if(FontDialog1->Show(this))
	{
		edtChars->SetFont(FontDialog1->GetFont());
	}
}

void TfrmMain::edtInfixKeyDown(void *sender, nlib::KeyParameters param)
{
    watchdog = 0;   // reset counter
	if(edtInfix->Text().empty())
        return;

    if(param.keycode == VK_RETURN)
        AddToHistory(edtInfix->Text());
    else if(param.keycode != VK_RIGHT && param.keycode != VK_LEFT && param.keycode != VK_UP && param.keycode != VK_DOWN &&
            param.keycode != VK_TAB)
    {
		if(param.keycode != 17 || !param.vkeys.contains(vksCtrl))  // 17 - Ctrl-H
                added = false;
    }
}

void TfrmMain::pnlDecPaint(void *sender, nlib::PaintParameters param)
{
	sa::GraphicText gtDec;
	Canvas *pCanvas = pnlDec->GetCanvas();
	pCanvas->FillRect(1,1,pnlDec->Width()-4, pnlDec->Height()-1);
	if(pnlDec->Text().empty() )
		return;

	gtDec.SetCanvas(  pCanvas );
	gtDec.SetText(pnlDec->Text(), 0, lengine->displayFormat.expFormat == ExpFormat::rnsfE);
	int y = (pnlDec->Height() - gtDec.Box().Height())/2 - gtDec.Box().TopLeft().y;
	if(y < 0)
		y = 0;
	gtDec.Draw(pnlDec->Width() - gtDec.Box().Width()-4, y);
}

void TfrmMain::ShowResults()	// from lengine
{
    if(edtInfix->Text().empty())
    {
		ShowMessageOnAllPanels(L"");
        return;
    }
    if(_resType== littlecalc::rtDefinition) // function definition?
    {
        ShowMessageOnAllPanels(L"Definition");
        return;
    }
    else if(_resType == littlecalc::rtInvalid)
    {
		ShowMessageOnAllPanels(L"???");
        return;
    }

	pnlDec->SetText(lengine->ResultAsDecString());
	pnlDec->Invalidate();
    pnlHex->SetText(lengine->ResultAsHexString());
    pnlOct->SetText(lengine->ResultAsOctString());
    pnlBin->SetText(lengine->ResultAsBinString());
    edtChars->SetText(lengine->ResultAsCharString());
}

// display same message in all panels
void TfrmMain::ShowMessageOnAllPanels(wstring s)
{
    pnlDec->SetText(s);
	pnlDec->Invalidate();

    pnlHex->SetText(s);
    pnlOct->SetText(s);
    pnlBin->SetText(s);
    edtChars->SetText(L"");
}

void TfrmMain::edtInfixTextChanged(void *sender, nlib::EventParameters param)
{
	if (busy)
		return;

	if(edtInfix->Text().empty() )
    {
        ShowMessageOnAllPanels(L"");
        return;
    }
    wstring s = edtInfix->Text();
	cbInfix->SetText(s);
    try
    {
        ci.infix = s;
        long double res = lengine->Calculate(ci);
        gbResults->SetText(L"Results");
        ShowResults();
        s = lengine->Postfix();
    }
    catch(wstring s)
    {
        gbResults->SetText(s);
        ShowMessageOnAllPanels(L"???");
    }
    catch(...)
    {
        ShowMessageOnAllPanels(L"???");
    }
	busy = false;
}

void TfrmMain::rdDegClick(void *sender, nlib::EventParameters param)
{
	ci.au = (ANGLE_UNIT)((Radiobox*)sender)->Tag();
	edtInfixTextChanged(sender,param);
}

void TfrmMain::spnDecDigitsTextChanged(void *sender, nlib::EventParameters param)
{
    sres.num_digits = UpDown1->Position();
    ShowResults();
}

void TfrmMain::tbCopyClick(void *sender, nlib::EventParameters param)
{
    miCopyClick(sender,param);
}

void TfrmMain::tbExitClick(void *sender, nlib::EventParameters param)
{
	Close();
}

void TfrmMain::tbHistoryClick(void *sender, nlib::EventParameters param)
{
	miShowHistClick(sender,param);
}

void TfrmMain::tbPasteClick(void *sender, nlib::EventParameters param)
{
	miPasteClick(sender,param);
}

void TfrmMain::chkDecDigitsClick(void *sender, nlib::EventParameters param)
{
    if(chkDecDigits->Checked() )
    {
        spnDecDigits->SetEnabled(true);
		sres.num_digits = UpDown1->Position();
    }
    else
    {
        spnDecDigits->SetEnabled(false);
        sres.num_digits = -1;
    }
    ShowResults();
}

void TfrmMain::chkMinusClick(void *sender, nlib::EventParameters param)
{
	sres.hexSign = chkMinus->Checked();
	ShowResults();
}

void TfrmMain::chkSciClick(void *sender, nlib::EventParameters param)
{
  if(busy)
    return;
  busy = true;
  Checkbox *ps = ((Checkbox*)sender),
            *pd = (ps == chkSci ? chkEng : chkSci);
  DEC_FORM df = (ps == chkSci ? dfSci : dfEng);
  sres.decFormat = ps->Checked() ? df : dfGeneral;
  pd->SetChecked(false);
    ShowResults();
  busy = false;
}

void TfrmMain::chkSepClick(void *sender, nlib::EventParameters param)
{
    bool b = chkSep->Checked();
    cbThousandSep->SetEnabled(b);
    if(b && cbThousandSep->ItemIndex() >= 0)
    {
        sres.chThousandSep =  (cbThousandSep->ItemIndex() > 0 ? cbThousandSep->Text()[0] : ' ');
		                     // UNicodestring index 1 based?
		//sres.chThousandSep =  (cbThousandSep->ItemIndex() > 0 ? cbThousandSep->Text()[1] : (cbThousandSep->ItemIndex() == 0 ? ' ' : 0));
    }
    else
        sres.chThousandSep = 0;
    ShowResults();
}

void TfrmMain::miExitClick(void *sender, nlib::EventParameters param)
{
	Close();
}

void TfrmMain::miCopyClick(void *sender, nlib::EventParameters param)
{
    if(edtInfix->SelLength())
        MyClipboard->SetText(edtInfix->SelText());
    else
        MyClipboard->SetText( edtInfix->Text());
}

void TfrmMain::miPasteClick(void *sender, nlib::EventParameters param)
{
    edtInfix->SetText(edtInfix->Text().substr(0, edtInfix->SelStart()) +
			MyClipboard->GetText() + edtInfix->Text().substr(edtInfix->SelStart(),999));
}

void TfrmMain::miAppendClick(void *sender, nlib::EventParameters param)
{
    edtInfix->SetText( edtInfix->Text() + MyClipboard->GetText());
}

void TfrmMain::miEditVarsClick(void *sender, nlib::EventParameters param)
{
    VARFUNC_INFO vf;
    lengine->GetVarFuncInfo(vf);

    if(!frmVariables)
	{
        frmVariables = new TfrmVariables;
		frmVariables->SetTopLevelParent(this);
	}
    else
    {
        frmVariables->tcVars->SetSelectedTab( ((MenuItem*)sender)->Tag());
		TabChangeParameters par(((MenuItem*)sender)->Tag());
        frmVariables->tcVarsTabChange(sender, par);
        frmVariables->Show();
        return;
    }
    frmVariables->Setup(vf);
    frmVariables->tcVars->SetSelectedTab( ((MenuItem*)sender)->Tag());
    frmVariables->Show();
}

void TfrmMain::miEditFuncsClick(void *sender, nlib::EventParameters param)
{
	miEditVarsClick(sender, param);
}

// TASK: to show history window below, stacked above or beside main window
// EPECTS:
// RETURNS: nothing
// REMARKS: sets position and size of history window
void TfrmMain::miShowHistClick(void *sender, nlib::EventParameters param)
{
	if(frmHistory)		// already set
	{
		frmHistory->Show();
			return;
	}
	frmHistory = new TfrmHistory;
	frmHistory->SetTopLevelParent(this);
    frmHistory->SetLeft(Left());
    frmHistory->chkSorted->SetChecked(slHistory->Sorted());
	frmHistory->Snap(0);	// unconditional snap to any side
	frmHistory->lstHistory->Items().SetLines(slHistory->Lines());
	frmHistory->Show();
}

void TfrmMain::miClearHistClick(void *sender, nlib::EventParameters param)
{
    slHistory->Clear();
	if(frmHistory)
		frmHistory->lstHistory->Clear();
}

void TfrmMain::miShowDecOptsClick(void *sender, nlib::EventParameters param)
{
	ShowDecOptions(!pnlDecOpt->Visible());
}

void TfrmMain::miShowHexOptsClick(void *sender, nlib::EventParameters param)
{
	ShowHexOptions(!pnlHexOpt->Visible());
}

void TfrmMain::miHistOptsClick(void *sender, nlib::EventParameters param)
{
	frmHistOptions = new TfrmHistOptions;
	frmHistOptions->SetTopLevelParent(this);
    frmHistOptions->Setup(maxHistDepth, watchLimit, slHistory->Sorted() );

	if(frmHistOptions->ShowModal() == mrOk)
    {
        if(frmHistOptions->chkDepth->Checked())
        {
            maxHistDepth = frmHistOptions->spinDepthBtn->Position();
			slHistory->SetCapacity(maxHistDepth);
			if(frmHistory)
				frmHistory->lstHistory->Items().SetLines(slHistory->Lines());
        }
        if(frmHistOptions->chkAutoSave->Checked())
        {
			wstring str = frmHistOptions->edtInterval->Text();
			int h = 0, m = 0, s = 0;
			int n = swscanf(str.c_str(), L"%d:%d:%d", &h, &m, &s);
			if(n != 3)
			{
				s = m;
				m = h;
				h = 0;
				if(n != 2)
				{
					s = m;
					m = 0;;
				}
			}
            watchLimit = h*3600 + m*60 + s;
        }
        else
        {
            watchLimit = 0;
        }
        // Timer1->Enabled = watchLimit > 0;
		EnableMyTimer(watchLimit > 0);
        slHistory->SetSorted(frmHistOptions->chkSort->Checked(),true);	// first (last entered) line is not sorted
        if(frmHistory)
            frmHistory->lstHistory->Items().SetLines(slHistory->Lines());

    }
	frmHistOptions->Destroy();
	frmHistOptions = NULL;
}

void TfrmMain::miAboutClick(void *sender, nlib::EventParameters param)
{
	frmAbout = new TfrmAbout;
	frmAbout ->SetTopLevelParent(this);
	frmAbout ->ShowModal();
	frmAbout->Destroy();
}

void TfrmMain::miGenHelpClick(void *sender, nlib::EventParameters param)
{
	frmHelp = new TfrmHelp;
	frmHelp ->SetTopLevelParent(this);
	frmHelp ->ShowModal();
	frmHelp->Destroy();
}

void TfrmMain::miCharFontClick(void *sender, nlib::EventParameters param)
{
	btnFont->Click();
}

void TfrmMain::miCopyDecClick(void *sender, nlib::EventParameters param)
{
	wstring ws = pnlDec->Text();	// reformat for 'normal' number
	int pos;
	if( (pos = ws.find_first_of(_CHART(183)) ) != wstring::npos)
		ws = ws.substr(0,pos) + _CHART('e') + ws.substr(pos+5, ws.length()-pos-5-1);
	MyClipboard->SetText(ws );
}

void TfrmMain::miCopyHexClick(void *sender, nlib::EventParameters param)
{
	MyClipboard->SetText(pnlHex->Text() );
}

void TfrmMain::miCopyOctClick(void *sender, nlib::EventParameters param)
{
	MyClipboard->SetText(pnlOct->Text() );
}

void TfrmMain::miCopyBinClick(void *sender, nlib::EventParameters param)
{
	MyClipboard->SetText(pnlBin->Text() );
}
void TfrmMain::cbThousandSepChanged(void *sender, nlib::EventParameters param)
{
	sres.chThousandSep =  cbThousandSep->Text()[0]; 
	if(sres.chThousandSep == L's')
		sres.chThousandSep = ' ';
	ShowResults();
}

void TfrmMain::ShowDecOptions(bool show)
{
    if(pnlDecOpt->Visible() == show)
        return;
    miShowDecOpts->SetChecked(show);
    if(show)
    {
        SetHeight( Height() + pnlDecOpt->Height());
        btnOpenHexOptions->SetTop(nHexBtnTop);
            // although this is common for both show and not show
            // if this is set AFTER 'pnlDecOpt' is shown the
            // btnCloseHexOptions remains on the screen over the panel in XE
        btnCloseHexOptions->SetTop(btnOpenHexOptions->Top());

        pnlDecOpt->SetTop(nDecOptTop);
    }
    else
    {
// DEBUG 2 lines
// int hp = pnlDecOpt->Height(),
// h = Height();
        SetHeight(Height() - pnlDecOpt->Height());
// h = Height(); // DEBUG
        btnOpenHexOptions->SetTop(nDecOptTop);
        btnCloseHexOptions->SetTop(btnOpenHexOptions->Top());
    }
    pnlDecOpt->SetVisible(show);
    pnlHexOpt->SetTop( btnOpenHexOptions->Top() + btnOpenHexOptions->Height()+2);
    btnOpenDecOptions->SetVisible(!show);
    btnCloseDecOptions->SetVisible(show);
}

//---------------------------------------------------------------------------
void TfrmMain::ShowHexOptions(bool show)
{
    if(pnlHexOpt->Visible() == show)
        return;
    miShowHexOpts->SetChecked(show);
    int h = pnlHexOpt->Height()-5;
    if(!show)
        h = -h;
// DEBUG
//int hh = Height();
    SetHeight(Height() + h);
//hh = Height();
    pnlDecOpt->SetTop(nDecOptTop);

    pnlHexOpt->SetVisible(show);
    btnOpenHexOptions->SetVisible(!show);
    btnCloseHexOptions->SetVisible(show);
}

void TfrmMain::btnCloseDecOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowDecOptions(false);
}

void TfrmMain::btnCloseHexOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowHexOptions(false);
}

void TfrmMain::btnOpenDecOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowDecOptions(true);
}

void TfrmMain::btnOpenHexOptionsClick(void *sender, nlib::EventParameters param)
{
     ShowHexOptions(true);
}

// SA 
void TfrmMain::EnableMyTimer(bool enable)
{
	if(bAutoSave == enable)
		return;
	if(enable)
		SetTimer(Handle(), (UINT_PTR)0x12, 1000, 0); // Timer1
	else
		KillTimer(Handle(),(UINT_PTR)0x12);
	bAutoSave = enable;
}

bool TfrmMain::SaveState(wstring name)
{
#if 1
	FileStream fs(name,ios_base::out);

     if(fs.fail())
        return false;
    fs << "FalconCalc State File V1.0\n";
	fs << "decFormat="<< (int)sres.decFormat << "|" << (int)sres.mode << "\n";
    fs << "hexFormat="<< (int)sres.hexFormat << "|"<< (int)sres.endian << "|"<< (int)sres.hexSign<<"\n";
	int u = UpDown1->Position() + (chkDecDigits->Checked() ? 0x100 : 0); // 0x100: checked state. must use Position as num_digits may be -1
    fs << "showAs=" << (int)sres.showAs << "|"<< u << "|"<< (unsigned int)sres.chThousandSep << "|"<< (int)ci.au << "\n";
	fs << "strFont="<< edtChars->GetFont().Family() << "\n";
	fs << "fontDat=" << (int)edtChars->GetFont().Size() << "|"<< (int)edtChars->GetFont().CharacterSet() << "|"<< (COLORREF)edtChars->GetFont().GetColor() << "\n";
    fs << "options=" << pnlDecOpt->Visible() << "|"<< pnlHexOpt->Visible()<<"\n";
    fs << "hopt=" << watchLimit << "|"<< maxHistDepth << "|"<<slHistory->Sorted() << "\n";
    if(!edtInfix->Text().empty())
        fs << "last=" <<  edtInfix->Text() << "\n";
#endif
    return true;
}

bool TfrmMain::LoadState(wstring name)
{
#if 1
	FileStream fs(name,ios_base::in);
    if(fs.fail())
        return false;
    STRING_RESULT res;
    littlecalc::CALC_INPUT inp;
	wstring s;
	wchar_t wbuf[1024], nam[1024];
	fs.getline(wbuf,1023);
	
    if(wcscmp(wbuf, L"FalconCalc State File V1.0"))
        goto E1;
    int n;
    int i1,i2,i3;
    unsigned int u1;//,u2,u3;
    long l1;

    fs.getline(wbuf,1023);
	n = swscanf(wbuf, L"decFormat=%d|%d\n", &i1, &i2);
    if(!n)
        goto E1;
    res.decFormat = (DEC_FORM)i1;
	if(n == 2)
	{
		res.mode = (BEATUFY_MODE)i2;
		switch(res.mode)
		{
			case bmoGraphText : rdNormal->SetChecked(true); break;
			case bmoHtml :		rdHtml->SetChecked(true); break;
			case bmoTEX :		rdTex->SetChecked(true); break;
			default:			rdNone->SetChecked(true); break;
		};
	}
	res.type = res.mode == bmoNone ? stDecimal : stDecBeautified;

    fs.getline( wbuf, 1023);
    n = swscanf(wbuf, L"hexFormat=%d|%d|%d\n", &i1,&i2,&i3);
    if(n != 3)
        goto E1;
    res.hexFormat = (HEX_FORM)i1;
    res.endian    = (HEX_ENDIAN)i2;
    res.hexSign   = i3 != 0;

    fs.getline( wbuf, 1023);
    n = swscanf(wbuf, L"showAs=%d|%d|%u|%d\n", &i1,&i2,&u1,&i3);
    if(n != 4)
        goto E1;
    res.showAs    = (SHOW_HEX_AS)i1;
    chkDecDigits->SetChecked( (i2 & 0x100)  != 0); // changes num_digits!
    res.num_digits = i2 & 0xFF;				// keep sign in 'res'
    res.chThousandSep=(_CHART)u1;
	if(res.chThousandSep == L's')
		res.chThousandSep = L' ';
    inp.au        = (ANGLE_UNIT)i3;

    fs.getline( wbuf, 1023);
            // this is tricky because of possible spaces in font name
    int len;
    if(wcsncmp(wbuf, L"strFont=",8) || (len = wcslen(wbuf+8)) <= 0)
        goto E1;
    wcsncpy(nam, wbuf+8, len);
    nam[len] = 0;
    edtChars->GetFont().SetFamily(nam);

    fs.getline( wbuf, 1023);
    n = swscanf(wbuf, L"fontDat=%d|%u|%ld\n",&i1,&u1,&l1);
    if(n == 3)
	{
	    edtChars->GetFont().SetSize((float)i1);
		edtChars->GetFont().SetCharacterSet((FontCharacterSets)u1);
		edtChars->GetFont().SetColor((COLORREF)l1);
	}

    sres = res;
// MARK	if(sres.num_digits < 0) sres.num_digits = -sres.num_digits;
    ci = inp;

    // set visual, Order IMPORTANT!
    busy = true;
    chkSep->SetChecked( sres.chThousandSep != 0);
    cbThousandSep->SetEnabled( sres.chThousandSep != 0);
    chkSci->SetChecked( sres.decFormat == dfSci);
    chkEng->SetChecked( sres.decFormat == dfEng);
	UpDown1->SetPosition( sres.num_digits); // will be increased in next call
	EventParameters param;
	chkDecDigitsClick(this, param);
    chkBytes->SetChecked( sres.showAs == shaBytes);
    chkWords->SetChecked( sres.showAs == shaWords);
    chkDWords->SetChecked( sres.showAs == shaDWords);
    chkLittleEndian->SetChecked( sres.endian == heLittle);
    chkLittleEndian->SetEnabled( sres.showAs != shaNormal);
    chkSingle->SetChecked( sres.hexFormat == hfSingle);
    chkDouble->SetChecked( sres.hexFormat == hfDouble);
    chkMinus->SetChecked( sres.hexSign);
#if 1
	switch((int)ci.au)
	{
		case 0: rdDeg->SetChecked(true); break;
		case 1: rdGrad->SetChecked(true); break;
		default: rdRad->SetChecked(true); break;
	}    
#endif
    busy = false;

    fs.getline( wbuf, 1023);
    n = swscanf(wbuf, L"options=%d|%d\n", &i1, &i2);
    if(n != 2)
        goto E1;

    fs.getline( wbuf, 1023);
    int wl,mhd,hs;
    n = swscanf(wbuf, L"hopt=%d|%d|%d\n", &wl, &mhd, &hs);
    if(n != 3)
        goto E1;

	// Timer1->Enabled = (watchLimit = wl) != 0;
	EnableMyTimer((watchLimit = wl) != 0);

    maxHistDepth = mhd;
	slHistory->SetCapacity(mhd);
    slHistory->SetSorted(hs!=0, true);	// keep first line unsorted
        // need to be here otherwise in case of error the window would be too small
    ShowDecOptions(i1 != 0);
    ShowHexOptions(i2 != 0);

    if( fs.getline( wbuf, 1023)  && !wcsncmp(wbuf, L"last=", 5) )
    {
        edtInfix->SetText(wbuf+5);
    }
    return true;
E1:
#endif
    return false;
}
// Adds actual expression to history
// Always inserts line at first position (top of list)
// For sorted list it first inserts the original first line
// then insert the new at the top
// If the expression was already in the list deletes it first from the list
void TfrmMain::AddToHistory(wstring text)
{
    int n;
    if( (n = slHistory->IndexOf(text)) >= 0)
    {
        if(n == 0 && slHistory->Sorted())	// already at top
            return;							// nothing to do
        slHistory->Delete(n);				// not at top delete expression from inside
    }
	else if(slHistory->Sorted() )			// then must put original top line in correct position 
	{										// first and add the new line afterwards, because
		wstring ws = (*slHistory)[0];		// list may be truncated after adding a new line to it
		slHistory->Delete(0);				// delete original top line
		slHistory->Add(ws);					// and insert into string
	}
	
    slHistory->Insert(0, text);				// then insert new expression to top of list

    added = true;
    watchdog = 0;
    if(frmHistory != 0)
        frmHistory->lstHistory->Items().SetLines(slHistory->Lines());
}

littlecalc::LittleEngine *TfrmMain::Engine() const
{
    return lengine;
}

void TfrmMain::FormClose(void *sender, nlib::FormCloseParameters param)
{;
}

void TfrmMain::chkAsBytesClick(void *sender, nlib::EventParameters param)
{
	chkWords->SetChecked(false);
	chkDWords->SetChecked(false);
	if(chkBytes->Checked() )
		sres.showAs =  shaBytes;
	else
		sres.showAs = shaNormal;
	chkLittleEndian->SetEnabled( sres.showAs != shaNormal);
	ShowResults();
}

void TfrmMain::chkAsDWordsClick(void *sender, nlib::EventParameters param)
{
	chkWords->SetChecked(false);
	chkBytes->SetChecked(false);
	if(chkDWords->Checked() )
		sres.showAs =  shaDWords;
	else
		sres.showAs = shaNormal;
	chkLittleEndian->SetEnabled( sres.showAs != shaNormal);
	ShowResults();
}

void TfrmMain::chkAsWordsClick(void *sender, nlib::EventParameters param)
{
	chkBytes->SetChecked(false);
	chkDWords->SetChecked(false);
	if(chkWords->Checked() )
		sres.showAs =  shaWords;
	else
		sres.showAs = shaNormal;
	chkLittleEndian->SetEnabled( sres.showAs != shaNormal);
	ShowResults();
}

void TfrmMain::chkDoubleClick(void *sender, nlib::EventParameters param)
{
	chkSingle->SetChecked(false);
	sres.hexFormat =  chkDouble->Checked() ? hfDouble : hfNormal;
	ShowResults();
}

void TfrmMain::chkSingleClick(void *sender, nlib::EventParameters param)
{
	chkDouble->SetChecked(false);
	sres.hexFormat =  chkSingle->Checked() ? hfSingle : hfNormal;
	ShowResults();
}

void TfrmMain::chkLittleEndianClick(void *sender, nlib::EventParameters param)
{
	sres.endian =  chkLittleEndian->Checked() ? heLittle : heBig;
	ShowResults();
}

void TfrmMain::btnCopyFormatClick(void *sender, nlib::EventParameters param)
{
	Button *pb = reinterpret_cast<Button*>(sender);
	switch (pb->Tag())
	{
		case 0: miCopyDecClick(sender, param); break;
		case 1: MyClipboard->SetText(pnlHex->Text() ); break;
		case 2: MyClipboard->SetText(pnlOct->Text() ); break;
		case 3: MyClipboard->SetText(pnlBin->Text() ); break;
	}
}

void TfrmMain::StartMove(void *sender, nlib::EventParameters param)
{
		// only use it for move and not for resize
	if(frmHistory && frmHistory->InsideSnapAreaFromMain(10) )	// then move it together
	{
		coMoveDX = (frmHistory->Left() - Left());
		coMoveDY = (frmHistory->Top()- Top());
	}
	else
		coMoveDX = coMoveDY = 0;
}

void TfrmMain::FormMove(void *sender, nlib::EventParameters param)
{
	if(coMoveDX || coMoveDY)
	{
		frmHistory->SetTop( Top() + coMoveDY );
		frmHistory->SetLeft( Left() + coMoveDX);
	}
}

void TfrmMain::rdNormalClick(void *sender, nlib::EventParameters param)
{
	sres.mode = (BEATUFY_MODE)((Radiobox*)sender)->Tag();
	sres.type = sres.mode == bmoNone ? stDecimal : stDecBeautified;
	ShowResults();
}

void TfrmMain::cbInfixTextChanged(void *sender, nlib::EventParameters param)
{
	if (busy)
		return;

	busy = true;
	if (cbInfix->Text().empty())
	{
		sres.valid = rvInvalid;
		ShowResults(L"");
		return;
	}
	wstring s = cbInfix->Text();
	edtInfix->SetText(s);
	try
	{
		ci.infix = s;
		long double res = lengine->Calculate(ci);
		gbResults->SetText(L"Results");
		sres.valid = rvOk;
		ShowResults(res);
		s = lengine->Postfix();
	}
	catch (wstring s)
	{
		sres.valid = rvInvalid;
		gbResults->SetText(s);
		ShowResults(L"???");
	}
	catch (...)
	{
		sres.valid = rvInvalid;
		ShowResults(L"???");
	}
	busy = false;
}

void TfrmMain::cbInfixKeyPress(void *sender, nlib::KeyPressParameters param)
{
	;
}

