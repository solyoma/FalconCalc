
#include "StdAfx_zoli.h"
using namespace nlib;
#include "mainForm.h"
#include "TStringList.h"
#include "history.h"
#include "clipboard.h"

TfrmHistory *frmHistory;
extern Clipboard* MyClipboard;


void TfrmHistory::InitializeFormAndControls() /* Control initialization function generated by the designer. Modifications will be lost. */
{
	/* Generated member initialization. Do not modify. */
	SetLeft(1884);
	SetTop(1172);
	SetText(L"FalconCalc History");
	GetFont().SetFamily(L"Tahoma");
	SetWantedKeyTypes(nlib::wkArrows | nlib::wkTab | nlib::wkEnter | nlib::wkEscape | nlib::wkOthers);
	SetKeyPreview(true);
	SetClientRect(nlib::Rect(0, 0, 517, 183));

	lstHistory = new nlib::Listbox();
	lstHistory->SetBounds(nlib::Rect(8, 8, 429, 166));
	lstHistory->SetText(L"lstHistory");
	lstHistory->SetAnchors(nlib::caLeft | nlib::caTop | nlib::caRight | nlib::caBottom);
	lstHistory->SetTabOrder(0);
	lstHistory->SetItemHeight(14);
	lstHistory->SetParent(this);

	btnDelete = new nlib::FlatButton();
	btnDelete->SetBounds(nlib::Rect(434, 8, 457, 30));
	btnDelete->SetAnchors(nlib::caTop | nlib::caRight);
	btnDelete->SetTabOrder(1);
	btnDelete->SetImagePosition(nlib::bipCenter);
	btnDelete->SetFlat(false);
	btnDelete->SetParent(this);

	btnClear = new nlib::FlatButton();
	btnClear->SetBounds(nlib::Rect(434, 36, 457, 58));
	btnClear->SetAnchors(nlib::caTop | nlib::caRight);
	btnClear->SetTabOrder(2);
	btnClear->SetImagePosition(nlib::bipCenter);
	btnClear->SetFlat(false);
	btnClear->SetParent(this);

	chkSorted = new nlib::Checkbox();
	chkSorted->SetBounds(nlib::Rect(437, 104, 511, 120));
	chkSorted->SetText(L"&Sort");
	chkSorted->SetAnchors(nlib::caTop | nlib::caRight);
	chkSorted->SetTabOrder(3);
	chkSorted->SetParent(this);

	btnCancel = new nlib::Button();
	btnCancel->SetBounds(nlib::Rect(435, 145, 510, 168));
	btnCancel->SetText(L"&Dismiss");
	btnCancel->SetAnchors(nlib::caRight | nlib::caBottom);
	btnCancel->GetFont().SetFamily(L"Tahoma");
	btnCancel->GetFont().SetSize(10);
	btnCancel->GetFont().SetCharacterSet(nlib::fcsAnsi);
	btnCancel->GetFont().SetOutputQuality(nlib::foqDraft);
	btnCancel->SetParentFont(false);
	btnCancel->SetTabOrder(4);
	btnCancel->SetParent(this);

	btnDelete->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28681)));
	btnDelete->Image()->SetStateCount(2);
	btnClear->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28682)));

	OnKeyPress = CreateEvent(this, &TfrmHistory::FormKeyPress);
	OnMove = CreateEvent(this, &TfrmHistory::FormMove);
	OnClose = CreateEvent(this, &TfrmHistory::FormClose);
	lstHistory->OnDblClick = CreateEvent(this, &TfrmHistory::lstHistoryDblClick);
	btnDelete->OnClick = CreateEvent(this, &TfrmHistory::btnDeleteClick);
	btnClear->OnClick = CreateEvent(this, &TfrmHistory::btnClearClick);
	chkSorted->OnClick = CreateEvent(this, &TfrmHistory::chkSortClick);
	btnCancel->OnClick = CreateEvent(this, &TfrmHistory::btnCancelClick);
}

void TfrmHistory::Destroy()
{
	/* Controls are valid here, but not in the destructor. */
	/* ... Your code here ... */

	Form::Destroy();
}

TfrmHistory::TfrmHistory()
{
	InitializeFormAndControls();
}

TfrmHistory::~TfrmHistory()
{
	/* Don't 'delete' the form. Call Destroy() instead which has access to the protected destructor. */
	frmHistory = NULL;
}

void TfrmHistory::lstHistoryDblClick(void *sender, nlib::MouseButtonParameters param)
{
    if(lstHistory->ItemIndex() >= 0)
    {
        int n;
        if( (n = lstHistory->ItemIndex()) >= 0)
        {
            frmMain->edtInfix->SetText(lstHistory->Items().Text(n));
            frmMain->Focus();
        }
    }
}

void TfrmHistory::btnCancelClick(void *sender, nlib::EventParameters param)
{
	Close();
}

void TfrmHistory::btnClearClick(void *sender, nlib::EventParameters param)
{
    lstHistory->Clear();
    frmMain->pslHistory->Clear();
}

void TfrmHistory::btnDeleteClick(void *sender, nlib::EventParameters param)
{
    int n = lstHistory->ItemIndex();
    if(n >=0)
    {
		lstHistory->Items().Delete(n);
		frmMain->pslHistory->Delete(n);
    }
}


void TfrmHistory::FormKeyPress(void *sender, nlib::KeyPressParameters param)
{
    SmartString s;

	switch (param.key)
	{
		case '1': 
		case '2':
			if (param.vkeys & vksAlt)	// functions or variables
			{
				nlib::EventParameters par;
				frmMain->OpenVarsOrFunctions(nullptr, param.key - '0', par);
			}
			break;
		case 22:						// paste CTRL + V
			s = MyClipboard->GetText();		 // MyClipboard must exist!
			if(s.empty())
				break;
			frmMain->pslHistory->Add(s,true);
			lstHistory->Items().SetLines(frmMain->pslHistory->Lines());
			break;
		case 3:
			for(int i =0; i < lstHistory->Items().Count(); ++i)
				s += lstHistory->Items().Text(i) + L"\n";
			MyClipboard->SetText(s.ToWideString());
			break;
		case VK_RETURN:
			if(lstHistory->ItemIndex() >= 0)
			{
				int n;
				if( (n = lstHistory->ItemIndex()) >= 0)
				{
					frmMain->edtInfix->SetText(lstHistory->Items().Text(n)) ;
					frmMain->Focus();
				}
			}
		case VK_ESCAPE:
			Close();
			break;
		default:
			break;
	}
}

void TfrmHistory::FormClose(void *sender, nlib::FormCloseParameters param)
{
    param.action = caDeleteForm;
	frmHistory=NULL;
	SetFocus(frmMain->Handle());
}
void TfrmHistory::chkSortClick(void *sender, nlib::EventParameters param)
{
	;
}

void TfrmHistory::FormMove(void *sender, nlib::EventParameters param)
{
	if(!snapped)
		Snap(10);
}

int TfrmHistory::InsideSnapAreaFromMain(int dist)
{
	// determine snap area index
	//   0: none 1 top, 2 right, 3 bottom, 4 left
	RECT r;
	r.top = Top(); r.right = Right(); r.bottom = Bottom(); r.left = Left();
	return ::InsideSnapAreaFromMain(r, dist);
}

void TfrmHistory::Snap(int dist)
{
    RECT rsc,r; // rectangles for: screen size, temp
	if(!SystemParametersInfo(SPI_GETWORKAREA,0,&rsc,0) )
		return;

	int which;

	snapped = false;
	if(!dist)
	{
			// get correct window size
		r = frmMain->ClientRect();
		int captionHeight = frmMain->Height() - (r.bottom - r.top);	
		if( frmMain->Bottom() + captionHeight > rsc.bottom)	// then history window's title bar is obscured if put below main
			if(frmMain->Top() - Height() < rsc.top)		// then also obsured at above it too
				if(frmMain->Right() + captionHeight >= rsc.right)    // and also at right
					if(frmMain->Left() <= r.left)						// and even from left
						;                        // then let Windows choose the position
					else								// not obscured only when at left
					{
						SetTop(frmMain->Top());
						SetHeight(frmMain->Height());
						SetLeft(frmMain->Left() - Width());
					}
				else                             // not obscured at right
				{
					SetTop(frmMain->Top());
					SetHeight(frmMain->Height() );
					SetLeft(frmMain->Right());
				}
			else                                // show it above
			{
				SetTop (frmMain->Top() - Height());
				SetLeft(frmMain->Left());
				SetWidth(frmMain->Width());
			}
		else                                     // position below
		{
			SetTop(frmMain->Bottom());
			SetLeft(frmMain->Left());
			SetWidth(frmMain->Width());
		}
		snapped = true;
	}
	else if((which = InsideSnapAreaFromMain(dist)) != 0 )		 // snap to main if distance is smaller than 'dist'
	{
		switch(which)
		{
			case 0: return;						// not inside
			case 1: SetTop(frmMain->Top() - Height() );		// snap to top
					break;
			case 2: SetLeft(frmMain->Right() );				// to right
					break;
			case 3: SetTop(frmMain->Bottom() );				// to bottom
					break;
			case 4: SetLeft(frmMain->Left() - Width());		// to left
					break;
		}
		snapped = true;
	}
	frmMain->SetCoMovingCoordinates(!snapped);
}
