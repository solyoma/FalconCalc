
#include "StdAfx_zoli.h"
using namespace nlib;
#include "mainForm.h"
#include "TStringList.h"
#include "history.h"
#include "clipboard.h"

TfrmHistory *frmHistory;
extern Clipboard* MyClipboard;


void TfrmHistory::InitializeFormAndControls() /* Control initialization function generated by the designer. Modifications will be lost. */
{
	/* Generated member initialization. Do not modify. */
	SetLeft(462);
	SetTop(684);
	SetText(L"FalconCalc History");
	GetFont().SetFamily(L"Tahoma");
	SetWantedKeyTypes(nlib::wkArrows | nlib::wkTab | nlib::wkEnter | nlib::wkEscape | nlib::wkOthers);
	SetKeyPreview(true);
	SetClientRect(nlib::Rect(0, 0, 517, 183));

	lstHistory = new nlib::Listbox();
	lstHistory->SetBounds(nlib::Rect(8, 8, 429, 166));
	lstHistory->SetText(L"lstHistory");
	lstHistory->SetAnchors(nlib::caLeft | nlib::caTop | nlib::caRight | nlib::caBottom);
	lstHistory->SetTabOrder(0);
	lstHistory->SetItemHeight(14);
	lstHistory->SetParent(this);

	btnDelete = new nlib::FlatButton();
	btnDelete->SetBounds(nlib::Rect(434, 8, 457, 30));
	btnDelete->SetAnchors(nlib::caTop | nlib::caRight);
	btnDelete->SetTabOrder(1);
	btnDelete->SetImagePosition(nlib::bipCenter);
	btnDelete->SetFlat(false);
	btnDelete->SetParent(this);

	btnClear = new nlib::FlatButton();
	btnClear->SetBounds(nlib::Rect(434, 36, 457, 58));
	btnClear->SetAnchors(nlib::caTop | nlib::caRight);
	btnClear->SetTabOrder(2);
	btnClear->SetImagePosition(nlib::bipCenter);
	btnClear->SetFlat(false);
	btnClear->SetParent(this);

	chkSorted = new nlib::Checkbox();
	chkSorted->SetBounds(nlib::Rect(437, 104, 511, 120));
	chkSorted->SetText(L"&Sort");
	chkSorted->SetAnchors(nlib::caTop | nlib::caRight);
	chkSorted->SetTabOrder(3);
	chkSorted->SetParent(this);

	btnCancel = new nlib::Button();
	btnCancel->SetBounds(nlib::Rect(435, 145, 510, 168));
	btnCancel->SetText(L"&Dismiss");
	btnCancel->SetAnchors(nlib::caRight | nlib::caBottom);
	btnCancel->GetFont().SetFamily(L"Tahoma");
	btnCancel->GetFont().SetSize(10);
	btnCancel->GetFont().SetCharacterSet(nlib::fcsAnsi);
	btnCancel->GetFont().SetOutputQuality(nlib::foqDraft);
	btnCancel->SetParentFont(false);
	btnCancel->SetTabOrder(4);
	btnCancel->SetParent(this);

	btnDelete->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28681)));
	btnDelete->Image()->SetStateCount(2);
	btnClear->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28682)));

	OnKeyPress = CreateEvent(this, &TfrmHistory::FormKeyPress);
	OnMove = CreateEvent(this, &TfrmHistory::FormMove);
	OnClose = CreateEvent(this, &TfrmHistory::FormClose);
	lstHistory->OnDblClick = CreateEvent(this, &TfrmHistory::lstHistoryDblClick);
	btnDelete->OnClick = CreateEvent(this, &TfrmHistory::btnDeleteClick);
	btnClear->OnClick = CreateEvent(this, &TfrmHistory::btnClearClick);
	chkSorted->OnClick = CreateEvent(this, &TfrmHistory::chkSortClick);
	btnCancel->OnClick = CreateEvent(this, &TfrmHistory::btnCancelClick);
}

void TfrmHistory::Destroy()
{
	/* Controls are valid here, but not in the destructor. */
	/* ... Your code here ... */

	Form::Destroy();
}

TfrmHistory::TfrmHistory()
{
	InitializeFormAndControls();
	snapped = false;
}

TfrmHistory::~TfrmHistory()
{
	/* Don't 'delete' the form. Call Destroy() instead which has access to the protected destructor. */
	frmHistory = NULL;
}

void TfrmHistory::lstHistoryDblClick(void *sender, nlib::MouseButtonParameters param)
{
    if(lstHistory->ItemIndex() >= 0)
    {
        int n;
        if( (n = lstHistory->ItemIndex()) >= 0)
        {
            frmMain->edtInfix->SetText(lstHistory->Items().Text(n));
            frmMain->Focus();
        }
    }
}

void TfrmHistory::btnCancelClick(void *sender, nlib::EventParameters param)
{
	Close();
}

void TfrmHistory::btnClearClick(void *sender, nlib::EventParameters param)
{
    lstHistory->Clear();
    frmMain->slHistory->Clear();
}

void TfrmHistory::btnDeleteClick(void *sender, nlib::EventParameters param)
{
    int n = lstHistory->ItemIndex();
    if(n >=0)
    {
		lstHistory->Items().Delete(n);
		frmMain->slHistory->Delete(n);
    }
}


void TfrmHistory::FormKeyPress(void *sender, nlib::KeyPressParameters param)
{
    SmartString s;

    if(param.key == 22 )  // paste CTRL + V
    {
		s = MyClipboard->GetText();		 // MyClipboard must exist!
		if(s.empty())
			return;
		frmMain->slHistory->Add(s,true);
		lstHistory->Items().SetLines(frmMain->slHistory->Lines());
    }
    else if(param.key == 3)       // copy: Ctrl + C
    {
		for(int i =0; i < lstHistory->Items().Count(); ++i)
			s += lstHistory->Items().Text(i) + L"\n";
		MyClipboard->SetText(s.ToWideString());
    }
    else if(param.key == VK_RETURN && lstHistory->ItemIndex() >= 0)
    {
        int n;
        if( (n = lstHistory->ItemIndex()) >= 0)
        {
			frmMain->edtInfix->SetText(lstHistory->Items().Text(n)) ;
			frmMain->Focus();
        }
    }
	else if(param.key == VK_ESCAPE)
		Close();
}

void TfrmHistory::FormClose(void *sender, nlib::FormCloseParameters param)
{
    param.action = caDeleteForm;
	frmHistory=NULL;
}
void TfrmHistory::chkSortClick(void *sender, nlib::EventParameters param)
{
	;
}

void TfrmHistory::FormMove(void *sender, nlib::EventParameters param)
{
	Snap(10);
}

// TASK: test the iontersection of rectangle 'rect' with rectangle 'r'
// RETURNS: which corner of 'r' 0: no intersection, 1: top left of r is inside 'rect'
//          2: top right  4: bottom right is inside, 8:bottom left 
int Intersect(RECT &rect, RECT &r)
{
	return (( (rect.left <= r.left) && (rect.right >= r.left) && (rect.top <= r.top && rect.bottom >= r.top)) ? 1 : 0) |		// left top
		   (( (rect.left <= r.right) && (rect.right >= r.right) && (rect.top <= r.top && rect.bottom >= r.top)) ? 2 : 0) |		// right top
		   (( (rect.left <= r.right) && (rect.right >= r.right) && (rect.top <= r.bottom && rect.bottom >= r.bottom)) ? 4: 0) | // right bottom
		   (( (rect.left <= r.left) && (rect.right >= r.left) && (rect.top <= r.bottom && rect.bottom >= r.bottom)) ? 8: 0);    // left bottom
}

int TfrmHistory::InsideSnapAreaFromMain(int dist)
{
	RECT rT,rR,rB,rL,	// top right bottom left area beside the main window
		 r;
									// area of main  temporarily into top
	rT.left = frmMain->Left();		
	rT.top = frmMain->Top();
	rT.right = frmMain->Right();
	rT.bottom = frmMain->Bottom();

	// area left of main
	rL.left = rT.left - dist;
	rL.right = rT.left;
	rL.top = rT.top;
	rL.bottom = rT.bottom;
	// right of main
	rR.left = rT.right;
	rR.right = rT.right+dist;
	rR.top = rT.top;
	rR.bottom = rT.bottom;
	// bottom of main
	rB.left = rT.left;
	rB.right = rT.right;
	rB.bottom = rT.bottom + dist;
	rB.top = rT.bottom;
	// area above main
	rT.bottom = rT.top;
	rT.top -= dist;

	// determine snap area index
	//   0: none 1 top, 2 right, 3 bottom, 4 left
	r.top = Top(); r.right = Right(); r.bottom = Bottom(); r.left = Left();

	if(Intersect(rT, r) & (4|8))		// when bottom right or bottom left is inside top area of main
		return 1;						// then snap to top of main
	else if(Intersect(rR,r) & (1|8))	// when top left or bottom left is inside right area
		return 2;						// snap to right of main
	else if(Intersect(rB,r) & (2|1))	// when top left or top right is inside bottom area
		return 3;						// snap to bottom of main
	else if(Intersect(rL,r) & (2|4))	// when top right or bottom right is inside top area
		return 4;						// snap to left of main
	else
		return 0;						// no snap
}

void TfrmHistory::Snap(int dist)
{
    RECT rsc,r; // rectangles for: screen size, temp
	if(!SystemParametersInfo(SPI_GETWORKAREA,0,&rsc,0) )
		return;

	int which;

	snapped = false;
	if(!dist)
	{
			// get correct window size
		r = frmMain->ClientRect();
		int captionHeight = frmMain->Height() - (r.bottom - r.top);	
		if( frmMain->Bottom() + captionHeight > rsc.bottom)	// then history window's title bar is obscured if put below main
			if(frmMain->Top() - Height() < rsc.top)		// then also obsured at above it too
				if(frmMain->Right() + captionHeight >= rsc.right)    // and also at right
					if(frmMain->Left() <= r.left)						// and even from left
						;                        // then let Windows choose the position
					else								// not obscured only when at left
					{
						SetTop(frmMain->Top());
						SetHeight(frmMain->Height());
						SetLeft(frmMain->Left() - Width());
					}
				else                             // not obscured at right
				{
					SetTop(frmMain->Top());
					SetHeight(frmMain->Height() );
					SetLeft(frmMain->Right());
				}
			else                                // show it above
			{
				SetTop (frmMain->Top() - Height());
				SetLeft(frmMain->Left());
				SetWidth(frmMain->Width());
			}
		else                                     // position below
		{
			SetTop(frmMain->Bottom());
			SetLeft(frmMain->Left());
			SetWidth(frmMain->Width());
		}
		snapped = true;
	}
	else if((which = InsideSnapAreaFromMain(dist)) != 0 )		 // snap to main if distance is smaller than 'dist'
	{
		switch(which)
		{
			case 0: return;						// not inside
			case 1: SetTop(frmMain->Top() - Height() );		// snap to top
					break;
			case 2: SetLeft(frmMain->Right() );				// to right
					break;
			case 3: SetTop(frmMain->Bottom() );				// to bottom
					break;
			case 4: SetLeft(frmMain->Left() - Width());		// to left
					break;
		}
		snapped = true;
	}
}
