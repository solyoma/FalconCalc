#include <set>
#include "stdafx_zoli.h"
#include "stdafx_lc.h"
#include "resource.h"
#include "wcommon.h"

#include "SmartString.h"
using namespace SmString;

#include "LongNumber.h"

using namespace LongNumber;

#include "common.h"
#include "calculate.h"

using namespace nlib;
#undef max

#include "SmartString.h"
using namespace SmString;
#include "LongNumber.h"

using namespace LongNumber;

#include "calculate.h"

#include "mainForm.h"
#include "variables.h"

TfrmVariables *frmVariables;
constexpr int	VARIABLES = 0,
			FUNCTIONS = 1;

int TfrmVariables::_colW[2][4] = { {80,100,60,300},{50,200,60,300} };

void TfrmVariables::InitializeFormAndControls() /* Control initialization function generated by the designer. Modifications will be lost. */
{
	/* Generated member initialization. Do not modify. */
	SetLeft(209);
	SetTop(509);
	SetText(L"FalconCalc - Edit Functions/Variables");
	GetFont().SetFamily(L"Tahoma");
	SetWantedKeyTypes(nlib::wkArrows | nlib::wkTab | nlib::wkEnter | nlib::wkEscape | nlib::wkOthers);
	SetClientRect(nlib::Rect(0, 0, 528, 569));

	MyLoadWindowIcon(this);


	tcVars = new nlib::TabControl();
	tcVars->SetBounds(nlib::Rect(0, 0, 439, 569));
	tcVars->SetText(L"tcVars");
	tcVars->SetAnchors(nlib::caLeft | nlib::caTop | nlib::caRight | nlib::caBottom);
	nlib::Tab *temp_var0086680704 = tcVars->AddTab(L"&Variables");
	tcVars->SetTabOrder(VARIABLES);
	nlib::Tab *temp_var0062653624 = tcVars->AddTab(L"&Functions");
	temp_var0062653624->SetTag(1);
	tcVars->SetSelectedTab(VARIABLES);
	tcVars->SetParent(this);

	sgUser = new nlib::StringGrid();
	sgUser->SetBounds(nlib::Rect(4, 23, 435, 319));
	sgUser->SetAlignment(nlib::alTop);
	sgUser->SetTabOrder(0);
	sgUser->SetRowCount(5);
	sgUser->SetFixedColCount(0);
	sgUser->SetSelectionKind(nlib::gskNoSelect);
	sgUser->SetColumnsResizable(true);
	sgUser->SetColWidth(0, 87);
	sgUser->SetColWidth(1, 64);
	sgUser->SetColWidth(2, 129);
	sgUser->SetRowHeight(3, 21);
	sgUser->SetRowHeight(4, 23);
	sgUser->SetDefColWidth(0, 87);
	sgUser->SetDefColWidth(2, 129);
	sgUser->SetDefColWidth(3, 129);
	sgUser->SetSmoothHorzScroll(true);
	sgUser->SetAutoEdit(true);
	sgUser->SetTabEdited(true);
	sgUser->SetParent(tcVars);

	pBuiltin = new nlib::Panel();
	pBuiltin->SetBounds(nlib::Rect(4, 319, 435, 343));
	pBuiltin->SetText(L"Builtins");
	pBuiltin->SetAlignment(nlib::alTop);
	pBuiltin->SetParentBackground(true);
	pBuiltin->SetTabOrder(1);
	pBuiltin->SetInnerBorderStyle(nlib::pbsNone);
	pBuiltin->SetParent(tcVars);

	sgBuiltin = new nlib::StringGrid();
	sgBuiltin->SetBounds(nlib::Rect(4, 343, 435, 565));
	sgBuiltin->SetAlignment(nlib::alClient);
	sgBuiltin->SetTabOrder(2);
	sgBuiltin->SetRowCount(5);
	sgBuiltin->SetFixedColCount(0);
	sgBuiltin->SetFixedRowCount(0);
	sgBuiltin->SetSelectionKind(nlib::gskNoSelect);
	sgBuiltin->SetColumnsResizable(true);
	sgBuiltin->SetColWidth(0, 88);
	sgBuiltin->SetColWidth(1, 64);
	sgBuiltin->SetColWidth(2, 133);
	sgBuiltin->SetRowHeight(2, 23);
	sgBuiltin->SetRowHeight(4, 20);
	sgBuiltin->SetDefColWidth(0, 88);
	sgBuiltin->SetDefColWidth(2, 129);
	sgBuiltin->SetDefColWidth(3, 129);
	sgBuiltin->SetSmoothHorzScroll(true);
	sgBuiltin->SetParent(tcVars);

	btnDelVar = new nlib::ToolButton();
	btnDelVar->SetBounds(nlib::Rect(444, 48, 467, 70));
	btnDelVar->SetAnchors(nlib::caTop | nlib::caRight);
	btnDelVar->SetTabOrder(1);
	btnDelVar->SetImagePosition(nlib::bipCenter);
	btnDelVar->SetFlat(false);
	btnDelVar->SetParent(this);

	btnClear = new nlib::ToolButton();
	btnClear->SetBounds(nlib::Rect(444, 76, 467, 98));
	btnClear->SetAnchors(nlib::caTop | nlib::caRight);
	btnClear->SetTabOrder(2);
	btnClear->SetImagePosition(nlib::bipCenter);
	btnClear->SetFlat(false);
	btnClear->SetParent(this);

	btnSave = new nlib::Button();
	btnSave->SetBounds(nlib::Rect(445, 497, 520, 520));
	btnSave->SetText(lt.GetTranslationFor(FCT_SAVE));
	btnSave->SetAnchors(nlib::caRight | nlib::caBottom);
	btnSave->SetTabOrder(4);
	btnSave->SetEnabled(false);
	btnSave->SetParent(this);

	btnCancel = new nlib::Button();
	btnCancel->SetBounds(nlib::Rect(445, 524, 520, 547));
	btnCancel->SetText(lt.GetTranslationFor(FCT_CLOSE));
	btnCancel->SetAnchors(nlib::caRight | nlib::caBottom);
	btnCancel->SetTabOrder(3);
	btnCancel->SetParent(this);

	btnDelVar->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28683)));
	btnDelVar->Image()->SetStateCount(2);
	btnClear->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28684)));

	OnClose = CreateEvent(this, &TfrmVariables::FormClose);
	OnEndSizeMove = CreateEvent(this, &TfrmVariables::FormSizeMoveEnded);
	OnKeyDown = CreateEvent(this, &TfrmVariables::VariablesKeyDown);

	tcVars->OnTabChange = CreateEvent(this, &TfrmVariables::tcVarsTabChange);
	sgUser->OnColumnSizing = CreateEvent(this, &TfrmVariables::sgUserColumnSizing);
	sgUser->OnEditorKeyDown = CreateEvent(this, &TfrmVariables::sgUserEditorKeyDown);
	sgUser->OnEditorKeyPress = CreateEvent(this, &TfrmVariables::sgUserKeyPress);
	sgUser->OnDblClick = CreateEvent(this, &TfrmVariables::sgUserDoubleClick);

	pBuiltin->OnMouseMove = CreateEvent(this, &TfrmVariables::BuiltinMouseMove);
	pBuiltin->OnMouseDown = CreateEvent(this, &TfrmVariables::BuiltinMouseDown);
	pBuiltin->OnMouseUp = CreateEvent(this, &TfrmVariables::BuiltinMouseUp);

	sgBuiltin->OnColumnSizing = CreateEvent(this, &TfrmVariables::sgBuiltinColumnSizing);
	sgBuiltin->OnDblClick = CreateEvent(this, &TfrmVariables::sgBuiltinDoubleClick);

	btnDelVar->OnClick = CreateEvent(this, &TfrmVariables::btnDelVarClick);
	btnClear->OnClick = CreateEvent(this, &TfrmVariables::btnClearClick);
	btnCancel->OnClick = CreateEvent(this, &TfrmVariables::btnCancelClick);
	btnSave->OnClick = CreateEvent(this, &TfrmVariables::btnSaveClick);
}

void TfrmVariables::Destroy()
{
	/* Controls are valid here, but not in the destructor. */
	/* ... Your code here ... */
	_activeTab = -1;
	Form::Destroy();
}

TfrmVariables::TfrmVariables()
{
	InitializeFormAndControls();

	_underResize = false;
	RowData rd;
	for (int i = 0; i < LittleEngine::variables.size(); ++i)
	{
		Variable& v = LittleEngine::variables[i];
		rd = { v.name, v.body, v.unit, v.desc };
		_rvUserVars[v.name] = rd;
	}
	_rvUserVarsIn = _rvUserVars;

	for (int i = 0; i < LittleEngine::functions.size(); ++i)
	{
		Func& f = LittleEngine::functions[i];
		rd = { f.FullNameWithArgs(), f.body, f.unit, f.desc};
		_rvUserFuncs[rd.cols[0]] = rd;
	}
	_rvUserFuncsIn = _rvUserFuncs;
}

TfrmVariables::~TfrmVariables()
{
	/* Don't 'delete' the form. Call Destroy() instead which has access to the protected destructor. */
}

void TfrmVariables::FormSizeMoveEnded(void* sender, nlib::SizePositionChangedParameters param)
{
	if (!frmMain->InMoving() && !_busy && GetSnapSide() != FalconCalc::wsNone)
		Snap();
}

FalconCalc::WindowSide TfrmVariables::GetSnapSide()
{
	// determine snap area index
	RECT r = wiVars.BareVisibleWindowRect(true);
	_snapDist = _snapPixelLimit;
	return _snappedToSide = ::GetSnapSide(r, _snapDist);
}

void TfrmVariables::Snap()
{
	RECT rbase = wiMain.BareVisibleWindowRect(),
			dr = wiVars.BareVisibleWindowRect(true);
	// DEBUG
	/*
	auto _DbgStr = [](std::wstring label,RECT r) ->std::wstring
		{
			return label + L":((" + to_wstring(r.left) + L"," + to_wstring(r.top) + L"), (" + to_wstring(r.right) + L"," + to_wstring(r.bottom) + L"))  [" +
				to_wstring(r.right - r.left) + L", " + to_wstring(r.bottom - r.top) + L"]\n";
		};
	DebugMsg(_DbgStr(L"rbase",rbase));
	DebugMsg(_DbgStr(L"dr   ",dr));
	*/
	// /DEBUG
	POINT pt = WinDistance(rbase, dr, _snappedToSide);
	rbase = wiMain.WindowRect();
	dr    = wiVars.WindowRect();
	if (::SnapTo(dr, _snappedToSide, pt))	// get snapped coordinates into 'dr'
	{
		++_busy;
		MoveWindow(Handle(), dr.left, dr.top, dr.right - dr.left, dr.bottom - dr.top, true);
		// DEBUG  1 line
		RECT rNew = WindowRect();
		--_busy;
	}
}

void TfrmVariables::BuiltinMouseDown(void *sender, nlib::MouseButtonParameters param)
{
	_underResize = true;
	_gridH = param.y;

}

void TfrmVariables::BuiltinMouseMove(void *sender, nlib::MouseMoveParameters param)
{
	if(!_underResize)
		return;
	int    rh = sgUser->DefaultRowHeight(),
		   h1 = sgUser->Height(),
		   h2 = sgBuiltin->Height(),
		   dh = param.y - _gridH;
	if(h1+dh > 2*rh && h2-dh > 2 *rh)
	{
		sgUser->SetHeight(h1+dh);
		_gridH += dh;
	}

}

void TfrmVariables::BuiltinMouseUp(void *sender, nlib::MouseButtonParameters param)
{
	_underResize = false;
}


 /*=============================================================
  * TASK   : store user data (from all rows of sgUser) for
  *				both user variables and user function in the  
  *				maps _rvIserXXX (XXX = Vars or Funcs)
  * PARAMS : table:		0: variables, 1: functions
  * EXPECTS:
  * GLOBALS: _rvUserXXX, _changed[]
  * RETURNS: nothing
  * REMARKS:- columns: name, body/definition, unit, description
  *			- functions must have a body
  *			- _changed[table] only set if there is changed or 
  *				new data in the table or when data is  erased
  *------------------------------------------------------------*/
void TfrmVariables::_CollectFrom(int table)
{
    //if(!_changed[table])    // 'changed' must be modified in caller when necessary
    //    return;

	RowDataMap &rvIn = table ? _rvUserFuncsIn : _rvUserVarsIn,
				&rv   = table ? _rvUserFuncs   : _rvUserVars  ;
											  
	RowData rd;
	// collect data from table into the non-input variables
	rv.clear();
	for (int i = 1; i < sgUser->RowCount(); ++i)
	{
		if (!sgUser->String(0, i).empty() && !sgUser->String(1, i).empty())
		{
			rd.cols[0] = SmartString(sgUser->String(0, i));		// name
			rd.cols[1] = SmartString(sgUser->String(1, i));		// body/definition
			rd.cols[2] = SmartString(sgUser->String(2, i));		// unit
			rd.cols[3] = SmartString(sgUser->String(3, i));		// description
		}
		rv[rd.cols[0]] = rd;			// actual is always set
	}

	// next check for changes
	if (rv.size() != rvIn.size())	// data deleted or added
		_changed[table] = true;
	else for (int i = 1; i < rv.size(); ++i)
		if(rv[i] != rvIn[i])
		{
			_changed[table] = true;
			break;
		}
    
	btnSave->SetEnabled(_changed[0] || _changed[1]);
}

void TfrmVariables::_SetupGridLayout(int tabIndex)
{
	if (tabIndex == VARIABLES)	// variables Fields: name, unit, value,comment	
	{
		sgUser->SetColCount(4);
		sgUser->SetColWidth(0, _colW[0][0]);
		sgUser->SetColWidth(1, _colW[0][1]);
		sgUser->SetColWidth(2, _colW[0][2]);
		sgUser->SetColWidth(3, _colW[0][3]);
		sgBuiltin->SetColCount(4);
		sgBuiltin->SetColWidth(0, _colW[0][0]);
		sgBuiltin->SetColWidth(1, _colW[0][1]);
		sgBuiltin->SetColWidth(2, _colW[0][2]);
		sgBuiltin->SetColWidth(3, _colW[0][3]);
	}
	else				// functions. Fields: name, definition, comment
	{
		sgUser->SetColCount(4);
		sgUser->SetColWidth(0, _colW[1][0]);
		sgUser->SetColWidth(1, _colW[1][1]);
		sgUser->SetColWidth(2, _colW[1][2]);
		sgUser->SetColWidth(3, _colW[1][3]);
		sgBuiltin->SetColCount(4);
		sgBuiltin->SetColWidth(0, _colW[1][0]);
		sgBuiltin->SetColWidth(1, _colW[1][1]);
		sgBuiltin->SetColWidth(2, _colW[1][2]);
		sgBuiltin->SetColWidth(3, _colW[1][3]);
	}
}

/*=============================================================
 * TASK   :	to store user data from grid into 'tcVars' from previously
 *			active Tab, then set data into grid from 'tcVars'
 *			for the now active Tab
 * PARAMS :	sender:
 *			param:
 * EXPECTS:
 * GLOBALS:
 * RETURNS:
 * REMARKS: changes the number of columns and rows
 *------------------------------------------------------------*/
void TfrmVariables::tcVarsTabChange(void *sender, nlib::TabChangeParameters param)
{
	if (_activeTab == param.tabindex)// && sgBuiltin->RowCount() > 5)
		return;

	bool initted = _activeTab >= 0;
	_activeTab = param.tabindex;

    size_t cntUser=0, cntBuiltin=0;

		// collect info from previously active Tab
	// and set data into actual Tab

	_SetupGridLayout(_activeTab);
	if (initted)
	{
		switch (_activeTab)
		{
			case FUNCTIONS:
				_CollectFrom(VARIABLES);	// the page we switched from
				sgUser->SetString(0, 0, L"Function(args)");
				sgUser->SetString(1, 0, L"Definition");
				sgUser->SetString(2, 0, L"Unit");
				sgUser->SetString(3, 0, L"Comment");
				cntUser = _rvUserFuncs.size();
				break;
			default:
			case VARIABLES:
				_CollectFrom(FUNCTIONS);	// the tab we switched from
				sgUser->SetString(0, 0, L"Variable");
				sgUser->SetString(1, 0, L"Value");
				sgUser->SetString(2, 0, L"Unit");
				sgUser->SetString(3, 0, L"Comment");
				cntUser = _rvUserVars.size();
				break;
		}
	}
	else
		cntUser = _activeTab == VARIABLES ? _rvUserVars.size() : _rvUserFuncs.size();

	if ((size_t)sgUser->RowCount() != cntUser + (cntUser ? 1 : 2))
		sgUser->SetRowCount(cntUser + (cntUser ? 1 : 2));

	if(cntUser == 0)
	{
		sgUser->SetString(0,1,L"");
		sgUser->SetString(1,1,L"");
		sgUser->SetString(2,1,L"");
		sgUser->SetString(3,1,L"");
	}

	// first the user variables:

	RowDataMap& sv = _activeTab == FUNCTIONS ? _rvUserFuncs : _rvUserVars;
	RowData rd;
	for (size_t i = 0; i < cntUser; ++i)
	{
		for (size_t j = 0; j < 4; ++j)
		{
			rd = sv[i];
			sgUser->SetString(j, i + 1, rd.cols[j].ToWideString());
		}
	}

	// then the builtins
	if (_activeTab == FUNCTIONS)
	{	
		BuiltinFuncTable &bfunc =  LittleEngine::builtinFunctions;
		static const SmartString sx1 = SmartString("(x)"), sx2 = SmartString("(x, y)");
		sgBuiltin->SetRowCount(bfunc.size());
		for (int i = 0; i < bfunc.size(); ++i)
		{
			SmartString s = bfunc[i].name + (bfunc[i].funct1 ? sx1 : sx2);

			sgBuiltin->SetString(0, i,s.ToWideString());
			sgBuiltin->SetString(1, i, L"-");
			sgBuiltin->SetString(2, i, L"-");
			sgBuiltin->SetString(3, i, bfunc[i].desc.ToWideString());
		}
	}
	else	//	VARIABLES:
	{
		sgBuiltin->SetRowCount(constantsMap.size());
		int i = 0;
		DisplayFormat df;
		
		for (auto &it: constantsMap)
		{
			sgBuiltin->SetString(0, i, it.second->name.ToWideString());
			sgBuiltin->SetString(1, i, it.second->value.ToDecimalString(df).ToWideString());
			sgBuiltin->SetString(2, i, it.second->unit.ToWideString());
			sgBuiltin->SetString(3, i, it.second->desc.ToWideString());
			++i;
		}
	}
}

void TfrmVariables::VariablesKeyDown(void* sender, nlib::KeyParameters param)
{
	if (param.keycode == VK_ESCAPE || (param.keycode== '0' && param.vkeys.contains(vksAlt)) )
		SetFocus(frmMain->cbInfix->Handle());

	if (param.keycode == VK_ESCAPE)
		Close();
}

void TfrmVariables::btnCancelClick(void *sender, nlib::EventParameters param)
{
    Close();
}

void TfrmVariables::btnClearClick(void *sender, nlib::EventParameters param)
{
	sgUser->SetRowCount(2);
	sgUser->SetString(0,1,L"");
	sgUser->SetString(1,1,L"");
	sgUser->SetString(2,1,L"");
	sgUser->SetString(3,1,L"");
	btnSave->SetEnabled(_changed[_activeTab] = true);
}

void TfrmVariables::btnDelVarClick(void *sender, nlib::EventParameters param)
{
	int n = sgUser->Selected().y;
    if(n > 0)
    {
        if(sgUser->RowCount() == 2) 
            btnClearClick(sender,param);
        else
			sgUser->DeleteRow(n);
        _changed[_activeTab] = true;
    }
	btnSave->SetEnabled(_changed[VARIABLES] ||_changed[FUNCTIONS]);
}

void TfrmVariables::btnSaveClick(void *sender, nlib::EventParameters param)
{
    if(!_changed[0] && !_changed[1])		// should never happen (Save button not enabled)
		return;
	
	if (_activeTab == VARIABLES)
		_CollectFrom(VARIABLES);	// changed FUNCTIONs already collected in tcVarsTabChanged()
	else if(_activeTab == FUNCTIONS)
		_CollectFrom(FUNCTIONS);	// changed VARIABLEs -"-

	SmartString s;
	SmartStringVector sv;
	if (_changed[VARIABLES])
	{
		lengine->variables.clear();
		for (int i = 0; i < _rvUserVars.size(); ++i)
		{
			s = _rvUserVars[i].Serialize();
			sv.push_back(s);
		}
		lengine->AddUserVariables(sv);
	}
	if (_changed[FUNCTIONS])
	{
		lengine->functions.clear();
		for (int i = 0; i < _rvUserFuncs.size(); ++i)
		{
			s = _rvUserFuncs[i].Serialize();
			sv.push_back(s);
		}
		lengine->AddUserFunctions(sv);
	}

    frmMain->cbInfixTextChanged(sender,param); // to reflect changed values
	btnSave->SetEnabled(false); //  _changed[] = false);

	lengine->clean = false;		// variables/functions saved at exit
}

void TfrmVariables::sgBuiltinColumnSizing(void *sender, nlib::ColumnRowSizeParameters param)
{
	sgUser->SetColWidth(param.index, param.size );
	_colW[_activeTab][param.index] = param.size;
}

void TfrmVariables::sgUserColumnSizing(void *sender, nlib::ColumnRowSizeParameters param)
{
	sgBuiltin->SetColWidth(param.index, param.size );
	_colW[_activeTab][param.index] = param.size;
}

void TfrmVariables::FormClose(void *sender, nlib::FormCloseParameters param)
{
    param.action = caDeleteForm;
	frmVariables=NULL;
	SetFocus(frmMain->cbInfix->Handle());
}

void TfrmVariables::sgUserKeyPress(void *sender, nlib::KeyPressParameters param)
{
	if (param.key != VK_TAB && param.key != VK_RIGHT && param.key != VK_LEFT && param.key != VK_UP && param.key != VK_DOWN)
		btnSave->SetEnabled(_changed[_activeTab] = true);

	if (param.key == '3' && param.vkeys & vksAlt)
	{
		nlib::EventParameters par;
		frmMain->miShowHistClick(nullptr, par);
	}
}

void TfrmVariables::sgUserDoubleClick(void* sender, nlib::MouseButtonParameters param)
{
	frmMain->cbInfix->SetSelText(sgUser->Selected().x == 0 ? sgUser->String(0, sgUser->Selected().y) : sgUser->String(1, sgUser->Selected().y));
	frmMain->cbInfix->Focus();
}

void TfrmVariables::sgBuiltinDoubleClick(void* sender, nlib::MouseButtonParameters param)
{
	frmMain->cbInfix->SetSelText(sgBuiltin->Selected().x == 0 ? sgBuiltin->String(0, sgBuiltin->Selected().y) : sgBuiltin->String(1, sgBuiltin->Selected().y));
	frmMain->cbInfix->Focus();
}

void TfrmVariables::sgUserEditorKeyDown(void *sender, nlib::KeyParameters param)
{
	if(param.keycode != VK_TAB && param.keycode != VK_RIGHT && param.keycode != VK_LEFT && param.keycode != VK_UP && param.keycode != VK_DOWN)
		btnSave->SetEnabled(_changed[_activeTab] = true);

	if(param.keycode == VK_TAB)
	{
//		int x = sgUser->Selected().x;
		if( (param.vkeys & vksShift) == 0 &&  sgUser->Selected().x >= 2)
		{
			int n = sgUser->Selected().y + 1;
			if(n >= sgUser->RowCount())
			{
				sgUser->SetRowCount(n+1);
				sgUser->SetString(0, n, L"");
				sgUser->SetString(1,n, L"");
				sgUser->SetString(2,n, L"");
			}
			sgUser->SetSelected(0,n);
		}
	}

}
