#include <set>
#include "stdafx_zoli.h"
#include "stdafx_lc.h"
#include "wcommon.h"

using namespace nlib;
#undef max

#include "calculate.h"
#include "mainForm.h"
#include "variables.h"

TfrmVariables *frmVariables;
const int	VARIABLES = 0,
			FUNCTIONS = 1;

int TfrmVariables::_colW[2][4] = { {80,100,60,300},{50,200,60,300} };

void TfrmVariables::InitializeFormAndControls() /* Control initialization function generated by the designer. Modifications will be lost. */
{
	/* Generated member initialization. Do not modify. */
	SetLeft(209);
	SetTop(509);
	SetText(L"FalconCalc - Edit Functions/Variables");
	GetFont().SetFamily(L"Tahoma");
	SetWantedKeyTypes(nlib::wkArrows | nlib::wkTab | nlib::wkEnter | nlib::wkEscape | nlib::wkOthers);
	SetClientRect(nlib::Rect(0, 0, 528, 569));

	tcVars = new nlib::TabControl();
	tcVars->SetBounds(nlib::Rect(0, 0, 439, 569));
	tcVars->SetText(L"tcVars");
	tcVars->SetAnchors(nlib::caLeft | nlib::caTop | nlib::caRight | nlib::caBottom);
	nlib::Tab *temp_var0086680704 = tcVars->AddTab(L"&Variables");
	tcVars->SetTabOrder(VARIABLES);
	nlib::Tab *temp_var0062653624 = tcVars->AddTab(L"&Functions");
	temp_var0062653624->SetTag(1);
	tcVars->SetSelectedTab(VARIABLES);
	tcVars->SetParent(this);

	sgUser = new nlib::StringGrid();
	sgUser->SetBounds(nlib::Rect(4, 23, 435, 319));
	sgUser->SetAlignment(nlib::alTop);
	sgUser->SetTabOrder(0);
	sgUser->SetRowCount(5);
	sgUser->SetFixedColCount(0);
	sgUser->SetSelectionKind(nlib::gskNoSelect);
	sgUser->SetColumnsResizable(true);
	sgUser->SetColWidth(0, 87);
	sgUser->SetColWidth(1, 64);
	sgUser->SetColWidth(2, 129);
	sgUser->SetRowHeight(3, 21);
	sgUser->SetRowHeight(4, 23);
	sgUser->SetDefColWidth(0, 87);
	sgUser->SetDefColWidth(2, 129);
	sgUser->SetDefColWidth(3, 129);
	sgUser->SetSmoothHorzScroll(true);
	sgUser->SetAutoEdit(true);
	sgUser->SetTabEdited(true);
	sgUser->SetParent(tcVars);

	pBuiltin = new nlib::Panel();
	pBuiltin->SetBounds(nlib::Rect(4, 319, 435, 343));
	pBuiltin->SetText(L"Builtins");
	pBuiltin->SetAlignment(nlib::alTop);
	pBuiltin->SetParentBackground(true);
	pBuiltin->SetTabOrder(1);
	pBuiltin->SetInnerBorderStyle(nlib::pbsNone);
	pBuiltin->SetParent(tcVars);

	sgBuiltin = new nlib::StringGrid();
	sgBuiltin->SetBounds(nlib::Rect(4, 343, 435, 565));
	sgBuiltin->SetAlignment(nlib::alClient);
	sgBuiltin->SetTabOrder(2);
	sgBuiltin->SetRowCount(5);
	sgBuiltin->SetFixedColCount(0);
	sgBuiltin->SetFixedRowCount(0);
	sgBuiltin->SetSelectionKind(nlib::gskNoSelect);
	sgBuiltin->SetColumnsResizable(true);
	sgBuiltin->SetColWidth(0, 88);
	sgBuiltin->SetColWidth(1, 64);
	sgBuiltin->SetColWidth(2, 133);
	sgBuiltin->SetRowHeight(2, 23);
	sgBuiltin->SetRowHeight(4, 20);
	sgBuiltin->SetDefColWidth(0, 88);
	sgBuiltin->SetDefColWidth(2, 129);
	sgBuiltin->SetDefColWidth(3, 129);
	sgBuiltin->SetSmoothHorzScroll(true);
	sgBuiltin->SetParent(tcVars);

	btnDelVar = new nlib::FlatButton();
	btnDelVar->SetBounds(nlib::Rect(444, 48, 467, 70));
	btnDelVar->SetAnchors(nlib::caTop | nlib::caRight);
	btnDelVar->SetTabOrder(1);
	btnDelVar->SetImagePosition(nlib::bipCenter);
	btnDelVar->SetFlat(false);
	btnDelVar->SetParent(this);

	btnClear = new nlib::FlatButton();
	btnClear->SetBounds(nlib::Rect(444, 76, 467, 98));
	btnClear->SetAnchors(nlib::caTop | nlib::caRight);
	btnClear->SetTabOrder(2);
	btnClear->SetImagePosition(nlib::bipCenter);
	btnClear->SetFlat(false);
	btnClear->SetParent(this);

	btnCancel = new nlib::Button();
	btnCancel->SetBounds(nlib::Rect(445, 497, 520, 520));
	btnCancel->SetText(L"&Cancel");
	btnCancel->SetAnchors(nlib::caRight | nlib::caBottom);
	btnCancel->SetTabOrder(3);
	btnCancel->SetParent(this);

	btnSave = new nlib::Button();
	btnSave->SetBounds(nlib::Rect(445, 524, 520, 547));
	btnSave->SetText(L"&Save");
	btnSave->SetAnchors(nlib::caRight | nlib::caBottom);
	btnSave->SetTabOrder(4);
	btnSave->SetEnabled(false);
	btnSave->SetParent(this);

	btnDelVar->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28683)));
	btnDelVar->Image()->SetStateCount(2);
	btnClear->Image()->SetBitmap(new nlib::Bitmap(NULL, MAKEINTRESOURCE(28684)));

	OnClose = CreateEvent(this, &TfrmVariables::FormClose);
	OnEndSizeMove = CreateEvent(this, &TfrmVariables::FormSizeMoveEnded);

	tcVars->OnTabChange = CreateEvent(this, &TfrmVariables::tcVarsTabChange);
	sgUser->OnColumnSizing = CreateEvent(this, &TfrmVariables::sgUserColumnSizing);
	sgUser->OnEditorKeyDown = CreateEvent(this, &TfrmVariables::sgUserEditorKeyDown);
	sgUser->OnEditorKeyPress = CreateEvent(this, &TfrmVariables::sgUserKeyPress);
	pBuiltin->OnMouseMove = CreateEvent(this, &TfrmVariables::BuiltinMouseMove);
	pBuiltin->OnMouseDown = CreateEvent(this, &TfrmVariables::BuiltinMouseDown);
	pBuiltin->OnMouseUp = CreateEvent(this, &TfrmVariables::BuiltinMouseUp);
	sgBuiltin->OnColumnSizing = CreateEvent(this, &TfrmVariables::sgBuiltinColumnSizing);
	btnDelVar->OnClick = CreateEvent(this, &TfrmVariables::btnDelVarClick);
	btnClear->OnClick = CreateEvent(this, &TfrmVariables::btnClearClick);
	btnCancel->OnClick = CreateEvent(this, &TfrmVariables::btnCancelClick);
	btnSave->OnClick = CreateEvent(this, &TfrmVariables::btnSaveClick);
}

void TfrmVariables::Destroy()
{
	/* Controls are valid here, but not in the destructor. */
	/* ... Your code here ... */
	_activeTab = -1;
	Form::Destroy();
}

TfrmVariables::TfrmVariables()
{
	InitializeFormAndControls();

	_changed = false;
	_underResize = false;
}

TfrmVariables::~TfrmVariables()
{
	/* Don't 'delete' the form. Call Destroy() instead which has access to the protected destructor. */
}

void TfrmVariables::Setup(const FalconCalc::VarFuncInfo &vfInfo)
{
    _vf = vfInfo;
//	tcVarsTabChange(tcVars, TabChangeParameters(tcVars->SelectedTab()));
}


void TfrmVariables::FormSizeMoveEnded(void* sender, nlib::SizePositionChangedParameters param)
{
	if (!frmMain->InMoving() && !_busy && GetSnapSide() != FalconCalc::wsNone)
		Snap();
}

FalconCalc::WindowSide TfrmVariables::GetSnapSide()
{
	// determine snap area index
	RECT r = wiVars.BareVisibleWindowRect(true);
	_snapDist = _snapPixelLimit;
	return _snappedToSide = ::GetSnapSide(r, _snapDist);
}

void TfrmVariables::Snap()
{
	RECT rbase = wiMain.BareVisibleWindowRect(),
			dr = wiVars.BareVisibleWindowRect(true);
	// DEBUG
	/*
	auto _DbgStr = [](std::wstring label,RECT r) ->std::wstring
		{
			return label + L":((" + to_wstring(r.left) + L"," + to_wstring(r.top) + L"), (" + to_wstring(r.right) + L"," + to_wstring(r.bottom) + L"))  [" +
				to_wstring(r.right - r.left) + L", " + to_wstring(r.bottom - r.top) + L"]\n";
		};
	DebugMsg(_DbgStr(L"rbase",rbase));
	DebugMsg(_DbgStr(L"dr   ",dr));
	*/
	// /DEBUG
	POINT pt = WinDistance(rbase, dr, _snappedToSide);
	rbase = wiMain.WindowRect();
	dr    = wiVars.WindowRect();
	if (::SnapTo(dr, _snappedToSide, pt))	// get snapped coordinates into 'dr'
	{
		++_busy;
		MoveWindow(Handle(), dr.left, dr.top, dr.right - dr.left, dr.bottom - dr.top, true);
		// DEBUG  1 line
		RECT rNew = WindowRect();
		--_busy;
	}
}

void TfrmVariables::BuiltinMouseDown(void *sender, nlib::MouseButtonParameters param)
{
	_underResize = true;
	_gridH = param.y;

}

void TfrmVariables::BuiltinMouseMove(void *sender, nlib::MouseMoveParameters param)
{
	if(!_underResize)
		return;
	int    rh = sgUser->DefaultRowHeight(),
		   h1 = sgUser->Height(),
		   h2 = sgBuiltin->Height(),
		   dh = param.y - _gridH;
	if(h1+dh > 2*rh && h2-dh > 2 *rh)
	{
		sgUser->SetHeight(h1+dh);
		_gridH += dh;
	}

}

void TfrmVariables::BuiltinMouseUp(void *sender, nlib::MouseButtonParameters param)
{
	_underResize = false;
}


 /*=============================================================
  * TASK   : store user data (from all rows of sgUser) for
  *				both user variables and user function in a single 
  *				string
  * PARAMS : us (O) : reference to string for all user data	
  *			 cnt (I): reference to # of columns
  * EXPECTS:
  * GLOBALS:
  * RETURNS: nothing
  * REMARKS:- result in 'us' as a single utf8 string of '\n' 
  *			  delimited lines which consists of fields separated
  *			  by ssCommondelimiters (":")
  *			- order of data stored for
  *				variables:  name,formula/value,unit,comment
  *				functions:	name,body,unit,comment
  *			- functions must have a body
  *------------------------------------------------------------*/
void TfrmVariables::_SerializeInto(SmartString& us, size_t& cnt)
{
    if(!_changed)    // 'changed' must be modified in caller when necessary
        return;
    int n = 0; // count of user variables/functions
	us.clear();
    for(int i = 1; i < sgUser->RowCount(); ++i)
    {
        if(!sgUser->String(0,i).empty() && !sgUser->String(1, i).empty())
        {
			us += SmartString(sgUser->String(0, i)) + ssCommentDelimiterString + SmartString(sgUser->String(1, i));
							// unit (even when empty)
			us += ssCommentDelimiterString + SmartString(sgUser->String(3, i));
							// description / body
			us += ssCommentDelimiterString + SmartString(sgUser->String(2, i)) + u"\n";
            ++n;
        }
    }
    cnt = n;
}

void TfrmVariables::_SetupGridLayout(int tabIndex)
{
	if (tabIndex == VARIABLES)	// variables Fields: name, unit, value,comment	
	{
		sgUser->SetColCount(4);
		sgUser->SetColWidth(0, _colW[0][0]);
		sgUser->SetColWidth(1, _colW[0][1]);
		sgUser->SetColWidth(2, _colW[0][2]);
		sgUser->SetColWidth(3, _colW[0][3]);
		sgBuiltin->SetColCount(4);
		sgBuiltin->SetColWidth(0, _colW[0][0]);
		sgBuiltin->SetColWidth(1, _colW[0][1]);
		sgBuiltin->SetColWidth(2, _colW[0][2]);
		sgBuiltin->SetColWidth(3, _colW[0][3]);
	}
	else				// functions. Fields: name, definition, comment
	{
		sgUser->SetColCount(4);
		sgUser->SetColWidth(0, _colW[1][0]);
		sgUser->SetColWidth(1, _colW[1][1]);
		sgUser->SetColWidth(2, _colW[1][2]);
		sgUser->SetColWidth(3, _colW[1][3]);
		sgBuiltin->SetColCount(4);
		sgBuiltin->SetColWidth(0, _colW[1][0]);
		sgBuiltin->SetColWidth(1, _colW[1][1]);
		sgBuiltin->SetColWidth(2, _colW[1][2]);
		sgBuiltin->SetColWidth(3, _colW[1][3]);
	}
}

/*=============================================================
 * TASK   :	to store user data from grid into 'tcVars' from previously
 *			active Tab, then set data into grid from 'tcVars'
 *			for the now active Tab
 * PARAMS :	sender:
 *			param:
 * EXPECTS:
 * GLOBALS:
 * RETURNS:
 * REMARKS: changes the number of columns and rows
 *------------------------------------------------------------*/
void TfrmVariables::tcVarsTabChange(void *sender, nlib::TabChangeParameters param)
{
	if (_activeTab == param.tabindex)// && sgBuiltin->RowCount() > 5)
		return;

	_activeTab = param.tabindex;

    size_t cntUser=0, cntBuiltin=0;
    SmartString *psUser=nullptr, *psBuiltin=nullptr;
    _changed = false;
	// and set data into actual Tab

	_SetupGridLayout(_activeTab);
    switch( _activeTab )
    {
		case FUNCTIONS:
			// collect info from previously active Tab
			_SerializeInto(_vf.sUserVars, _vf.uUserVarCnt);	// collect variables
			sgUser->SetString(0,0,L"Function(args)");
			sgUser->SetString(1,0,L"Definition");
			sgUser->SetString(2,0,L"Unit");
			sgUser->SetString(3,0,L"Comment");
            cntUser		= _vf.uUserFuncCnt;
            cntBuiltin	= _vf.uBuiltinFuncCnt;
            psUser		= &_vf.sUserFuncs;
            psBuiltin	= &_vf.sBuiltinFuncs;

            break;
		case VARIABLES:
			// collect info from previously active Tab
			_SerializeInto(_vf.sUserFuncs,_vf.uUserFuncCnt);	// collect functions
			sgUser->SetString(0,0,L"Variable");
			sgUser->SetString(1,0,L"Value");
			sgUser->SetString(2,0,L"Unit");
			sgUser->SetString(3,0,L"Comment");
			 
            cntUser    = _vf.uUserVarCnt;
            cntBuiltin = _vf.uBuiltinVarCnt;
            psUser		= &_vf.sUserVars;
            psBuiltin	= &_vf.sBuiltinVars;
            break;
    }
    if((size_t)sgUser->RowCount() != cntUser + (cntUser ? 1 : 2))
        sgUser->SetRowCount(cntUser + (cntUser ? 1 : 2));
    if((size_t)sgBuiltin->RowCount() != cntBuiltin)
        sgBuiltin->SetRowCount(cntBuiltin);

	if(cntUser == 0)
	{
		sgUser->SetString(0,1,L"");
		sgUser->SetString(1,1,L"");
		sgUser->SetString(2,1,L"");
		sgUser->SetString(3,1,L"");
	}

	std::vector<SmartString> sUserData, sBuiltinData;
	std::vector<SmartString> sUserLines, sBuiltinLines;

    switch( _activeTab )
    {
		case FUNCTIONS:
			sUserData = psUser->Split(SCharT('\n'), false);
			for (size_t i = 1; i <= cntUser; ++i)
			{
				int n = 0;
				sUserLines = sUserData[i-1].Split(schCommentDelimiter, true);
				sgUser->SetString(0,i,sUserLines[n].ToWideString());
				sgUser->SetString(1,i,sUserLines[++n].ToWideString());
				if(sUserLines.size() == 3)
					sgUser->SetString(2,i,L"-");
				else
					sgUser->SetString(2,i,sUserLines[++n].ToWideString());
				sgUser->SetString(3,i,sUserLines[++n].ToWideString());
			}
			sBuiltinData = psBuiltin->Split(SCharT('\n'), false);
			for (size_t i = 0; i < cntBuiltin; ++i)
			{
				sBuiltinLines = sBuiltinData[i].Split(schCommentDelimiter, true);

				sgBuiltin->SetString(0,i,sBuiltinLines[0].ToWideString());
				sgBuiltin->SetString(1,i,L"-");
				sgBuiltin->SetString(2,i,L"-");
				sgBuiltin->SetString(3,i,sBuiltinLines[2].ToWideString());
			}
			break;
		case VARIABLES:
			sUserData = psUser->Split(SCharT('\n'), false);
			if (!sUserData.empty())
			{
				// fields: <name>:<definition>[:<comment>[:<unit>]]
				// size: 2,3,4
				for (size_t i = 1; i <= cntUser; ++i)
				{
					sUserLines = sUserData[i - 1].Split(schCommentDelimiter, true);
					sgUser->SetString(0, i, sUserLines[0].ToWideString());		// name
					sgUser->SetString(1, i, sUserLines[1].ToWideString());		// definition
					sgUser->SetString(2, i, L"-");								// unit (may be modified below)
					switch (sUserLines.size())
					{
						case 2:	// nothing, no comment, no unit
							break;
						case 3:	// comment but no unit
							sgUser->SetString(3, i, sUserLines[2].ToWideString());
							break;
						default:// comment and unit
							sgUser->SetString(2, i, sUserLines[3].ToWideString());
							sgUser->SetString(3, i, sUserLines[2].ToWideString());
							break;
					}
				}
			}
			sBuiltinData = psBuiltin->Split(SCharT('\n'), false);
			for (size_t i = 0; i < cntBuiltin; ++i)
			{
				sBuiltinLines = sBuiltinData[i].Split(schCommentDelimiter, true);

				sgBuiltin->SetString(0,i,sBuiltinLines[0].ToWideString());
				sgBuiltin->SetString(1,i,sBuiltinLines[1].ToWideString());
				sgBuiltin->SetString(2,i,sBuiltinLines[2].ToWideString());
				sgBuiltin->SetString(3,i,sBuiltinLines[3].ToWideString());
			}
			break;
	}
}

void TfrmVariables::btnCancelClick(void *sender, nlib::EventParameters param)
{
    Close();
}

void TfrmVariables::btnClearClick(void *sender, nlib::EventParameters param)
{
	sgUser->SetRowCount(2);
	sgUser->SetString(0,1,L"");
	sgUser->SetString(1,1,L"");
	sgUser->SetString(2,1,L"");
	sgUser->SetString(3,1,L"");
	btnSave->SetEnabled(_changed = true);
}

void TfrmVariables::btnDelVarClick(void *sender, nlib::EventParameters param)
{
	int n = sgUser->Selected().y;
    if(n > 0)
    {
        if(sgUser->RowCount() == 2) 
            btnClearClick(sender,param);
        else
			sgUser->DeleteRow(n);
        _changed = true;
    }
	btnSave->SetEnabled(_changed);
}

void TfrmVariables::btnSaveClick(void *sender, nlib::EventParameters param)
{
    if(!_changed)		// should never happen
	{
		return;
	}
    switch( tcVars->SelectedTab() )
    {
       case VARIABLES: _SerializeInto(_vf.sUserVars, _vf.uUserVarCnt); 
				frmMain->pEngine()->AddUserVariablesAndFunctions(_vf.sUserVars,  1);
		   break;

       case FUNCTIONS: _SerializeInto(_vf.sUserFuncs,_vf.uUserFuncCnt); 
				frmMain->pEngine()->AddUserVariablesAndFunctions(_vf.sUserFuncs, 2);
		   break;
    }

    frmMain->edtInfixTextChanged(sender,param); // to reflect changed values
    _changed = false;
	btnSave->SetEnabled(_changed);
}

void TfrmVariables::sgBuiltinColumnSizing(void *sender, nlib::ColumnRowSizeParameters param)
{
	sgUser->SetColWidth(param.index, param.size );
	_colW[_activeTab][param.index] = param.size;
}

void TfrmVariables::sgUserColumnSizing(void *sender, nlib::ColumnRowSizeParameters param)
{
	sgBuiltin->SetColWidth(param.index, param.size );
	_colW[_activeTab][param.index] = param.size;
}

void TfrmVariables::FormClose(void *sender, nlib::FormCloseParameters param)
{
    param.action = caDeleteForm;
	frmVariables=NULL;
	SetFocus(frmMain->Handle());
}

void TfrmVariables::sgUserKeyPress(void *sender, nlib::KeyPressParameters param)
{
	if(param.key != VK_TAB && param.key != VK_RIGHT && param.key != VK_LEFT && param.key != VK_UP && param.key != VK_DOWN)
		btnSave->SetEnabled(_changed = true);
	if (param.key == '3' && param.vkeys & vksAlt)
	{
		nlib::EventParameters par;
		frmMain->miShowHistClick(nullptr, par);
	}
}

void TfrmVariables::sgUserEditorKeyDown(void *sender, nlib::KeyParameters param)
{
	if(param.keycode != VK_TAB && param.keycode != VK_RIGHT && param.keycode != VK_LEFT && param.keycode != VK_UP && param.keycode != VK_DOWN)
		btnSave->SetEnabled(_changed = true);

	if(param.keycode == VK_TAB)
	{
//		int x = sgUser->Selected().x;
		if( (param.vkeys & vksShift) == 0 &&  sgUser->Selected().x >= 2)
		{
			int n = sgUser->Selected().y + 1;
			if(n >= sgUser->RowCount())
			{
				sgUser->SetRowCount(n+1);
				sgUser->SetString(0, n, L"");
				sgUser->SetString(1,n, L"");
				sgUser->SetString(2,n, L"");
			}
			sgUser->SetSelected(0,n);
		}
	}

}
